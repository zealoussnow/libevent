<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libevent: event2/http.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>event2/http.h File Reference</h1>
<p>Basic support for HTTP serving.  
<a href="#_details">More...</a></p>
<code>#include &lt;<a class="el" href="util_8h_source.html">event2/util.h</a>&gt;</code><br/>

<p><a href="http_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ace576911d436a163584f4942907270a5">EVHTTP_URI_NONCONFORMANT</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tolerate URIs that do not conform to RFC3986.  <a href="#ace576911d436a163584f4942907270a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d93bc2b08ddc194c213682c4726b0e6"></a><!-- doxytag: member="http.h::HTTP_BADMETHOD" ref="a8d93bc2b08ddc194c213682c4726b0e6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a8d93bc2b08ddc194c213682c4726b0e6">HTTP_BADMETHOD</a>&nbsp;&nbsp;&nbsp;405</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">method not allowed for this uri <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9f070802de32cd2f820059fc42cbf39"></a><!-- doxytag: member="http.h::HTTP_BADREQUEST" ref="af9f070802de32cd2f820059fc42cbf39" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#af9f070802de32cd2f820059fc42cbf39">HTTP_BADREQUEST</a>&nbsp;&nbsp;&nbsp;400</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">invalid http request was made <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64236d9bad703199d84a08bee90e00f0"></a><!-- doxytag: member="http.h::HTTP_ENTITYTOOLARGE" ref="a64236d9bad703199d84a08bee90e00f0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>HTTP_ENTITYTOOLARGE</b>&nbsp;&nbsp;&nbsp;413</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4eac9f52d3d8de9b3deadaec6ad0bee9"></a><!-- doxytag: member="http.h::HTTP_EXPECTATIONFAILED" ref="a4eac9f52d3d8de9b3deadaec6ad0bee9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a4eac9f52d3d8de9b3deadaec6ad0bee9">HTTP_EXPECTATIONFAILED</a>&nbsp;&nbsp;&nbsp;417</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">we can't handle this expectation <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15eac402986428a8125d364b7ae569b1"></a><!-- doxytag: member="http.h::HTTP_INTERNAL" ref="a15eac402986428a8125d364b7ae569b1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a15eac402986428a8125d364b7ae569b1">HTTP_INTERNAL</a>&nbsp;&nbsp;&nbsp;500</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">internal error <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6ffbb7b69889f1eee0d413576c609a9"></a><!-- doxytag: member="http.h::HTTP_MOVEPERM" ref="ac6ffbb7b69889f1eee0d413576c609a9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ac6ffbb7b69889f1eee0d413576c609a9">HTTP_MOVEPERM</a>&nbsp;&nbsp;&nbsp;301</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the uri moved permanently <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d2a7341ba2af15babe8c25df67e563f"></a><!-- doxytag: member="http.h::HTTP_MOVETEMP" ref="a7d2a7341ba2af15babe8c25df67e563f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a7d2a7341ba2af15babe8c25df67e563f">HTTP_MOVETEMP</a>&nbsp;&nbsp;&nbsp;302</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the uri moved temporarily <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5e3a483119375a05d199c30709f2b8e"></a><!-- doxytag: member="http.h::HTTP_NOCONTENT" ref="ac5e3a483119375a05d199c30709f2b8e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ac5e3a483119375a05d199c30709f2b8e">HTTP_NOCONTENT</a>&nbsp;&nbsp;&nbsp;204</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">request does not have content <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f5b9c02b018640c890e5f27207fa6c0"></a><!-- doxytag: member="http.h::HTTP_NOTFOUND" ref="a1f5b9c02b018640c890e5f27207fa6c0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a1f5b9c02b018640c890e5f27207fa6c0">HTTP_NOTFOUND</a>&nbsp;&nbsp;&nbsp;404</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">could not find content for uri <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9759dd4ad026a688142afb7b4e4542cc"></a><!-- doxytag: member="http.h::HTTP_NOTIMPLEMENTED" ref="a9759dd4ad026a688142afb7b4e4542cc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a9759dd4ad026a688142afb7b4e4542cc">HTTP_NOTIMPLEMENTED</a>&nbsp;&nbsp;&nbsp;501</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">not implemented <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3112d58297965db46a04fe288bf1d0da"></a><!-- doxytag: member="http.h::HTTP_NOTMODIFIED" ref="a3112d58297965db46a04fe288bf1d0da" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a3112d58297965db46a04fe288bf1d0da">HTTP_NOTMODIFIED</a>&nbsp;&nbsp;&nbsp;304</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">page was not modified from last <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02e6d59009dee759528ec81fc9a8eeff"></a><!-- doxytag: member="http.h::HTTP_OK" ref="a02e6d59009dee759528ec81fc9a8eeff" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a02e6d59009dee759528ec81fc9a8eeff">HTTP_OK</a>&nbsp;&nbsp;&nbsp;200</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">request completed ok <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fd6829fe2bb38dd13288f11dcb2025f"></a><!-- doxytag: member="http.h::HTTP_SERVUNAVAIL" ref="a5fd6829fe2bb38dd13288f11dcb2025f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a5fd6829fe2bb38dd13288f11dcb2025f">HTTP_SERVUNAVAIL</a>&nbsp;&nbsp;&nbsp;503</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the server is not available <br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ac858319d667267f9fc848c2bb6931aa3">evhttp_cmd_type</a> { <br/>
&nbsp;&nbsp;<b>EVHTTP_REQ_GET</b> =  1 &lt;&lt; 0, 
<b>EVHTTP_REQ_POST</b> =  1 &lt;&lt; 1, 
<b>EVHTTP_REQ_HEAD</b> =  1 &lt;&lt; 2, 
<b>EVHTTP_REQ_PUT</b> =  1 &lt;&lt; 3, 
<br/>
&nbsp;&nbsp;<b>EVHTTP_REQ_DELETE</b> =  1 &lt;&lt; 4, 
<b>EVHTTP_REQ_OPTIONS</b> =  1 &lt;&lt; 5, 
<b>EVHTTP_REQ_TRACE</b> =  1 &lt;&lt; 6, 
<b>EVHTTP_REQ_CONNECT</b> =  1 &lt;&lt; 7, 
<br/>
&nbsp;&nbsp;<b>EVHTTP_REQ_PATCH</b> =  1 &lt;&lt; 8
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The different request types supported by evhttp. </p>
 <a href="http_8h.html#ac858319d667267f9fc848c2bb6931aa3">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a47ca41a942899d019bf59cf32301ae4f">evhttp_request_kind</a> { <b>EVHTTP_REQUEST</b>, 
<b>EVHTTP_RESPONSE</b>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>a request object can represent either a request or a reply </p>
<br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#aa5719654012b143ebfc0dfc9d4a8490d">evhttp_accept_socket</a> (struct evhttp *http, evutil_socket_t fd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes an HTTP server accept connections on the specified socket.  <a href="#aa5719654012b143ebfc0dfc9d4a8490d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct evhttp_bound_socket *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ae0b17d7e600e87cadda2352ea2135d8f">evhttp_accept_socket_with_handle</a> (struct evhttp *http, evutil_socket_t fd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="http_8h.html#aa5719654012b143ebfc0dfc9d4a8490d" title="Makes an HTTP server accept connections on the specified socket.">evhttp_accept_socket()</a>, but returns a handle for referencing the socket.  <a href="#ae0b17d7e600e87cadda2352ea2135d8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a04e3f41c14b8e0e74da13a8d308b93b7">evhttp_add_header</a> (struct evkeyvalq *headers, const char *key, const char *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a header to a list of existing headers.  <a href="#a04e3f41c14b8e0e74da13a8d308b93b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a58fe001925e7f65d7678bf90b31fc2a5">evhttp_add_server_alias</a> (struct evhttp *http, const char *alias)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a server alias to an http object.  <a href="#a58fe001925e7f65d7678bf90b31fc2a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a82d8fb72c5e8c76b787987ba5de5b141">evhttp_add_virtual_host</a> (struct evhttp *http, const char *pattern, struct evhttp *vhost)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a virtual host to the http server.  <a href="#a82d8fb72c5e8c76b787987ba5de5b141"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct evhttp_bound_socket *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#aa86abe883e71049f03534d984dd8c625">evhttp_bind_listener</a> (struct evhttp *http, struct evconnlistener *listener)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The most low-level evhttp_bind/accept method: takes an evconnlistener, and returns an evhttp_bound_socket.  <a href="#aa86abe883e71049f03534d984dd8c625"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a80ea2b819c0997a0ecc0d915446aeaa4">evhttp_bind_socket</a> (struct evhttp *http, const char *address, ev_uint16_t port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binds an HTTP server on the specified address and port.  <a href="#a80ea2b819c0997a0ecc0d915446aeaa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct evhttp_bound_socket *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a7b2e494399364cfb8071e69564c33db9">evhttp_bind_socket_with_handle</a> (struct evhttp *http, const char *address, ev_uint16_t port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="http_8h.html#a80ea2b819c0997a0ecc0d915446aeaa4" title="Binds an HTTP server on the specified address and port.">evhttp_bind_socket()</a>, but returns a handle for referencing the socket.  <a href="#a7b2e494399364cfb8071e69564c33db9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">evutil_socket_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a5b5912e3d764bbd8f4952aba0f0604fa">evhttp_bound_socket_get_fd</a> (struct evhttp_bound_socket *bound_socket)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the raw file descriptor referenced by an evhttp_bound_socket.  <a href="#a5b5912e3d764bbd8f4952aba0f0604fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b9ba15b143ece0f69a2b4c52ff9d788"></a><!-- doxytag: member="http.h::evhttp_bound_socket_get_listener" ref="a7b9ba15b143ece0f69a2b4c52ff9d788" args="(struct evhttp_bound_socket *bound)" -->
struct evconnlistener *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a7b9ba15b143ece0f69a2b4c52ff9d788">evhttp_bound_socket_get_listener</a> (struct evhttp_bound_socket *bound)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the listener used to implement a bound socket. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ab323fe297168f0f87af832f2bddc40a0">evhttp_cancel_request</a> (struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancels a pending HTTP request.  <a href="#ab323fe297168f0f87af832f2bddc40a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#adfd33f73c8d7af63a0da05ebb32b7e72">evhttp_clear_headers</a> (struct evkeyvalq *headers)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all headers from the header list.  <a href="#adfd33f73c8d7af63a0da05ebb32b7e72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct evhttp_connection *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#af5913a2851880df25cf9ef43f7646074">evhttp_connection_base_new</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, struct evdns_base *dnsbase, const char *address, unsigned short port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A connection object that can be used to for making HTTP requests.  <a href="#af5913a2851880df25cf9ef43f7646074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5afe0ffd71e479a9d830ac3800ba599"></a><!-- doxytag: member="http.h::evhttp_connection_free" ref="ab5afe0ffd71e479a9d830ac3800ba599" args="(struct evhttp_connection *evcon)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ab5afe0ffd71e479a9d830ac3800ba599">evhttp_connection_free</a> (struct evhttp_connection *evcon)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees an http connection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeeec8fa8b1c5836d05a0e552793b0945"></a><!-- doxytag: member="http.h::evhttp_connection_get_base" ref="aeeec8fa8b1c5836d05a0e552793b0945" args="(struct evhttp_connection *req)" -->
struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#aeeec8fa8b1c5836d05a0e552793b0945">evhttp_connection_get_base</a> (struct evhttp_connection *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the underlying <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> for this connection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39cc41e2c07c0a2042ecdd05248bd645"></a><!-- doxytag: member="http.h::evhttp_connection_get_bufferevent" ref="a39cc41e2c07c0a2042ecdd05248bd645" args="(struct evhttp_connection *evcon)" -->
struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a39cc41e2c07c0a2042ecdd05248bd645">evhttp_connection_get_bufferevent</a> (struct evhttp_connection *evcon)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> that an evhttp_connection is using. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#afa866e15c757e815a2e66cba7c8aa161">evhttp_connection_get_peer</a> (struct evhttp_connection *evcon, char **address, ev_uint16_t *port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the remote address and port associated with this connection.  <a href="#afa866e15c757e815a2e66cba7c8aa161"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#af62e12b843002e6eace204cc68da2277">evhttp_connection_set_closecb</a> (struct evhttp_connection *evcon, void(*)(struct evhttp_connection *, void *), void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a callback for connection close.  <a href="#af62e12b843002e6eace204cc68da2277"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a839b6cd03f4377fead26e8b680e9cd7e"></a><!-- doxytag: member="http.h::evhttp_connection_set_local_address" ref="a839b6cd03f4377fead26e8b680e9cd7e" args="(struct evhttp_connection *evcon, const char *address)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a839b6cd03f4377fead26e8b680e9cd7e">evhttp_connection_set_local_address</a> (struct evhttp_connection *evcon, const char *address)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets the ip address from which http connections are made <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a325b818c5c4f48a8ba1f3cf6a49d7f"></a><!-- doxytag: member="http.h::evhttp_connection_set_local_port" ref="a3a325b818c5c4f48a8ba1f3cf6a49d7f" args="(struct evhttp_connection *evcon, ev_uint16_t port)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a3a325b818c5c4f48a8ba1f3cf6a49d7f">evhttp_connection_set_local_port</a> (struct evhttp_connection *evcon, ev_uint16_t port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets the local port from which http connections are made <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05e5fc3a7488c3a32f28fde45d15c6e4"></a><!-- doxytag: member="http.h::evhttp_connection_set_max_body_size" ref="a05e5fc3a7488c3a32f28fde45d15c6e4" args="(struct evhttp_connection *evcon, ev_ssize_t new_max_body_size)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>evhttp_connection_set_max_body_size</b> (struct evhttp_connection *evcon, ev_ssize_t new_max_body_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeea564828181bbd3879b6af92224d4f6"></a><!-- doxytag: member="http.h::evhttp_connection_set_max_headers_size" ref="aeea564828181bbd3879b6af92224d4f6" args="(struct evhttp_connection *evcon, ev_ssize_t new_max_headers_size)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>evhttp_connection_set_max_headers_size</b> (struct evhttp_connection *evcon, ev_ssize_t new_max_headers_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9356b2a28a3b08bf273d027d1c40f470"></a><!-- doxytag: member="http.h::evhttp_connection_set_retries" ref="a9356b2a28a3b08bf273d027d1c40f470" args="(struct evhttp_connection *evcon, int retry_max)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a9356b2a28a3b08bf273d027d1c40f470">evhttp_connection_set_retries</a> (struct evhttp_connection *evcon, int retry_max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the retry limit for this connection - -1 repeats indefinitely. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa145623b7f58efe51908c6e48060db8c"></a><!-- doxytag: member="http.h::evhttp_connection_set_timeout" ref="aa145623b7f58efe51908c6e48060db8c" args="(struct evhttp_connection *evcon, int timeout_in_secs)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#aa145623b7f58efe51908c6e48060db8c">evhttp_connection_set_timeout</a> (struct evhttp_connection *evcon, int timeout_in_secs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the timeout for events related to this connection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a681a8e967dec9f73fb8e27f465fdae4b">evhttp_decode_uri</a> (const char *uri)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to sort of decode a URI-encoded string.  <a href="#a681a8e967dec9f73fb8e27f465fdae4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a5404c30f3b50a664f2ec1500ebb30d86">evhttp_del_accept_socket</a> (struct evhttp *http, struct evhttp_bound_socket *bound_socket)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes an HTTP server stop accepting connections on the specified socket.  <a href="#a5404c30f3b50a664f2ec1500ebb30d86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26b24365ab036cbce853fedc7818bc49"></a><!-- doxytag: member="http.h::evhttp_del_cb" ref="a26b24365ab036cbce853fedc7818bc49" args="(struct evhttp *, const char *)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a26b24365ab036cbce853fedc7818bc49">evhttp_del_cb</a> (struct evhttp *, const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the callback for a specified URI. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a2b6d14272efe8d5f6bb110666a2032fd">evhttp_encode_uri</a> (const char *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to encode a string for inclusion in a URI.  <a href="#a2b6d14272efe8d5f6bb110666a2032fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a3a36842fd6f74977c9c0fb7aa5578832">evhttp_find_header</a> (const struct evkeyvalq *headers, const char *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the value belonging to a header.  <a href="#a3a36842fd6f74977c9c0fb7aa5578832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a849acf0f233772b486b8057fcf3aaf4a">evhttp_free</a> (struct evhttp *http)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the previously created HTTP server.  <a href="#a849acf0f233772b486b8057fcf3aaf4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ac9318bd77cb5f4030b434bea99b3828e">evhttp_htmlescape</a> (const char *html)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Escape HTML character entities in a string.  <a href="#ac9318bd77cb5f4030b434bea99b3828e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a70af2a5e67da78782e06c640b9f85d4e">evhttp_make_request</a> (struct evhttp_connection *evcon, struct evhttp_request *req, enum <a class="el" href="http_8h.html#ac858319d667267f9fc848c2bb6931aa3">evhttp_cmd_type</a> type, const char *uri)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an HTTP request over the specified connection.  <a href="#a70af2a5e67da78782e06c640b9f85d4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct evhttp *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ab8c84271a97fd85957cf72b1161b8216">evhttp_new</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new HTTP server.  <a href="#ab8c84271a97fd85957cf72b1161b8216"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a12d3940d23fb53c38106f8ac0d3dfff6">evhttp_parse_query</a> (const char *uri, struct evkeyvalq *headers)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to parse out arguments in a query.  <a href="#a12d3940d23fb53c38106f8ac0d3dfff6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a1598fb5757f39dde6dc43dee9a2e7fca">evhttp_parse_query_str</a> (const char *uri, struct evkeyvalq *headers)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to parse out arguments from the query portion of an HTTP URI.  <a href="#a1598fb5757f39dde6dc43dee9a2e7fca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ab87600f14a6f8c36beedbeed8267b856">evhttp_remove_header</a> (struct evkeyvalq *headers, const char *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a header from a list of existing headers.  <a href="#ab87600f14a6f8c36beedbeed8267b856"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a88fe4c5507e88c4db284ea30a0478e5d">evhttp_remove_server_alias</a> (struct evhttp *http, const char *alias)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a server alias from an http object.  <a href="#a88fe4c5507e88c4db284ea30a0478e5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ab2eb1ac82f36e7f0180b18d4553d3994">evhttp_remove_virtual_host</a> (struct evhttp *http, struct evhttp *vhost)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a virtual host from the http server.  <a href="#ab2eb1ac82f36e7f0180b18d4553d3994"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#aad0392c873fa034be3ff09d4f8b68aba">evhttp_request_free</a> (struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees the request object and removes associated events.  <a href="#aad0392c873fa034be3ff09d4f8b68aba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a552bcfe23acec6858742e44a1b932dad"></a><!-- doxytag: member="http.h::evhttp_request_get_command" ref="a552bcfe23acec6858742e44a1b932dad" args="(const struct evhttp_request *req)" -->
enum <a class="el" href="http_8h.html#ac858319d667267f9fc848c2bb6931aa3">evhttp_cmd_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a552bcfe23acec6858742e44a1b932dad">evhttp_request_get_command</a> (const struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the request command. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct evhttp_connection *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a92a534f00172fa452c45c9f3fc42d6f5">evhttp_request_get_connection</a> (struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the connection object associated with the request or NULL.  <a href="#a92a534f00172fa452c45c9f3fc42d6f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cc0812787263e4473b2bd25fcade9c2"></a><!-- doxytag: member="http.h::evhttp_request_get_evhttp_uri" ref="a4cc0812787263e4473b2bd25fcade9c2" args="(const struct evhttp_request *req)" -->
struct evhttp_uri *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a4cc0812787263e4473b2bd25fcade9c2">evhttp_request_get_evhttp_uri</a> (const struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the request URI (parsed). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#aac84865e4848b8d9089e4182e12d185e">evhttp_request_get_host</a> (struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the host associated with the request.  <a href="#aac84865e4848b8d9089e4182e12d185e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa939f28c8da2a8122097de23c7670321"></a><!-- doxytag: member="http.h::evhttp_request_get_input_buffer" ref="aa939f28c8da2a8122097de23c7670321" args="(struct evhttp_request *req)" -->
struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#aa939f28c8da2a8122097de23c7670321">evhttp_request_get_input_buffer</a> (struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the input buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a034fca99ce0cc5ff3b7f56744915a8be"></a><!-- doxytag: member="http.h::evhttp_request_get_input_headers" ref="a034fca99ce0cc5ff3b7f56744915a8be" args="(struct evhttp_request *req)" -->
struct evkeyvalq *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a034fca99ce0cc5ff3b7f56744915a8be">evhttp_request_get_input_headers</a> (struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the input headers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dc23de32b242457db98ab566c53f71f"></a><!-- doxytag: member="http.h::evhttp_request_get_output_buffer" ref="a8dc23de32b242457db98ab566c53f71f" args="(struct evhttp_request *req)" -->
struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a8dc23de32b242457db98ab566c53f71f">evhttp_request_get_output_buffer</a> (struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the output buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1321a89525b6336fce624e28de41b49"></a><!-- doxytag: member="http.h::evhttp_request_get_output_headers" ref="ae1321a89525b6336fce624e28de41b49" args="(struct evhttp_request *req)" -->
struct evkeyvalq *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ae1321a89525b6336fce624e28de41b49">evhttp_request_get_output_headers</a> (struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the output headers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1452ea8db0ddb07f52d5de739f026af"></a><!-- doxytag: member="http.h::evhttp_request_get_response_code" ref="ac1452ea8db0ddb07f52d5de739f026af" args="(const struct evhttp_request *req)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>evhttp_request_get_response_code</b> (const struct evhttp_request *req)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78ce0bb30083afddb525cb9fa0b30ae0"></a><!-- doxytag: member="http.h::evhttp_request_get_uri" ref="a78ce0bb30083afddb525cb9fa0b30ae0" args="(const struct evhttp_request *req)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a78ce0bb30083afddb525cb9fa0b30ae0">evhttp_request_get_uri</a> (const struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the request URI. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25516c0fb1b0ef47c81f623da3782bd1"></a><!-- doxytag: member="http.h::evhttp_request_is_owned" ref="a25516c0fb1b0ef47c81f623da3782bd1" args="(struct evhttp_request *req)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a25516c0fb1b0ef47c81f623da3782bd1">evhttp_request_is_owned</a> (struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns 1 if the request is owned by the user. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct evhttp_request *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a2f40f147e37f9a40f8ef684fb8f2d6b0">evhttp_request_new</a> (void(*cb)(struct evhttp_request *, void *), void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new request object that needs to be filled in with the request parameters.  <a href="#a2f40f147e37f9a40f8ef684fb8f2d6b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a93a13d12f579bf22af35e2f1a6d82f4c">evhttp_request_own</a> (struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Takes ownership of the request object.  <a href="#a93a13d12f579bf22af35e2f1a6d82f4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a3dd375d81eac9baabc53749ed025ec12">evhttp_request_set_chunked_cb</a> (struct evhttp_request *, void(*cb)(struct evhttp_request *, void *))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable delivery of chunks to requestor.  <a href="#a3dd375d81eac9baabc53749ed025ec12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a629ef7f70ed916e162dee3bd12e397c9">evhttp_send_error</a> (struct evhttp_request *req, int error, const char *reason)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send an HTML error message to the client.  <a href="#a629ef7f70ed916e162dee3bd12e397c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a9df5ec9adc9bc664db5d6b161a293525">evhttp_send_reply</a> (struct evhttp_request *req, int code, const char *reason, struct <a class="el" href="structevbuffer.html">evbuffer</a> *databuf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send an HTML reply to the client.  <a href="#a9df5ec9adc9bc664db5d6b161a293525"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a7950f70e66678fda56fdf8288811639c">evhttp_send_reply_chunk</a> (struct evhttp_request *req, struct <a class="el" href="structevbuffer.html">evbuffer</a> *databuf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send another data chunk as part of an ongoing chunked reply.  <a href="#a7950f70e66678fda56fdf8288811639c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a77024706313626c5857089b08ec5e0ae">evhttp_send_reply_end</a> (struct evhttp_request *req)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Complete a chunked reply, freeing the request as appropriate.  <a href="#a77024706313626c5857089b08ec5e0ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a69c93aab46133521997cdfb8c2e07195">evhttp_send_reply_start</a> (struct evhttp_request *req, int code, const char *reason)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiate a reply that uses Transfer-Encoding chunked.  <a href="#a69c93aab46133521997cdfb8c2e07195"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ae63a0370f59570e00753f7fb512a7f59">evhttp_set_allowed_methods</a> (struct evhttp *http, ev_uint16_t methods)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the what HTTP methods are supported in requests accepted by this server, and passed to user callbacks.  <a href="#ae63a0370f59570e00753f7fb512a7f59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a5b685afe43d7f4c3bfcc7dcba72d41e0">evhttp_set_cb</a> (struct evhttp *http, const char *path, void(*cb)(struct evhttp_request *, void *), void *cb_arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a callback for a specified URI.  <a href="#a5b685afe43d7f4c3bfcc7dcba72d41e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ad3466287c0054d32dfd538a3bdfb0374">evhttp_set_gencb</a> (struct evhttp *http, void(*cb)(struct evhttp_request *, void *), void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a callback for all requests that are not caught by specific callbacks.  <a href="#ad3466287c0054d32dfd538a3bdfb0374"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a8406065dcb34f9a058b2a7a6988ac351">evhttp_set_max_body_size</a> (struct evhttp *http, ev_ssize_t max_body_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XXX Document.  <a href="#a8406065dcb34f9a058b2a7a6988ac351"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ae936aa6e7b0cb9617d0548a952db93cf">evhttp_set_max_headers_size</a> (struct evhttp *http, ev_ssize_t max_headers_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XXX Document.  <a href="#ae936aa6e7b0cb9617d0548a952db93cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#acc8bb4d9e196f957510b5db9f6a02e44">evhttp_set_timeout</a> (struct evhttp *http, int timeout_in_secs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the timeout for an HTTP request.  <a href="#acc8bb4d9e196f957510b5db9f6a02e44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a5ee82311278b8fda3ed93a8e358683bb">evhttp_uri_free</a> (struct evhttp_uri *uri)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all memory allocated for a parsed uri.  <a href="#a5ee82311278b8fda3ed93a8e358683bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7fcd64c02bb074bc9c754e8107550c1"></a><!-- doxytag: member="http.h::evhttp_uri_get_fragment" ref="ad7fcd64c02bb074bc9c754e8107550c1" args="(const struct evhttp_uri *uri)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ad7fcd64c02bb074bc9c754e8107550c1">evhttp_uri_get_fragment</a> (const struct evhttp_uri *uri)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the fragment part of an evhttp_uri (excluding the leading "#"), or NULL if it has no fragment set. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a2d45134ab552432fbe25eb2ff646f906">evhttp_uri_get_host</a> (const struct evhttp_uri *uri)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the host part of an evhttp_uri, or NULL if it has no host set.  <a href="#a2d45134ab552432fbe25eb2ff646f906"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49e685022515780b3dfb4d944b4cce4d"></a><!-- doxytag: member="http.h::evhttp_uri_get_path" ref="a49e685022515780b3dfb4d944b4cce4d" args="(const struct evhttp_uri *uri)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a49e685022515780b3dfb4d944b4cce4d">evhttp_uri_get_path</a> (const struct evhttp_uri *uri)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the path part of an evhttp_uri, or NULL if it has no path set. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a60d456504f4f93f61384eb0b526f5a4c">evhttp_uri_get_port</a> (const struct evhttp_uri *uri)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the port part of an evhttp_uri, or -1 if there is no port set.  <a href="#a60d456504f4f93f61384eb0b526f5a4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a8c53b664a23dbdebd99d768a17590e"></a><!-- doxytag: member="http.h::evhttp_uri_get_query" ref="a9a8c53b664a23dbdebd99d768a17590e" args="(const struct evhttp_uri *uri)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a9a8c53b664a23dbdebd99d768a17590e">evhttp_uri_get_query</a> (const struct evhttp_uri *uri)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the query part of an evhttp_uri (excluding the leading "?"), or NULL if it has no query set. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a6f49cc20f421d2f66907c613d24ad3dc">evhttp_uri_get_scheme</a> (const struct evhttp_uri *uri)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the scheme of an evhttp_uri, or NULL if there is no scheme has been set and the evhttp_uri contains a Relative-Ref.  <a href="#a6f49cc20f421d2f66907c613d24ad3dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfc9eeca8691a9f55dad523e60f1a467"></a><!-- doxytag: member="http.h::evhttp_uri_get_userinfo" ref="adfc9eeca8691a9f55dad523e60f1a467" args="(const struct evhttp_uri *uri)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#adfc9eeca8691a9f55dad523e60f1a467">evhttp_uri_get_userinfo</a> (const struct evhttp_uri *uri)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the userinfo part of an evhttp_uri, or NULL if it has no userinfo set. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a60f7217fccc2bdfb9cb6abeb1c4ad102">evhttp_uri_join</a> (struct evhttp_uri *uri, char *buf, size_t limit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Join together the uri parts from parsed data to form a URI-Reference.  <a href="#a60f7217fccc2bdfb9cb6abeb1c4ad102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2847be10a24befd3c65d412690475110"></a><!-- doxytag: member="http.h::evhttp_uri_new" ref="a2847be10a24befd3c65d412690475110" args="(void)" -->
struct evhttp_uri *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a2847be10a24befd3c65d412690475110">evhttp_uri_new</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a new empty evhttp_uri with no fields set. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47bc072177c8e839083c511a618a422c"></a><!-- doxytag: member="http.h::evhttp_uri_parse" ref="a47bc072177c8e839083c511a618a422c" args="(const char *source_uri)" -->
struct evhttp_uri *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a47bc072177c8e839083c511a618a422c">evhttp_uri_parse</a> (const char *source_uri)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Alias for evhttp_uri_parse_with_flags(source_uri, 0). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct evhttp_uri *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ad9f9447cb1c3c92e40478b98ff30db60">evhttp_uri_parse_with_flags</a> (const char *source_uri, unsigned flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to parse a URI-Reference as specified by RFC3986.  <a href="#ad9f9447cb1c3c92e40478b98ff30db60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#aea0b990f1ca5ba71feffa96c8f6bd06b">evhttp_uri_set_flags</a> (struct evhttp_uri *uri, unsigned flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the flags set on a given URI.  <a href="#aea0b990f1ca5ba71feffa96c8f6bd06b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a36b844028058c82b6709d1e0fe7e1cf9">evhttp_uri_set_fragment</a> (struct evhttp_uri *uri, const char *fragment)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the fragment of an evhttp_uri, or clear the fragment if fragment==NULL.  <a href="#a36b844028058c82b6709d1e0fe7e1cf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a103c447efb9f41a5897b3aa130424734">evhttp_uri_set_host</a> (struct evhttp_uri *uri, const char *host)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the host of an evhttp_uri, or clear the host if host==NULL.  <a href="#a103c447efb9f41a5897b3aa130424734"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ae6bbfc5cf62df674ba72800ea46c5828">evhttp_uri_set_path</a> (struct evhttp_uri *uri, const char *path)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the path of an evhttp_uri, or clear the path if path==NULL.  <a href="#ae6bbfc5cf62df674ba72800ea46c5828"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#a8cc430f9b8fb4c6aa11692d5ef0b383c">evhttp_uri_set_port</a> (struct evhttp_uri *uri, int port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the port of an evhttp_uri, or clear the port if port==-1.  <a href="#a8cc430f9b8fb4c6aa11692d5ef0b383c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#aaf999637136bc1785e5d75c191c671ba">evhttp_uri_set_query</a> (struct evhttp_uri *uri, const char *query)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the query of an evhttp_uri, or clear the query if query==NULL.  <a href="#aaf999637136bc1785e5d75c191c671ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#abf5f82fb9c8f8df0b1b4c73691791dd5">evhttp_uri_set_scheme</a> (struct evhttp_uri *uri, const char *scheme)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scheme of an evhttp_uri, or clear the scheme if scheme==NULL.  <a href="#abf5f82fb9c8f8df0b1b4c73691791dd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ac7b10b8ef8ee94d14674f9329486d355">evhttp_uri_set_userinfo</a> (struct evhttp_uri *uri, const char *userinfo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the userinfo of an evhttp_uri, or clear the userinfo if userinfo==NULL.  <a href="#ac7b10b8ef8ee94d14674f9329486d355"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ac2914389616f04199aded10444fd8e42">evhttp_uridecode</a> (const char *uri, int decode_plus, size_t *size_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function to decode a URI-escaped string or HTTP parameter.  <a href="#ac2914389616f04199aded10444fd8e42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="http_8h.html#ab64229249a981ccfea09161a199972da">evhttp_uriencode</a> (const char *str, ev_ssize_t size, int space_to_plus)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As evhttp_encode_uri, but if 'size' is nonnegative, treat the string as being 'size' bytes long.  <a href="#ab64229249a981ccfea09161a199972da"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Basic support for HTTP serving. </p>
<p>As Libevent is a library for dealing with <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> notification and most interesting applications are networked today, I have often found the need to write HTTP code. The following prototypes and definitions provide an application with a minimal interface for making HTTP requests and for creating a very simple HTTP server. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ace576911d436a163584f4942907270a5"></a><!-- doxytag: member="http.h::EVHTTP_URI_NONCONFORMANT" ref="ace576911d436a163584f4942907270a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVHTTP_URI_NONCONFORMANT&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tolerate URIs that do not conform to RFC3986. </p>
<p>Unfortunately, some HTTP clients generate URIs that, according to RFC3986, are not conformant URIs. If you need to support these URIs, you can do so by passing this flag to evhttp_uri_parse_with_flags.</p>
<p>Currently, these changes are: </p>
<ul>
<li>
Nonconformant URIs are allowed to contain otherwise unreasonable characters in their path, query, and fragment components. </li>
</ul>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ac858319d667267f9fc848c2bb6931aa3"></a><!-- doxytag: member="http.h::evhttp_cmd_type" ref="ac858319d667267f9fc848c2bb6931aa3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="http_8h.html#ac858319d667267f9fc848c2bb6931aa3">evhttp_cmd_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The different request types supported by evhttp. </p>
<p>These are as specified in RFC2616, except for PATCH which is specified by RFC5789.</p>
<p>By default, only some of these methods are accepted and passed to user callbacks; use <a class="el" href="http_8h.html#ae63a0370f59570e00753f7fb512a7f59" title="Sets the what HTTP methods are supported in requests accepted by this server, and...">evhttp_set_allowed_methods()</a> to change which methods are allowed. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa5719654012b143ebfc0dfc9d4a8490d"></a><!-- doxytag: member="http.h::evhttp_accept_socket" ref="aa5719654012b143ebfc0dfc9d4a8490d" args="(struct evhttp *http, evutil_socket_t fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_accept_socket </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname"> <em>fd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes an HTTP server accept connections on the specified socket. </p>
<p>This may be useful to create a socket and then fork multiple instances of an http server, or when a socket has been communicated via file descriptor passing in situations where an http servers does not have permissions to bind to a low-numbered port.</p>
<p>Can be called multiple times to have the http server listen to multiple different sockets.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>a pointer to an evhttp object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>a socket fd that is ready for accepting connections </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#a80ea2b819c0997a0ecc0d915446aeaa4" title="Binds an HTTP server on the specified address and port.">evhttp_bind_socket()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae0b17d7e600e87cadda2352ea2135d8f"></a><!-- doxytag: member="http.h::evhttp_accept_socket_with_handle" ref="ae0b17d7e600e87cadda2352ea2135d8f" args="(struct evhttp *http, evutil_socket_t fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct evhttp_bound_socket* evhttp_accept_socket_with_handle </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname"> <em>fd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like <a class="el" href="http_8h.html#aa5719654012b143ebfc0dfc9d4a8490d" title="Makes an HTTP server accept connections on the specified socket.">evhttp_accept_socket()</a>, but returns a handle for referencing the socket. </p>
<p>The returned pointer is not valid after <em>http</em> is freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>a pointer to an evhttp object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>a socket fd that is ready for accepting connections </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Handle for the socket on success, NULL on failure. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#aa5719654012b143ebfc0dfc9d4a8490d" title="Makes an HTTP server accept connections on the specified socket.">evhttp_accept_socket()</a>, <a class="el" href="http_8h.html#a5404c30f3b50a664f2ec1500ebb30d86" title="Makes an HTTP server stop accepting connections on the specified socket.">evhttp_del_accept_socket()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a04e3f41c14b8e0e74da13a8d308b93b7"></a><!-- doxytag: member="http.h::evhttp_add_header" ref="a04e3f41c14b8e0e74da13a8d308b93b7" args="(struct evkeyvalq *headers, const char *key, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_add_header </td>
          <td>(</td>
          <td class="paramtype">struct evkeyvalq *&nbsp;</td>
          <td class="paramname"> <em>headers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a header to a list of existing headers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>headers</em>&nbsp;</td><td>the evkeyvalq object to which to add a header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the name of the header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>the value belonging to the header </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 otherwise. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#a3a36842fd6f74977c9c0fb7aa5578832" title="Finds the value belonging to a header.">evhttp_find_header()</a>, <a class="el" href="http_8h.html#adfd33f73c8d7af63a0da05ebb32b7e72" title="Removes all headers from the header list.">evhttp_clear_headers()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a58fe001925e7f65d7678bf90b31fc2a5"></a><!-- doxytag: member="http.h::evhttp_add_server_alias" ref="a58fe001925e7f65d7678bf90b31fc2a5" args="(struct evhttp *http, const char *alias)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_add_server_alias </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>alias</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a server alias to an http object. </p>
<p>The http object can be a virtual host or the main server.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>the evhttp object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alias</em>&nbsp;</td><td>the alias to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>evhttp_add_remove_alias() </dd></dl>

</div>
</div>
<a class="anchor" id="a82d8fb72c5e8c76b787987ba5de5b141"></a><!-- doxytag: member="http.h::evhttp_add_virtual_host" ref="a82d8fb72c5e8c76b787987ba5de5b141" args="(struct evhttp *http, const char *pattern, struct evhttp *vhost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_add_virtual_host </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>vhost</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a virtual host to the http server. </p>
<p>A virtual host is a newly initialized evhttp object that has request callbacks set on it via <a class="el" href="http_8h.html#a5b685afe43d7f4c3bfcc7dcba72d41e0" title="Set a callback for a specified URI.">evhttp_set_cb()</a> or <a class="el" href="http_8h.html#ad3466287c0054d32dfd538a3bdfb0374" title="Set a callback for all requests that are not caught by specific callbacks.">evhttp_set_gencb()</a>. It most not have any listing sockets associated with it.</p>
<p>If the virtual host has not been removed by the time that <a class="el" href="http_8h.html#a849acf0f233772b486b8057fcf3aaf4a" title="Free the previously created HTTP server.">evhttp_free()</a> is called on the main http server, it will be automatically freed, too.</p>
<p>It is possible to have hierarchical vhosts. For example: A vhost with the pattern *.example.com may have other vhosts with patterns foo.example.com and bar.example.com associated with it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>the evhttp object to which to add a virtual host </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pattern</em>&nbsp;</td><td>the glob pattern against which the hostname is matched. The match is case insensitive and follows otherwise regular shell matching. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vhost</em>&nbsp;</td><td>the virtual host to add the regular http server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#ab2eb1ac82f36e7f0180b18d4553d3994" title="Removes a virtual host from the http server.">evhttp_remove_virtual_host()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa86abe883e71049f03534d984dd8c625"></a><!-- doxytag: member="http.h::evhttp_bind_listener" ref="aa86abe883e71049f03534d984dd8c625" args="(struct evhttp *http, struct evconnlistener *listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct evhttp_bound_socket* evhttp_bind_listener </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct evconnlistener *&nbsp;</td>
          <td class="paramname"> <em>listener</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The most low-level evhttp_bind/accept method: takes an evconnlistener, and returns an evhttp_bound_socket. </p>
<p>The listener will be freed when the bound socket is freed. </p>

</div>
</div>
<a class="anchor" id="a80ea2b819c0997a0ecc0d915446aeaa4"></a><!-- doxytag: member="http.h::evhttp_bind_socket" ref="a80ea2b819c0997a0ecc0d915446aeaa4" args="(struct evhttp *http, const char *address, ev_uint16_t port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_bind_socket </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint16_t&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Binds an HTTP server on the specified address and port. </p>
<p>Can be called multiple times to bind the same http server to multiple different ports.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>a pointer to an evhttp object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>a string containing the IP address to listen(2) on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>the port number to listen on </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#aa5719654012b143ebfc0dfc9d4a8490d" title="Makes an HTTP server accept connections on the specified socket.">evhttp_accept_socket()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7b2e494399364cfb8071e69564c33db9"></a><!-- doxytag: member="http.h::evhttp_bind_socket_with_handle" ref="a7b2e494399364cfb8071e69564c33db9" args="(struct evhttp *http, const char *address, ev_uint16_t port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct evhttp_bound_socket* evhttp_bind_socket_with_handle </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint16_t&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like <a class="el" href="http_8h.html#a80ea2b819c0997a0ecc0d915446aeaa4" title="Binds an HTTP server on the specified address and port.">evhttp_bind_socket()</a>, but returns a handle for referencing the socket. </p>
<p>The returned pointer is not valid after <em>http</em> is freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>a pointer to an evhttp object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>a string containing the IP address to listen(2) on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>the port number to listen on </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Handle for the socket on success, NULL on failure. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#a80ea2b819c0997a0ecc0d915446aeaa4" title="Binds an HTTP server on the specified address and port.">evhttp_bind_socket()</a>, <a class="el" href="http_8h.html#a5404c30f3b50a664f2ec1500ebb30d86" title="Makes an HTTP server stop accepting connections on the specified socket.">evhttp_del_accept_socket()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5b5912e3d764bbd8f4952aba0f0604fa"></a><!-- doxytag: member="http.h::evhttp_bound_socket_get_fd" ref="a5b5912e3d764bbd8f4952aba0f0604fa" args="(struct evhttp_bound_socket *bound_socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evutil_socket_t evhttp_bound_socket_get_fd </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_bound_socket *&nbsp;</td>
          <td class="paramname"> <em>bound_socket</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the raw file descriptor referenced by an evhttp_bound_socket. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bound_socket</em>&nbsp;</td><td>a handle returned by evhttp_{bind,accept}_socket_with_handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the file descriptor used by the bound socket </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#a7b2e494399364cfb8071e69564c33db9" title="Like evhttp_bind_socket(), but returns a handle for referencing the socket.">evhttp_bind_socket_with_handle()</a>, <a class="el" href="http_8h.html#ae0b17d7e600e87cadda2352ea2135d8f" title="Like evhttp_accept_socket(), but returns a handle for referencing the socket.">evhttp_accept_socket_with_handle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab323fe297168f0f87af832f2bddc40a0"></a><!-- doxytag: member="http.h::evhttp_cancel_request" ref="ab323fe297168f0f87af832f2bddc40a0" args="(struct evhttp_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_cancel_request </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_request *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancels a pending HTTP request. </p>
<p>Cancels an ongoing HTTP request. The callback associated with this request is not executed and the request object is freed. If the request is currently being processed, e.g. it is ongoing, the corresponding evhttp_connection object is going to get reset.</p>
<p>A request cannot be canceled if its callback has executed already. A request may be canceled reentrantly from its chunked callback.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>the evhttp_request to cancel; req becomes invalid after this call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfd33f73c8d7af63a0da05ebb32b7e72"></a><!-- doxytag: member="http.h::evhttp_clear_headers" ref="adfd33f73c8d7af63a0da05ebb32b7e72" args="(struct evkeyvalq *headers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_clear_headers </td>
          <td>(</td>
          <td class="paramtype">struct evkeyvalq *&nbsp;</td>
          <td class="paramname"> <em>headers</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all headers from the header list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>headers</em>&nbsp;</td><td>the evkeyvalq object from which to remove all headers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5913a2851880df25cf9ef43f7646074"></a><!-- doxytag: member="http.h::evhttp_connection_base_new" ref="af5913a2851880df25cf9ef43f7646074" args="(struct event_base *base, struct evdns_base *dnsbase, const char *address, unsigned short port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct evhttp_connection* evhttp_connection_base_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct evdns_base *&nbsp;</td>
          <td class="paramname"> <em>dnsbase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A connection object that can be used to for making HTTP requests. </p>
<p>The connection object tries to resolve address and establish the connection when it is given an http request object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>the <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> to use for handling the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dnsbase</em>&nbsp;</td><td>the dns_base to use for resolving host names; if not specified host name resolution will block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>the address to which to connect </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>the port to connect to </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an evhttp_connection object that can be used for making requests </dd></dl>

</div>
</div>
<a class="anchor" id="afa866e15c757e815a2e66cba7c8aa161"></a><!-- doxytag: member="http.h::evhttp_connection_get_peer" ref="afa866e15c757e815a2e66cba7c8aa161" args="(struct evhttp_connection *evcon, char **address, ev_uint16_t *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_connection_get_peer </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_connection *&nbsp;</td>
          <td class="paramname"> <em>evcon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint16_t *&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the remote address and port associated with this connection. </p>

</div>
</div>
<a class="anchor" id="af62e12b843002e6eace204cc68da2277"></a><!-- doxytag: member="http.h::evhttp_connection_set_closecb" ref="af62e12b843002e6eace204cc68da2277" args="(struct evhttp_connection *evcon, void(*)(struct evhttp_connection *, void *), void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_connection_set_closecb </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_connection *&nbsp;</td>
          <td class="paramname"> <em>evcon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct evhttp_connection *, void *)&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a callback for connection close. </p>

</div>
</div>
<a class="anchor" id="a681a8e967dec9f73fb8e27f465fdae4b"></a><!-- doxytag: member="http.h::evhttp_decode_uri" ref="a681a8e967dec9f73fb8e27f465fdae4b" args="(const char *uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* evhttp_decode_uri </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uri</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to sort of decode a URI-encoded string. </p>
<p>Unlike evhttp_get_decoded_uri, it decodes all plus characters that appear _after_ the first question mark character, but no plusses that occur before. This is not a good way to decode URIs in whole or in part.</p>
<p>The returned string must be freed by the caller</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>This function is deprecated; you probably want to use evhttp_get_decoded_uri instead.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uri</em>&nbsp;</td><td>an encoded URI </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated unencoded URI or NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a5404c30f3b50a664f2ec1500ebb30d86"></a><!-- doxytag: member="http.h::evhttp_del_accept_socket" ref="a5404c30f3b50a664f2ec1500ebb30d86" args="(struct evhttp *http, struct evhttp_bound_socket *bound_socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_del_accept_socket </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct evhttp_bound_socket *&nbsp;</td>
          <td class="paramname"> <em>bound_socket</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes an HTTP server stop accepting connections on the specified socket. </p>
<p>This may be useful when a socket has been sent via file descriptor passing and is no longer needed by the current process.</p>
<p>If you created this bound socket with evhttp_bind_socket_with_handle or evhttp_accept_socket_with_handle, this function closes the fd you provided. If you created this bound socket with evhttp_bind_listener, this function frees the listener you provided.</p>
<p><em>bound_socket</em> is an invalid pointer after this call returns.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>a pointer to an evhttp object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bound_socket</em>&nbsp;</td><td>a handle returned by evhttp_{bind,accept}_socket_with_handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#a7b2e494399364cfb8071e69564c33db9" title="Like evhttp_bind_socket(), but returns a handle for referencing the socket.">evhttp_bind_socket_with_handle()</a>, <a class="el" href="http_8h.html#ae0b17d7e600e87cadda2352ea2135d8f" title="Like evhttp_accept_socket(), but returns a handle for referencing the socket.">evhttp_accept_socket_with_handle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2b6d14272efe8d5f6bb110666a2032fd"></a><!-- doxytag: member="http.h::evhttp_encode_uri" ref="a2b6d14272efe8d5f6bb110666a2032fd" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* evhttp_encode_uri </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to encode a string for inclusion in a URI. </p>
<p>All characters are replaced by their hex-escaped (22) equivalents, except for characters explicitly unreserved by RFC3986 -- that is, ASCII alphanumeric characters, hyphen, dot, underscore, and tilde.</p>
<p>The returned string must be freed by the caller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>an unencoded string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated URI-encoded string or NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a3a36842fd6f74977c9c0fb7aa5578832"></a><!-- doxytag: member="http.h::evhttp_find_header" ref="a3a36842fd6f74977c9c0fb7aa5578832" args="(const struct evkeyvalq *headers, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* evhttp_find_header </td>
          <td>(</td>
          <td class="paramtype">const struct evkeyvalq *&nbsp;</td>
          <td class="paramname"> <em>headers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the value belonging to a header. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>headers</em>&nbsp;</td><td>the evkeyvalq object in which to find the header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the name of the header to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the value for the header or NULL if the header count not be found. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#a04e3f41c14b8e0e74da13a8d308b93b7" title="Adds a header to a list of existing headers.">evhttp_add_header()</a>, <a class="el" href="http_8h.html#ab87600f14a6f8c36beedbeed8267b856" title="Removes a header from a list of existing headers.">evhttp_remove_header()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a849acf0f233772b486b8057fcf3aaf4a"></a><!-- doxytag: member="http.h::evhttp_free" ref="a849acf0f233772b486b8057fcf3aaf4a" args="(struct evhttp *http)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_free </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the previously created HTTP server. </p>
<p>Works only if no requests are currently being served.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>the evhttp server object to be freed </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http__compat_8h.html#aff4e96ef72ca014740878e3e5f02befc" title="Start an HTTP server on the specified address and port.">evhttp_start()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac9318bd77cb5f4030b434bea99b3828e"></a><!-- doxytag: member="http.h::evhttp_htmlescape" ref="ac9318bd77cb5f4030b434bea99b3828e" args="(const char *html)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* evhttp_htmlescape </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>html</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Escape HTML character entities in a string. </p>
<p>Replaces &lt;, &gt;, , ' and &amp; with &lt;, &gt;, ", &amp;#039; and &amp; correspondingly.</p>
<p>The returned string needs to be freed by the caller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>html</em>&nbsp;</td><td>an unescaped HTML string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an escaped HTML string or NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a70af2a5e67da78782e06c640b9f85d4e"></a><!-- doxytag: member="http.h::evhttp_make_request" ref="a70af2a5e67da78782e06c640b9f85d4e" args="(struct evhttp_connection *evcon, struct evhttp_request *req, enum evhttp_cmd_type type, const char *uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_make_request </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_connection *&nbsp;</td>
          <td class="paramname"> <em>evcon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct evhttp_request *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="http_8h.html#ac858319d667267f9fc848c2bb6931aa3">evhttp_cmd_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make an HTTP request over the specified connection. </p>
<p>The connection gets ownership of the request. On failure, the request object is no longer valid as it has been freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evcon</em>&nbsp;</td><td>the evhttp_connection object over which to send the request </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>the previously created and configured request object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the request type EVHTTP_REQ_GET, EVHTTP_REQ_POST, etc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uri</em>&nbsp;</td><td>the URI associated with the request </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#ab323fe297168f0f87af832f2bddc40a0" title="Cancels a pending HTTP request.">evhttp_cancel_request()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab8c84271a97fd85957cf72b1161b8216"></a><!-- doxytag: member="http.h::evhttp_new" ref="ab8c84271a97fd85957cf72b1161b8216" args="(struct event_base *base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct evhttp* evhttp_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"> <em>base</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new HTTP server. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>(optional) the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base to receive the HTTP events </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to a newly initialized evhttp server structure </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#a849acf0f233772b486b8057fcf3aaf4a" title="Free the previously created HTTP server.">evhttp_free()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a12d3940d23fb53c38106f8ac0d3dfff6"></a><!-- doxytag: member="http.h::evhttp_parse_query" ref="a12d3940d23fb53c38106f8ac0d3dfff6" args="(const char *uri, struct evkeyvalq *headers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_parse_query </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct evkeyvalq *&nbsp;</td>
          <td class="paramname"> <em>headers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to parse out arguments in a query. </p>
<p>Parsing a URI like</p>
<p><a href="http://foo.com/?q=test&s=some+thing">http://foo.com/?q=test&amp;s=some+thing</a></p>
<p>will result in two entries in the key value queue.</p>
<p>The first entry is: key="q", value="test" The second entry is: key="s", value="some thing"</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>This function is deprecated as of Libevent 2.0.9. Use evhttp_uri_parse and evhttp_parse_query_str instead.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uri</em>&nbsp;</td><td>the request URI </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>headers</em>&nbsp;</td><td>the head of the evkeyval queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a1598fb5757f39dde6dc43dee9a2e7fca"></a><!-- doxytag: member="http.h::evhttp_parse_query_str" ref="a1598fb5757f39dde6dc43dee9a2e7fca" args="(const char *uri, struct evkeyvalq *headers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_parse_query_str </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct evkeyvalq *&nbsp;</td>
          <td class="paramname"> <em>headers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to parse out arguments from the query portion of an HTTP URI. </p>
<p>Parsing a query string like</p>
<p>q=test&amp;s=some+thing</p>
<p>will result in two entries in the key value queue.</p>
<p>The first entry is: key="q", value="test" The second entry is: key="s", value="some thing"</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>query_parse</em>&nbsp;</td><td>the query portion of the URI </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>headers</em>&nbsp;</td><td>the head of the evkeyval queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ab87600f14a6f8c36beedbeed8267b856"></a><!-- doxytag: member="http.h::evhttp_remove_header" ref="ab87600f14a6f8c36beedbeed8267b856" args="(struct evkeyvalq *headers, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_remove_header </td>
          <td>(</td>
          <td class="paramtype">struct evkeyvalq *&nbsp;</td>
          <td class="paramname"> <em>headers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a header from a list of existing headers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>headers</em>&nbsp;</td><td>the evkeyvalq object from which to remove a header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the name of the header to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the header was removed, -1 otherwise. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#a3a36842fd6f74977c9c0fb7aa5578832" title="Finds the value belonging to a header.">evhttp_find_header()</a>, <a class="el" href="http_8h.html#a04e3f41c14b8e0e74da13a8d308b93b7" title="Adds a header to a list of existing headers.">evhttp_add_header()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a88fe4c5507e88c4db284ea30a0478e5d"></a><!-- doxytag: member="http.h::evhttp_remove_server_alias" ref="a88fe4c5507e88c4db284ea30a0478e5d" args="(struct evhttp *http, const char *alias)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_remove_server_alias </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>alias</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a server alias from an http object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>the evhttp object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alias</em>&nbsp;</td><td>the alias to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#a58fe001925e7f65d7678bf90b31fc2a5" title="Add a server alias to an http object.">evhttp_add_server_alias()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab2eb1ac82f36e7f0180b18d4553d3994"></a><!-- doxytag: member="http.h::evhttp_remove_virtual_host" ref="ab2eb1ac82f36e7f0180b18d4553d3994" args="(struct evhttp *http, struct evhttp *vhost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_remove_virtual_host </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>vhost</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a virtual host from the http server. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>the evhttp object from which to remove the virtual host </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vhost</em>&nbsp;</td><td>the virtual host to remove from the regular http server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#a82d8fb72c5e8c76b787987ba5de5b141" title="Adds a virtual host to the http server.">evhttp_add_virtual_host()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aad0392c873fa034be3ff09d4f8b68aba"></a><!-- doxytag: member="http.h::evhttp_request_free" ref="aad0392c873fa034be3ff09d4f8b68aba" args="(struct evhttp_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_request_free </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_request *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees the request object and removes associated events. </p>

</div>
</div>
<a class="anchor" id="a92a534f00172fa452c45c9f3fc42d6f5"></a><!-- doxytag: member="http.h::evhttp_request_get_connection" ref="a92a534f00172fa452c45c9f3fc42d6f5" args="(struct evhttp_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct evhttp_connection* evhttp_request_get_connection </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_request *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the connection object associated with the request or NULL. </p>
<p>The user needs to either free the request explicitly or call <a class="el" href="http_8h.html#a77024706313626c5857089b08ec5e0ae" title="Complete a chunked reply, freeing the request as appropriate.">evhttp_send_reply_end()</a>. </p>

</div>
</div>
<a class="anchor" id="aac84865e4848b8d9089e4182e12d185e"></a><!-- doxytag: member="http.h::evhttp_request_get_host" ref="aac84865e4848b8d9089e4182e12d185e" args="(struct evhttp_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* evhttp_request_get_host </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_request *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the host associated with the request. </p>
<p>If a client sends an absolute URI, the host part of that is preferred. Otherwise, the input headers are searched for a Host: header. NULL is returned if no absolute URI or Host: header is provided. </p>

</div>
</div>
<a class="anchor" id="a2f40f147e37f9a40f8ef684fb8f2d6b0"></a><!-- doxytag: member="http.h::evhttp_request_new" ref="a2f40f147e37f9a40f8ef684fb8f2d6b0" args="(void(*cb)(struct evhttp_request *, void *), void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct evhttp_request* evhttp_request_new </td>
          <td>(</td>
          <td class="paramtype">void(*)(struct evhttp_request *, void *)&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new request object that needs to be filled in with the request parameters. </p>
<p>The callback is executed when the request completed or an error occurred. </p>

</div>
</div>
<a class="anchor" id="a93a13d12f579bf22af35e2f1a6d82f4c"></a><!-- doxytag: member="http.h::evhttp_request_own" ref="a93a13d12f579bf22af35e2f1a6d82f4c" args="(struct evhttp_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_request_own </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_request *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Takes ownership of the request object. </p>
<p>Can be used in a request callback to keep onto the request until <a class="el" href="http_8h.html#aad0392c873fa034be3ff09d4f8b68aba" title="Frees the request object and removes associated events.">evhttp_request_free()</a> is explicitly called by the user. </p>

</div>
</div>
<a class="anchor" id="a3dd375d81eac9baabc53749ed025ec12"></a><!-- doxytag: member="http.h::evhttp_request_set_chunked_cb" ref="a3dd375d81eac9baabc53749ed025ec12" args="(struct evhttp_request *, void(*cb)(struct evhttp_request *, void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_request_set_chunked_cb </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_request *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct evhttp_request *, void *)&nbsp;</td>
          <td class="paramname"> <em>cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable delivery of chunks to requestor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>will be called after every read of data with the same argument as the completion callback. Will never be called on an empty response. May drain the input buffer; it will be drained automatically on return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a629ef7f70ed916e162dee3bd12e397c9"></a><!-- doxytag: member="http.h::evhttp_send_error" ref="a629ef7f70ed916e162dee3bd12e397c9" args="(struct evhttp_request *req, int error, const char *reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_send_error </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_request *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send an HTML error message to the client. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>a request object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>the HTTP error code </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>a brief explanation of the error. If this is NULL, we'll just use the standard meaning of the error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9df5ec9adc9bc664db5d6b161a293525"></a><!-- doxytag: member="http.h::evhttp_send_reply" ref="a9df5ec9adc9bc664db5d6b161a293525" args="(struct evhttp_request *req, int code, const char *reason, struct evbuffer *databuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_send_reply </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_request *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>databuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send an HTML reply to the client. </p>
<p>The body of the reply consists of the data in databuf. After calling <a class="el" href="http_8h.html#a9df5ec9adc9bc664db5d6b161a293525" title="Send an HTML reply to the client.">evhttp_send_reply()</a> databuf will be empty, but the buffer is still owned by the caller and needs to be deallocated by the caller if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>a request object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>code</em>&nbsp;</td><td>the HTTP response code to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>a brief message to send with the response code </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>databuf</em>&nbsp;</td><td>the body of the response </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7950f70e66678fda56fdf8288811639c"></a><!-- doxytag: member="http.h::evhttp_send_reply_chunk" ref="a7950f70e66678fda56fdf8288811639c" args="(struct evhttp_request *req, struct evbuffer *databuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_send_reply_chunk </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_request *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>databuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send another data chunk as part of an ongoing chunked reply. </p>
<p>The reply chunk consists of the data in databuf. After calling <a class="el" href="http_8h.html#a7950f70e66678fda56fdf8288811639c" title="Send another data chunk as part of an ongoing chunked reply.">evhttp_send_reply_chunk()</a> databuf will be empty, but the buffer is still owned by the caller and needs to be deallocated by the caller if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>a request object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>databuf</em>&nbsp;</td><td>the data chunk to send as part of the reply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77024706313626c5857089b08ec5e0ae"></a><!-- doxytag: member="http.h::evhttp_send_reply_end" ref="a77024706313626c5857089b08ec5e0ae" args="(struct evhttp_request *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_send_reply_end </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_request *&nbsp;</td>
          <td class="paramname"> <em>req</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Complete a chunked reply, freeing the request as appropriate. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>a request object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69c93aab46133521997cdfb8c2e07195"></a><!-- doxytag: member="http.h::evhttp_send_reply_start" ref="a69c93aab46133521997cdfb8c2e07195" args="(struct evhttp_request *req, int code, const char *reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_send_reply_start </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_request *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiate a reply that uses Transfer-Encoding chunked. </p>
<p>This allows the caller to stream the reply back to the client and is useful when either not all of the reply data is immediately available or when sending very large replies.</p>
<p>The caller needs to supply data chunks with <a class="el" href="http_8h.html#a7950f70e66678fda56fdf8288811639c" title="Send another data chunk as part of an ongoing chunked reply.">evhttp_send_reply_chunk()</a> and complete the reply by calling <a class="el" href="http_8h.html#a77024706313626c5857089b08ec5e0ae" title="Complete a chunked reply, freeing the request as appropriate.">evhttp_send_reply_end()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>a request object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>code</em>&nbsp;</td><td>the HTTP response code to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>a brief message to send with the response code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae63a0370f59570e00753f7fb512a7f59"></a><!-- doxytag: member="http.h::evhttp_set_allowed_methods" ref="ae63a0370f59570e00753f7fb512a7f59" args="(struct evhttp *http, ev_uint16_t methods)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_set_allowed_methods </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint16_t&nbsp;</td>
          <td class="paramname"> <em>methods</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the what HTTP methods are supported in requests accepted by this server, and passed to user callbacks. </p>
<p>If not supported they will generate a "405 Method not allowed" response.</p>
<p>By default this includes the following methods: GET, POST, HEAD, PUT, DELETE</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>the http server on which to set the methods </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>methods</em>&nbsp;</td><td>bit mask constructed from evhttp_cmd_type values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b685afe43d7f4c3bfcc7dcba72d41e0"></a><!-- doxytag: member="http.h::evhttp_set_cb" ref="a5b685afe43d7f4c3bfcc7dcba72d41e0" args="(struct evhttp *http, const char *path, void(*cb)(struct evhttp_request *, void *), void *cb_arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_set_cb </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct evhttp_request *, void *)&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cb_arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a callback for a specified URI. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>the http sever on which to set the callback </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>the path for which to invoke the callback </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the callback function that gets invoked on requesting path </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb_arg</em>&nbsp;</td><td>an additional context argument for the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 if the callback existed already, -2 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ad3466287c0054d32dfd538a3bdfb0374"></a><!-- doxytag: member="http.h::evhttp_set_gencb" ref="ad3466287c0054d32dfd538a3bdfb0374" args="(struct evhttp *http, void(*cb)(struct evhttp_request *, void *), void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_set_gencb </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct evhttp_request *, void *)&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a callback for all requests that are not caught by specific callbacks. </p>
<p>Invokes the specified callback for all requests that do not match any of the previously specified request paths. This is catchall for requests not specifically configured with <a class="el" href="http_8h.html#a5b685afe43d7f4c3bfcc7dcba72d41e0" title="Set a callback for a specified URI.">evhttp_set_cb()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>the evhttp server object for which to set the callback </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the callback to invoke for any unmatched requests </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>an context argument for the callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8406065dcb34f9a058b2a7a6988ac351"></a><!-- doxytag: member="http.h::evhttp_set_max_body_size" ref="a8406065dcb34f9a058b2a7a6988ac351" args="(struct evhttp *http, ev_ssize_t max_body_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_set_max_body_size </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&nbsp;</td>
          <td class="paramname"> <em>max_body_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>XXX Document. </p>

</div>
</div>
<a class="anchor" id="ae936aa6e7b0cb9617d0548a952db93cf"></a><!-- doxytag: member="http.h::evhttp_set_max_headers_size" ref="ae936aa6e7b0cb9617d0548a952db93cf" args="(struct evhttp *http, ev_ssize_t max_headers_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_set_max_headers_size </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&nbsp;</td>
          <td class="paramname"> <em>max_headers_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>XXX Document. </p>

</div>
</div>
<a class="anchor" id="acc8bb4d9e196f957510b5db9f6a02e44"></a><!-- doxytag: member="http.h::evhttp_set_timeout" ref="acc8bb4d9e196f957510b5db9f6a02e44" args="(struct evhttp *http, int timeout_in_secs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_set_timeout </td>
          <td>(</td>
          <td class="paramtype">struct evhttp *&nbsp;</td>
          <td class="paramname"> <em>http</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_in_secs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the timeout for an HTTP request. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http</em>&nbsp;</td><td>an evhttp object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_in_secs</em>&nbsp;</td><td>the timeout, in seconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ee82311278b8fda3ed93a8e358683bb"></a><!-- doxytag: member="http.h::evhttp_uri_free" ref="a5ee82311278b8fda3ed93a8e358683bb" args="(struct evhttp_uri *uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_uri_free </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_uri *&nbsp;</td>
          <td class="paramname"> <em>uri</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free all memory allocated for a parsed uri. </p>
<p>Only use this for URIs generated by evhttp_uri_parse.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uri</em>&nbsp;</td><td>container with parsed data </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#a47bc072177c8e839083c511a618a422c" title="Alias for evhttp_uri_parse_with_flags(source_uri, 0).">evhttp_uri_parse()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2d45134ab552432fbe25eb2ff646f906"></a><!-- doxytag: member="http.h::evhttp_uri_get_host" ref="a2d45134ab552432fbe25eb2ff646f906" args="(const struct evhttp_uri *uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* evhttp_uri_get_host </td>
          <td>(</td>
          <td class="paramtype">const struct evhttp_uri *&nbsp;</td>
          <td class="paramname"> <em>uri</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the host part of an evhttp_uri, or NULL if it has no host set. </p>
<p>The host may either be a regular hostname (conforming to the RFC 3986 "regname" production), or an IPv4 address, or the empty string, or a bracketed IPv6 address, or a bracketed 'IP-Future' address.</p>
<p>Note that having a NULL host means that the URI has no authority section, but having an empty-string host means that the URI has an authority section with no host part. For example, "mailto:user@example.com" has a host of NULL, but "file:///etc/motd" has a host of "". </p>

</div>
</div>
<a class="anchor" id="a60d456504f4f93f61384eb0b526f5a4c"></a><!-- doxytag: member="http.h::evhttp_uri_get_port" ref="a60d456504f4f93f61384eb0b526f5a4c" args="(const struct evhttp_uri *uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_uri_get_port </td>
          <td>(</td>
          <td class="paramtype">const struct evhttp_uri *&nbsp;</td>
          <td class="paramname"> <em>uri</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the port part of an evhttp_uri, or -1 if there is no port set. </p>

</div>
</div>
<a class="anchor" id="a6f49cc20f421d2f66907c613d24ad3dc"></a><!-- doxytag: member="http.h::evhttp_uri_get_scheme" ref="a6f49cc20f421d2f66907c613d24ad3dc" args="(const struct evhttp_uri *uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* evhttp_uri_get_scheme </td>
          <td>(</td>
          <td class="paramtype">const struct evhttp_uri *&nbsp;</td>
          <td class="paramname"> <em>uri</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the scheme of an evhttp_uri, or NULL if there is no scheme has been set and the evhttp_uri contains a Relative-Ref. </p>

</div>
</div>
<a class="anchor" id="a60f7217fccc2bdfb9cb6abeb1c4ad102"></a><!-- doxytag: member="http.h::evhttp_uri_join" ref="a60f7217fccc2bdfb9cb6abeb1c4ad102" args="(struct evhttp_uri *uri, char *buf, size_t limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* evhttp_uri_join </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_uri *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Join together the uri parts from parsed data to form a URI-Reference. </p>
<p>Note that no escaping of reserved characters is done on the members of the evhttp_uri, so the generated string might not be a valid URI unless the members of evhttp_uri are themselves valid.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uri</em>&nbsp;</td><td>container with parsed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>destination buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>destination buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an joined uri as string or NULL on error </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#a47bc072177c8e839083c511a618a422c" title="Alias for evhttp_uri_parse_with_flags(source_uri, 0).">evhttp_uri_parse()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad9f9447cb1c3c92e40478b98ff30db60"></a><!-- doxytag: member="http.h::evhttp_uri_parse_with_flags" ref="ad9f9447cb1c3c92e40478b98ff30db60" args="(const char *source_uri, unsigned flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct evhttp_uri* evhttp_uri_parse_with_flags </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>source_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to parse a URI-Reference as specified by RFC3986. </p>
<p>This function matches the URI-Reference production from RFC3986, which includes both URIs like</p>
<p>scheme://[[userinfo]@]foo.com[:port]]/[path][?query][fragment]</p>
<p>and relative-refs like</p>
<p>[path][?query][fragment]</p>
<p>Any optional elements portions not present in the original URI are left set to NULL in the resulting evhttp_uri. If no port is specified, the port is set to -1.</p>
<p>Note that no decoding is performed on percent-escaped characters in the string; if you want to parse them, use evhttp_uridecode or evhttp_parse_query_str as appropriate.</p>
<p>Note also that most URI schemes will have additional constraints that this function does not know about, and cannot check. For example, mailto://www.example.com/cgi-bin/fortune.pl is not a reasonable mailto url, <a href="http://www.example.com:99999/">http://www.example.com:99999/</a> is not a reasonable HTTP URL, and <a href="ftp:username@example.com is not a reasonable FTP URL.">ftp:username@example.com is not a reasonable FTP URL.</a> Nevertheless, all of these URLs conform to RFC3986, and this function accepts all of them as valid.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source_uri</em>&nbsp;</td><td>the request URI </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Zero or more EVHTTP_URI_* flags to affect the behavior of the parser. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>uri container to hold parsed data, or NULL if there is error </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="http_8h.html#a5ee82311278b8fda3ed93a8e358683bb" title="Free all memory allocated for a parsed uri.">evhttp_uri_free()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aea0b990f1ca5ba71feffa96c8f6bd06b"></a><!-- doxytag: member="http.h::evhttp_uri_set_flags" ref="aea0b990f1ca5ba71feffa96c8f6bd06b" args="(struct evhttp_uri *uri, unsigned flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evhttp_uri_set_flags </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_uri *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the flags set on a given URI. </p>
<p>See EVHTTP_URI_* for a list of flags. </p>

</div>
</div>
<a class="anchor" id="a36b844028058c82b6709d1e0fe7e1cf9"></a><!-- doxytag: member="http.h::evhttp_uri_set_fragment" ref="a36b844028058c82b6709d1e0fe7e1cf9" args="(struct evhttp_uri *uri, const char *fragment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_uri_set_fragment </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_uri *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fragment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the fragment of an evhttp_uri, or clear the fragment if fragment==NULL. </p>
<p>The fragment should not include a leading "#". Returns 0 on success, -1 if fragment is not well-formed. </p>

</div>
</div>
<a class="anchor" id="a103c447efb9f41a5897b3aa130424734"></a><!-- doxytag: member="http.h::evhttp_uri_set_host" ref="a103c447efb9f41a5897b3aa130424734" args="(struct evhttp_uri *uri, const char *host)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_uri_set_host </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_uri *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the host of an evhttp_uri, or clear the host if host==NULL. </p>
<p>Returns 0 on success, -1 if host is not well-formed. </p>

</div>
</div>
<a class="anchor" id="ae6bbfc5cf62df674ba72800ea46c5828"></a><!-- doxytag: member="http.h::evhttp_uri_set_path" ref="ae6bbfc5cf62df674ba72800ea46c5828" args="(struct evhttp_uri *uri, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_uri_set_path </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_uri *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the path of an evhttp_uri, or clear the path if path==NULL. </p>
<p>Returns 0 on success, -1 if path is not well-formed. </p>

</div>
</div>
<a class="anchor" id="a8cc430f9b8fb4c6aa11692d5ef0b383c"></a><!-- doxytag: member="http.h::evhttp_uri_set_port" ref="a8cc430f9b8fb4c6aa11692d5ef0b383c" args="(struct evhttp_uri *uri, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_uri_set_port </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_uri *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the port of an evhttp_uri, or clear the port if port==-1. </p>
<p>Returns 0 on success, -1 if port is not well-formed. </p>

</div>
</div>
<a class="anchor" id="aaf999637136bc1785e5d75c191c671ba"></a><!-- doxytag: member="http.h::evhttp_uri_set_query" ref="aaf999637136bc1785e5d75c191c671ba" args="(struct evhttp_uri *uri, const char *query)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_uri_set_query </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_uri *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>query</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the query of an evhttp_uri, or clear the query if query==NULL. </p>
<p>The query should not include a leading "?". Returns 0 on success, -1 if query is not well-formed. </p>

</div>
</div>
<a class="anchor" id="abf5f82fb9c8f8df0b1b4c73691791dd5"></a><!-- doxytag: member="http.h::evhttp_uri_set_scheme" ref="abf5f82fb9c8f8df0b1b4c73691791dd5" args="(struct evhttp_uri *uri, const char *scheme)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_uri_set_scheme </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_uri *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>scheme</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the scheme of an evhttp_uri, or clear the scheme if scheme==NULL. </p>
<p>Returns 0 on success, -1 if scheme is not well-formed. </p>

</div>
</div>
<a class="anchor" id="ac7b10b8ef8ee94d14674f9329486d355"></a><!-- doxytag: member="http.h::evhttp_uri_set_userinfo" ref="ac7b10b8ef8ee94d14674f9329486d355" args="(struct evhttp_uri *uri, const char *userinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evhttp_uri_set_userinfo </td>
          <td>(</td>
          <td class="paramtype">struct evhttp_uri *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>userinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the userinfo of an evhttp_uri, or clear the userinfo if userinfo==NULL. </p>
<p>Returns 0 on success, -1 if userinfo is not well-formed. </p>

</div>
</div>
<a class="anchor" id="ac2914389616f04199aded10444fd8e42"></a><!-- doxytag: member="http.h::evhttp_uridecode" ref="ac2914389616f04199aded10444fd8e42" args="(const char *uri, int decode_plus, size_t *size_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* evhttp_uridecode </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>decode_plus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>size_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to decode a URI-escaped string or HTTP parameter. </p>
<p>If 'decode_plus' is 1, then we decode the string as an HTTP parameter value, and convert all plus ('+') characters to spaces. If 'decode_plus' is 0, we leave all plus characters unchanged.</p>
<p>The returned string must be freed by the caller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uri</em>&nbsp;</td><td>a URI-encode encoded URI </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>decode_plus</em>&nbsp;</td><td>determines whether we convert '+' to sapce. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size_out</em>&nbsp;</td><td>if size_out is not NULL, *size_out is set to the size of the returned string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated unencoded URI or NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ab64229249a981ccfea09161a199972da"></a><!-- doxytag: member="http.h::evhttp_uriencode" ref="ab64229249a981ccfea09161a199972da" args="(const char *str, ev_ssize_t size, int space_to_plus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* evhttp_uriencode </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>space_to_plus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>As evhttp_encode_uri, but if 'size' is nonnegative, treat the string as being 'size' bytes long. </p>
<p>This allows you to encode strings that may contain 0-valued bytes.</p>
<p>The returned string must be freed by the caller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>an unencoded string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the length of the string to encode, or -1 if the string is NUL-terminated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>space_to_plus</em>&nbsp;</td><td>if true, space characters in 'str' are encoded as +, not 20. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocate URI-encoded string, or NULL on failure. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 17 Mar 2015 for libevent by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
