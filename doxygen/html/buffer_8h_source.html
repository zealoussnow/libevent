<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libevent: event2/buffer.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>event2/buffer.h</h1><a href="buffer_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00005"></a>00005 <span class="comment"> * modification, are permitted provided that the following conditions</span>
<a name="l00006"></a>00006 <span class="comment"> * are met:</span>
<a name="l00007"></a>00007 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
<a name="l00008"></a>00008 <span class="comment"> *    notice, this list of conditions and the following disclaimer.</span>
<a name="l00009"></a>00009 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<a name="l00010"></a>00010 <span class="comment"> *    notice, this list of conditions and the following disclaimer in the</span>
<a name="l00011"></a>00011 <span class="comment"> *    documentation and/or other materials provided with the distribution.</span>
<a name="l00012"></a>00012 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
<a name="l00013"></a>00013 <span class="comment"> *    derived from this software without specific prior written permission.</span>
<a name="l00014"></a>00014 <span class="comment"> *</span>
<a name="l00015"></a>00015 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&apos;&apos; AND ANY EXPRESS OR</span>
<a name="l00016"></a>00016 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
<a name="l00017"></a>00017 <span class="comment"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00018"></a>00018 <span class="comment"> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<a name="l00019"></a>00019 <span class="comment"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
<a name="l00020"></a>00020 <span class="comment"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00021"></a>00021 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00022"></a>00022 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00023"></a>00023 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a name="l00024"></a>00024 <span class="comment"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="preprocessor">#ifndef _EVENT2_BUFFER_H_</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#define _EVENT2_BUFFER_H_</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00075"></a>00075 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00077"></a>00077 <span class="preprocessor">#endif</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span>
<a name="l00079"></a>00079 <span class="preprocessor">#include &lt;event2/event-config.h&gt;</span>
<a name="l00080"></a>00080 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00081"></a>00081 <span class="preprocessor">#ifdef _EVENT_HAVE_SYS_TYPES_H</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00083"></a>00083 <span class="preprocessor">#endif</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="preprocessor">#ifdef _EVENT_HAVE_SYS_UIO_H</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/uio.h&gt;</span>
<a name="l00086"></a>00086 <span class="preprocessor">#endif</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="util_8h.html" title="Common convenience functions for cross-platform portability and related socket manipulations...">event2/util.h</a>&gt;</span>
<a name="l00088"></a>00088 
<a name="l00095"></a><a class="code" href="structevbuffer.html">00095</a> <span class="keyword">struct </span><a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>
<a name="l00096"></a>00096 #ifdef _EVENT_IN_DOXYGEN
<a name="l00097"></a>00097 {}
<a name="l00098"></a>00098 <span class="preprocessor">#endif</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span>;
<a name="l00100"></a>00100 
<a name="l00109"></a><a class="code" href="structevbuffer__ptr.html">00109</a> <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> {
<a name="l00110"></a>00110         ev_ssize_t pos;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112         <span class="comment">/* Do not alter the values of fields. */</span>
<a name="l00113"></a>00113         <span class="keyword">struct </span>{
<a name="l00114"></a>00114                 <span class="keywordtype">void</span> *chain;
<a name="l00115"></a>00115                 <span class="keywordtype">size_t</span> pos_in_chain;
<a name="l00116"></a>00116         } _internal;
<a name="l00117"></a>00117 };
<a name="l00118"></a>00118 
<a name="l00124"></a>00124 <span class="preprocessor">#ifdef _EVENT_HAVE_SYS_UIO_H</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span><span class="preprocessor">#define evbuffer_iovec iovec</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span><span class="comment">/* Internal use -- defined only if we are using the native struct iovec */</span>
<a name="l00127"></a>00127 <span class="preprocessor">#define _EVBUFFER_IOVEC_IS_NATIVE</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00129"></a><a class="code" href="structevbuffer__iovec.html">00129</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structevbuffer__iovec.html" title="Describes a single extent of memory inside an evbuffer.">evbuffer_iovec</a> {
<a name="l00131"></a><a class="code" href="structevbuffer__iovec.html#a1ce384c93f7554ab94f5dccdab8b4e13">00131</a>         <span class="keywordtype">void</span> *<a class="code" href="structevbuffer__iovec.html#a1ce384c93f7554ab94f5dccdab8b4e13" title="The start of the extent of memory.">iov_base</a>;
<a name="l00133"></a><a class="code" href="structevbuffer__iovec.html#a0b1981aa931c720e63238022d74c0ac1">00133</a>         <span class="keywordtype">size_t</span> <a class="code" href="structevbuffer__iovec.html#a0b1981aa931c720e63238022d74c0ac1" title="The length of the extent of memory.">iov_len</a>;
<a name="l00134"></a>00134 };
<a name="l00135"></a>00135 <span class="preprocessor">#endif</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span>
<a name="l00143"></a>00143 <span class="keyword">struct </span><a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *<a class="code" href="buffer_8h.html#a8ebe44bfccd1d245cae17b1b7586092a" title="Allocate storage for a new evbuffer.">evbuffer_new</a>(<span class="keywordtype">void</span>);
<a name="l00149"></a>00149 <span class="keywordtype">void</span> <a class="code" href="buffer_8h.html#a0a87b43a5ae8c5589e77cde486b8a155" title="Deallocate storage for an evbuffer.">evbuffer_free</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf);
<a name="l00150"></a>00150 
<a name="l00163"></a>00163 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a1bf21d715f288541eb670c5f159f2264" title="Enable locking on an evbuffer so that it can safely be used by multiple threads at...">evbuffer_enable_locking</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, <span class="keywordtype">void</span> *lock);
<a name="l00164"></a>00164 
<a name="l00169"></a>00169 <span class="keywordtype">void</span> <a class="code" href="buffer_8h.html#af9542ca1ac381708c9b1450d91d168ec" title="Acquire the lock on an evbuffer.">evbuffer_lock</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf);
<a name="l00170"></a>00170 
<a name="l00175"></a>00175 <span class="keywordtype">void</span> <a class="code" href="buffer_8h.html#a538b62549df58369e10fd5703cafe92b" title="Release the lock on an evbuffer.">evbuffer_unlock</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 
<a name="l00193"></a><a class="code" href="buffer_8h.html#a0d9db8b232ebf8d63c660ec429981e91">00193</a> <span class="preprocessor">#define EVBUFFER_FLAG_DRAINS_TO_FD 1</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span>
<a name="l00202"></a>00202 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#ae7ca62b72232b4029288e4c3a06f1c6c" title="Change the flags that are set for an evbuffer by adding more.">evbuffer_set_flags</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, ev_uint64_t flags);
<a name="l00210"></a>00210 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a732701957705ae6abe7c28effeb4aa39" title="Change the flags that are set for an evbuffer by removing some.">evbuffer_clear_flags</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, ev_uint64_t flags);
<a name="l00211"></a>00211 
<a name="l00218"></a>00218 <span class="keywordtype">size_t</span> <a class="code" href="buffer_8h.html#af1b44374d37735f3a90ae402eaeddf44" title="Returns the total number of bytes stored in the evbuffer.">evbuffer_get_length</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf);
<a name="l00219"></a>00219 
<a name="l00232"></a>00232 <span class="keywordtype">size_t</span> <a class="code" href="buffer_8h.html#acd3d8507991609637a501e835e450331" title="Returns the number of contiguous available bytes in the first buffer chain.">evbuffer_get_contiguous_space</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf);
<a name="l00233"></a>00233 
<a name="l00244"></a>00244 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a305caf7b9bfb8713e6ef383d61791f95" title="Expands the available space in an evbuffer.">evbuffer_expand</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, <span class="keywordtype">size_t</span> datlen);
<a name="l00245"></a>00245 
<a name="l00279"></a>00279 <span class="keywordtype">int</span>
<a name="l00280"></a>00280 <a class="code" href="buffer_8h.html#ada49b2dc41bb09bb011765c1fc826a5d" title="Reserves space in the last chain or chains of an evbuffer.">evbuffer_reserve_space</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, ev_ssize_t size,
<a name="l00281"></a>00281     <span class="keyword">struct</span> <a class="code" href="structevbuffer__iovec.html" title="Describes a single extent of memory inside an evbuffer.">evbuffer_iovec</a> *vec, <span class="keywordtype">int</span> n_vec);
<a name="l00282"></a>00282 
<a name="l00304"></a>00304 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a7a13a10fd1eb75cccf0ca29a05c5ba8a" title="Commits previously reserved space.">evbuffer_commit_space</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf,
<a name="l00305"></a>00305     <span class="keyword">struct</span> <a class="code" href="structevbuffer__iovec.html" title="Describes a single extent of memory inside an evbuffer.">evbuffer_iovec</a> *vec, <span class="keywordtype">int</span> n_vecs);
<a name="l00306"></a>00306 
<a name="l00315"></a>00315 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a69c3b8893a49bdd919642c6920c1fcb4" title="Append data to the end of an evbuffer.">evbuffer_add</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> datlen);
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 
<a name="l00329"></a>00329 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a0455fc72c74c758ed8dc9a0902af451a" title="Read data from an evbuffer and drain the bytes read.">evbuffer_remove</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> datlen);
<a name="l00330"></a>00330 
<a name="l00342"></a>00342 ev_ssize_t <a class="code" href="buffer_8h.html#a8fa753475570f6529691ef8484cacc1b" title="Read data from an evbuffer, and leave the buffer unchanged.">evbuffer_copyout</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, <span class="keywordtype">void</span> *data_out, <span class="keywordtype">size_t</span> datlen);
<a name="l00343"></a>00343 
<a name="l00357"></a>00357 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a0bdef97f6a142425b271b329a90de869" title="Read data from an evbuffer into another evbuffer, draining the bytes from the source...">evbuffer_remove_buffer</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *src, <span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *dst,
<a name="l00358"></a>00358     <span class="keywordtype">size_t</span> datlen);
<a name="l00359"></a>00359 
<a name="l00362"></a><a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">00362</a> <span class="keyword">enum</span> <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178" title="Used to tell evbuffer_readln what kind of line-ending to look for.">evbuffer_eol_style</a> {
<a name="l00372"></a><a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178ab7c6da1408b1b2ec3a6657e5a71a50c3">00372</a>         <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178ab7c6da1408b1b2ec3a6657e5a71a50c3" title="Any sequence of CR and LF characters is acceptable as an EOL.">EVBUFFER_EOL_ANY</a>,
<a name="l00375"></a><a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178a4aec5353e85fbb57ce3b1ee68f36f641">00375</a>         <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178a4aec5353e85fbb57ce3b1ee68f36f641" title="An EOL is an LF, optionally preceded by a CR.">EVBUFFER_EOL_CRLF</a>,
<a name="l00377"></a><a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178a814775b4a9773d34421e7e88ca8c58de">00377</a>         <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178a814775b4a9773d34421e7e88ca8c58de" title="An EOL is a CR followed by an LF.">EVBUFFER_EOL_CRLF_STRICT</a>,
<a name="l00379"></a><a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178ac572ea90e5a96a7ceb878f2a8ef48993">00379</a>         <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178ac572ea90e5a96a7ceb878f2a8ef48993" title="An EOL is a LF.">EVBUFFER_EOL_LF</a>
<a name="l00380"></a>00380 };
<a name="l00381"></a>00381 
<a name="l00396"></a>00396 <span class="keywordtype">char</span> *<a class="code" href="buffer_8h.html#ae2460b5060948d3233342c4c81888650" title="Read a single line from an evbuffer.">evbuffer_readln</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, <span class="keywordtype">size_t</span> *n_read_out,
<a name="l00397"></a>00397     <span class="keyword">enum</span> <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178" title="Used to tell evbuffer_readln what kind of line-ending to look for.">evbuffer_eol_style</a> eol_style);
<a name="l00398"></a>00398 
<a name="l00411"></a>00411 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a9d2edd536246d70c50678a3865305414" title="Move all data from one evbuffer into another evbuffer.">evbuffer_add_buffer</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *outbuf, <span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *inbuf);
<a name="l00412"></a>00412 
<a name="l00419"></a><a class="code" href="buffer_8h.html#acc4dead0032a38143cb2c902417f9177">00419</a> <span class="keyword">typedef</span> void (*<a class="code" href="buffer_8h.html#acc4dead0032a38143cb2c902417f9177" title="A cleanup function for a piece of memory added to an evbuffer by reference.">evbuffer_ref_cleanup_cb</a>)(<span class="keyword">const</span> <span class="keywordtype">void</span> *data,
<a name="l00420"></a>00420     <span class="keywordtype">size_t</span> datalen, <span class="keywordtype">void</span> *extra);
<a name="l00421"></a>00421 
<a name="l00437"></a>00437 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a8a61b06a97974a86853becb9110b2ffd" title="Reference memory into an evbuffer without copying.">evbuffer_add_reference</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *outbuf,
<a name="l00438"></a>00438     <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> datlen,
<a name="l00439"></a>00439     <a class="code" href="buffer_8h.html#acc4dead0032a38143cb2c902417f9177" title="A cleanup function for a piece of memory added to an evbuffer by reference.">evbuffer_ref_cleanup_cb</a> cleanupfn, <span class="keywordtype">void</span> *cleanupfn_arg);
<a name="l00440"></a>00440 
<a name="l00462"></a>00462 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a5db7e9063755accc56fdad87d662743e" title="Copy data from a file into the evbuffer for writing to a socket.">evbuffer_add_file</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *outbuf, <span class="keywordtype">int</span> fd, ev_off_t offset,
<a name="l00463"></a>00463     ev_off_t length);
<a name="l00464"></a>00464 
<a name="l00477"></a>00477 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#adeb9457f344ddaf459726dbe348ac3db" title="Append a formatted string to the end of an evbuffer.">evbuffer_add_printf</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
<a name="l00478"></a>00478 <span class="preprocessor">#ifdef __GNUC__</span>
<a name="l00479"></a>00479 <span class="preprocessor"></span>  __attribute__((format(printf, 2, 3)))
<a name="l00480"></a>00480 <span class="preprocessor">#endif</span>
<a name="l00481"></a>00481 <span class="preprocessor"></span>;
<a name="l00482"></a>00482 
<a name="l00491"></a>00491 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#acc385568d5129d4af10486b641b98f81" title="Append a va_list formatted string to the end of an evbuffer.">evbuffer_add_vprintf</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, va_list ap)
<a name="l00492"></a>00492 <span class="preprocessor">#ifdef __GNUC__</span>
<a name="l00493"></a>00493 <span class="preprocessor"></span>        __attribute__((format(printf, 2, 0)))
<a name="l00494"></a>00494 <span class="preprocessor">#endif</span>
<a name="l00495"></a>00495 <span class="preprocessor"></span>;
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 
<a name="l00505"></a>00505 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a5c24f3bfbc941d693bf59b5d77d2c37f" title="Remove a specified number of bytes data from the beginning of an evbuffer.">evbuffer_drain</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, <span class="keywordtype">size_t</span> len);
<a name="l00506"></a>00506 
<a name="l00507"></a>00507 
<a name="l00518"></a>00518 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a1207167bb14d5333326225f41477e910" title="Write the contents of an evbuffer to a file descriptor.">evbuffer_write</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, <a class="code" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b" title="A type wide enough to hold the output of &amp;quot;socket()&amp;quot; or &amp;quot;accept()&amp;quot;...">evutil_socket_t</a> fd);
<a name="l00519"></a>00519 
<a name="l00532"></a>00532 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#aa0bea512e82177762be7cf0a28a9b03b" title="Write some of the contents of an evbuffer to a file descriptor.">evbuffer_write_atmost</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, <a class="code" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b" title="A type wide enough to hold the output of &amp;quot;socket()&amp;quot; or &amp;quot;accept()&amp;quot;...">evutil_socket_t</a> fd,
<a name="l00533"></a>00533                                                   ev_ssize_t howmuch);
<a name="l00534"></a>00534 
<a name="l00544"></a>00544 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a464aff577b05417171192fc68539b77e" title="Read from a file descriptor and store the result in an evbuffer.">evbuffer_read</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, <a class="code" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b" title="A type wide enough to hold the output of &amp;quot;socket()&amp;quot; or &amp;quot;accept()&amp;quot;...">evutil_socket_t</a> fd, <span class="keywordtype">int</span> howmuch);
<a name="l00545"></a>00545 
<a name="l00557"></a>00557 <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> <a class="code" href="buffer_8h.html#a61e15e2a355409587464c476d2481105" title="Search for a string within an evbuffer.">evbuffer_search</a>(struct <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, <span class="keyword">const</span> <span class="keywordtype">char</span> *what, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> *start);
<a name="l00558"></a>00558 
<a name="l00573"></a>00573 <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> <a class="code" href="buffer_8h.html#a532ded8162d838b306e18839e9ab04af" title="Search for a string within part of an evbuffer.">evbuffer_search_range</a>(struct <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, <span class="keyword">const</span> <span class="keywordtype">char</span> *what, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> *start, <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> *end);
<a name="l00574"></a>00574 
<a name="l00579"></a><a class="code" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014">00579</a> <span class="keyword">enum</span> <a class="code" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014" title="Defines how to adjust an evbuffer_ptr by evbuffer_ptr_set().">evbuffer_ptr_how</a> {
<a name="l00582"></a><a class="code" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014a78a0ff3721ff5f1647f743dcfb2f13ee">00582</a>         <a class="code" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014a78a0ff3721ff5f1647f743dcfb2f13ee" title="Sets the pointer to the position; can be called on with an uninitialized evbuffer_ptr...">EVBUFFER_PTR_SET</a>,
<a name="l00584"></a><a class="code" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014a0bce00d78b5fbc55c478ff362269f428">00584</a>         <a class="code" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014a0bce00d78b5fbc55c478ff362269f428" title="Advances the pointer by adding to the current position.">EVBUFFER_PTR_ADD</a>
<a name="l00585"></a>00585 };
<a name="l00586"></a>00586 
<a name="l00599"></a>00599 <span class="keywordtype">int</span>
<a name="l00600"></a>00600 <a class="code" href="buffer_8h.html#a83ea16ab8facba6c68d2e6931d13fbf4" title="Sets the search pointer in the buffer to position.">evbuffer_ptr_set</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, <span class="keyword">struct</span> <a class="code" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> *ptr,
<a name="l00601"></a>00601     <span class="keywordtype">size_t</span> position, <span class="keyword">enum</span> <a class="code" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014" title="Defines how to adjust an evbuffer_ptr by evbuffer_ptr_set().">evbuffer_ptr_how</a> how);
<a name="l00602"></a>00602 
<a name="l00617"></a>00617 <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> <a class="code" href="buffer_8h.html#aa54aca588fa272157513191a9628d457" title="Search for an end-of-line string within an evbuffer.">evbuffer_search_eol</a>(struct <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer,
<a name="l00618"></a>00618     <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> *start, <span class="keywordtype">size_t</span> *eol_len_out,
<a name="l00619"></a>00619     <span class="keyword">enum</span> <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178" title="Used to tell evbuffer_readln what kind of line-ending to look for.">evbuffer_eol_style</a> eol_style);
<a name="l00620"></a>00620 
<a name="l00649"></a>00649 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#adf4b59974a0cb989b7091f0b8677d511" title="Function to peek at data inside an evbuffer without removing it or copying it out...">evbuffer_peek</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, ev_ssize_t len,
<a name="l00650"></a>00650     <span class="keyword">struct</span> <a class="code" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> *start_at,
<a name="l00651"></a>00651     <span class="keyword">struct</span> <a class="code" href="structevbuffer__iovec.html" title="Describes a single extent of memory inside an evbuffer.">evbuffer_iovec</a> *vec_out, <span class="keywordtype">int</span> n_vec);
<a name="l00652"></a>00652 
<a name="l00653"></a>00653 
<a name="l00658"></a><a class="code" href="structevbuffer__cb__info.html">00658</a> <span class="keyword">struct </span><a class="code" href="structevbuffer__cb__info.html" title="Structure passed to an evbuffer_cb_func evbuffer callback.">evbuffer_cb_info</a> {
<a name="l00661"></a><a class="code" href="structevbuffer__cb__info.html#a18e973448576100923328e4de05ddef5">00661</a>         <span class="keywordtype">size_t</span> <a class="code" href="structevbuffer__cb__info.html#a18e973448576100923328e4de05ddef5" title="The number of bytes in this evbuffer when callbacks were last invoked.">orig_size</a>;
<a name="l00663"></a><a class="code" href="structevbuffer__cb__info.html#a8191bbc06e291543359428daace6bae6">00663</a>         <span class="keywordtype">size_t</span> <a class="code" href="structevbuffer__cb__info.html#a8191bbc06e291543359428daace6bae6" title="The number of bytes added since callbacks were last invoked.">n_added</a>;
<a name="l00665"></a><a class="code" href="structevbuffer__cb__info.html#a7d1a674e020d2eee72538b0221dc32a4">00665</a>         <span class="keywordtype">size_t</span> <a class="code" href="structevbuffer__cb__info.html#a7d1a674e020d2eee72538b0221dc32a4" title="The number of bytes removed since callbacks were last invoked.">n_deleted</a>;
<a name="l00666"></a>00666 };
<a name="l00667"></a>00667 
<a name="l00687"></a><a class="code" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9">00687</a> <span class="keyword">typedef</span> void (*<a class="code" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9" title="Type definition for a callback that is invoked whenever data is added or removed...">evbuffer_cb_func</a>)(<span class="keyword">struct </span><a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structevbuffer__cb__info.html" title="Structure passed to an evbuffer_cb_func evbuffer callback.">evbuffer_cb_info</a> *info, <span class="keywordtype">void</span> *arg);
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 <span class="keyword">struct </span>evbuffer_cb_entry;
<a name="l00701"></a>00701 <span class="keyword">struct </span>evbuffer_cb_entry *<a class="code" href="buffer_8h.html#aa2a1509845c3d71f0adac4198aab0bf7" title="Add a new callback to an evbuffer.">evbuffer_add_cb</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, <a class="code" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9" title="Type definition for a callback that is invoked whenever data is added or removed...">evbuffer_cb_func</a> cb, <span class="keywordtype">void</span> *cbarg);
<a name="l00702"></a>00702 
<a name="l00711"></a>00711 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#afd1e51be92170b17178949a639dfa8ab" title="Remove a callback from an evbuffer, given a handle returned from evbuffer_add_cb...">evbuffer_remove_cb_entry</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer,
<a name="l00712"></a>00712                              <span class="keyword">struct</span> evbuffer_cb_entry *ent);
<a name="l00713"></a>00713 
<a name="l00720"></a>00720 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a4d7c75045267863306d37043d3f0809a" title="Remove a callback from an evbuffer, given the function and argument used to add it...">evbuffer_remove_cb</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, <a class="code" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9" title="Type definition for a callback that is invoked whenever data is added or removed...">evbuffer_cb_func</a> cb, <span class="keywordtype">void</span> *cbarg);
<a name="l00721"></a>00721 
<a name="l00727"></a><a class="code" href="buffer_8h.html#aeb635643a72f8e57d50d7dee37308148">00727</a> <span class="preprocessor">#define EVBUFFER_CB_ENABLED 1</span>
<a name="l00728"></a>00728 <span class="preprocessor"></span>
<a name="l00736"></a>00736 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a4ba44d01484f19fbfe7c18d2a175dc3b" title="Change the flags that are set for a callback on a buffer by adding more.">evbuffer_cb_set_flags</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer,
<a name="l00737"></a>00737                           <span class="keyword">struct</span> evbuffer_cb_entry *cb, ev_uint32_t flags);
<a name="l00738"></a>00738 
<a name="l00746"></a>00746 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#acda56baecd4b512f4e9f54a21e39177f" title="Change the flags that are set for a callback on a buffer by removing some.">evbuffer_cb_clear_flags</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer,
<a name="l00747"></a>00747                           <span class="keyword">struct</span> evbuffer_cb_entry *cb, ev_uint32_t flags);
<a name="l00748"></a>00748 
<a name="l00749"></a>00749 <span class="preprocessor">#if 0</span>
<a name="l00750"></a>00750 <span class="preprocessor"></span>
<a name="l00759"></a>00759 <span class="keywordtype">void</span> evbuffer_cb_suspend(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, <span class="keyword">struct</span> evbuffer_cb_entry *cb);
<a name="l00768"></a>00768 <span class="keywordtype">void</span> evbuffer_cb_unsuspend(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, <span class="keyword">struct</span> evbuffer_cb_entry *cb);
<a name="l00769"></a>00769 <span class="preprocessor">#endif</span>
<a name="l00770"></a>00770 <span class="preprocessor"></span>
<a name="l00780"></a>00780 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="buffer_8h.html#a07df786553218ae3a7b0ebd2c9471a96" title="Makes the data at the begging of an evbuffer contiguous.">evbuffer_pullup</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, ev_ssize_t size);
<a name="l00781"></a>00781 
<a name="l00791"></a>00791 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a0daf99dbc837953427b60c462e5eba97" title="Prepends data to the beginning of the evbuffer.">evbuffer_prepend</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> size);
<a name="l00792"></a>00792 
<a name="l00801"></a>00801 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a80ea4326ada348edc0e4fb53ad1df80c" title="Prepends all data from the src evbuffer to the beginning of the dst evbuffer.">evbuffer_prepend_buffer</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *dst, <span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>* src);
<a name="l00802"></a>00802 
<a name="l00817"></a>00817 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a8611ca97c720d4dd605e272cc4136684" title="Prevent calls that modify an evbuffer from succeeding.">evbuffer_freeze</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, <span class="keywordtype">int</span> at_front);
<a name="l00826"></a>00826 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a0aceee5e8d8443df6d1b5daeb4daacfd" title="Re-enable calls that modify an evbuffer.">evbuffer_unfreeze</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buf, <span class="keywordtype">int</span> at_front);
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 <span class="keyword">struct </span><a class="code" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a>;
<a name="l00836"></a>00836 <span class="keywordtype">int</span> <a class="code" href="buffer_8h.html#a1c99c484430a81e641a783a273435074" title="Force all the callbacks on an evbuffer to be run, not immediately after the evbuffer...">evbuffer_defer_callbacks</a>(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> *buffer, <span class="keyword">struct</span> <a class="code" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> *base);
<a name="l00837"></a>00837 
<a name="l00838"></a>00838 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00839"></a>00839 <span class="preprocessor"></span>}
<a name="l00840"></a>00840 <span class="preprocessor">#endif</span>
<a name="l00841"></a>00841 <span class="preprocessor"></span>
<a name="l00842"></a>00842 <span class="preprocessor">#endif </span><span class="comment">/* _EVENT2_BUFFER_H_ */</span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 17 Mar 2015 for libevent by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
