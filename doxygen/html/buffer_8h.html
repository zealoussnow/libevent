<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libevent: event2/buffer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>event2/buffer.h File Reference</h1>
<p>Functions for buffering data for network sending or receiving.  
<a href="#_details">More...</a></p>
<code>#include &lt;event2/event-config.h&gt;</code><br/>
<code>#include &lt;stdarg.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="util_8h_source.html">event2/util.h</a>&gt;</code><br/>

<p><a href="buffer_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevbuffer.html">evbuffer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> is an opaque data type for efficiently buffering data to be sent or received on the network.  <a href="structevbuffer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevbuffer__cb__info.html">evbuffer_cb_info</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure passed to an evbuffer_cb_func <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> callback.  <a href="structevbuffer__cb__info.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes a single extent of memory inside an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="structevbuffer__iovec.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to a position within an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="structevbuffer__ptr.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aeb635643a72f8e57d50d7dee37308148">EVBUFFER_CB_ENABLED</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If this flag is not set, then a callback is temporarily disabled, and should not be invoked.  <a href="#aeb635643a72f8e57d50d7dee37308148"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a0d9db8b232ebf8d63c660ec429981e91">EVBUFFER_FLAG_DRAINS_TO_FD</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If this flag is set, then we will not use <a class="el" href="buffer_8h.html#adf4b59974a0cb989b7091f0b8677d511" title="Function to peek at data inside an evbuffer without removing it or copying it out...">evbuffer_peek()</a>, <a class="el" href="buffer_8h.html#a0455fc72c74c758ed8dc9a0902af451a" title="Read data from an evbuffer and drain the bytes read.">evbuffer_remove()</a>, <a class="el" href="buffer_8h.html#a0bdef97f6a142425b271b329a90de869" title="Read data from an evbuffer into another evbuffer, draining the bytes from the source...">evbuffer_remove_buffer()</a>, and so on to read bytes from this buffer: we'll only take bytes out of this buffer by writing them to the network (as with evbuffer_write_atmost), by removing them without observing them (as with evbuffer_drain), or by copying them all out at once (as with evbuffer_add_buffer).  <a href="#a0d9db8b232ebf8d63c660ec429981e91"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9">evbuffer_cb_func</a> )(struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, const struct <a class="el" href="structevbuffer__cb__info.html">evbuffer_cb_info</a> *info, void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type definition for a callback that is invoked whenever data is added or removed from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#af40adaa98b02da7fca55da29270266d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#acc4dead0032a38143cb2c902417f9177">evbuffer_ref_cleanup_cb</a> )(const void *data, size_t datalen, void *extra)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A cleanup function for a piece of memory added to an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> by reference.  <a href="#acc4dead0032a38143cb2c902417f9177"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a> { <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178ab7c6da1408b1b2ec3a6657e5a71a50c3">EVBUFFER_EOL_ANY</a>, 
<a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178a4aec5353e85fbb57ce3b1ee68f36f641">EVBUFFER_EOL_CRLF</a>, 
<a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178a814775b4a9773d34421e7e88ca8c58de">EVBUFFER_EOL_CRLF_STRICT</a>, 
<a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178ac572ea90e5a96a7ceb878f2a8ef48993">EVBUFFER_EOL_LF</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Used to tell evbuffer_readln what kind of line-ending to look for. </p>
 <a href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014">evbuffer_ptr_how</a> { <a class="el" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014a78a0ff3721ff5f1647f743dcfb2f13ee">EVBUFFER_PTR_SET</a>, 
<a class="el" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014a0bce00d78b5fbc55c478ff362269f428">EVBUFFER_PTR_ADD</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Defines how to adjust an <a class="el" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> by <a class="el" href="buffer_8h.html#a83ea16ab8facba6c68d2e6931d13fbf4" title="Sets the search pointer in the buffer to position.">evbuffer_ptr_set()</a>. </p>
 <a href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a69c3b8893a49bdd919642c6920c1fcb4">evbuffer_add</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, const void *data, size_t datlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append data to the end of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#a69c3b8893a49bdd919642c6920c1fcb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a9d2edd536246d70c50678a3865305414">evbuffer_add_buffer</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *outbuf, struct <a class="el" href="structevbuffer.html">evbuffer</a> *inbuf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move all data from one <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> into another <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#a9d2edd536246d70c50678a3865305414"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct evbuffer_cb_entry *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aa2a1509845c3d71f0adac4198aab0bf7">evbuffer_add_cb</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, <a class="el" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9">evbuffer_cb_func</a> cb, void *cbarg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new callback to an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#aa2a1509845c3d71f0adac4198aab0bf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a5db7e9063755accc56fdad87d662743e">evbuffer_add_file</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *outbuf, int fd, ev_off_t offset, ev_off_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy data from a file into the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> for writing to a socket.  <a href="#a5db7e9063755accc56fdad87d662743e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#adeb9457f344ddaf459726dbe348ac3db">evbuffer_add_printf</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, const char *fmt,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a formatted string to the end of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#adeb9457f344ddaf459726dbe348ac3db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a8a61b06a97974a86853becb9110b2ffd">evbuffer_add_reference</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *outbuf, const void *data, size_t datlen, <a class="el" href="buffer_8h.html#acc4dead0032a38143cb2c902417f9177">evbuffer_ref_cleanup_cb</a> cleanupfn, void *cleanupfn_arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference memory into an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> without copying.  <a href="#a8a61b06a97974a86853becb9110b2ffd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#acc385568d5129d4af10486b641b98f81">evbuffer_add_vprintf</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, const char *fmt, va_list ap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a va_list formatted string to the end of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#acc385568d5129d4af10486b641b98f81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#acda56baecd4b512f4e9f54a21e39177f">evbuffer_cb_clear_flags</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, struct evbuffer_cb_entry *cb, ev_uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the flags that are set for a callback on a buffer by removing some.  <a href="#acda56baecd4b512f4e9f54a21e39177f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a4ba44d01484f19fbfe7c18d2a175dc3b">evbuffer_cb_set_flags</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, struct evbuffer_cb_entry *cb, ev_uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the flags that are set for a callback on a buffer by adding more.  <a href="#a4ba44d01484f19fbfe7c18d2a175dc3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a732701957705ae6abe7c28effeb4aa39">evbuffer_clear_flags</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, ev_uint64_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the flags that are set for an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> by removing some.  <a href="#a732701957705ae6abe7c28effeb4aa39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a7a13a10fd1eb75cccf0ca29a05c5ba8a">evbuffer_commit_space</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *vec, int n_vecs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Commits previously reserved space.  <a href="#a7a13a10fd1eb75cccf0ca29a05c5ba8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ev_ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a8fa753475570f6529691ef8484cacc1b">evbuffer_copyout</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, void *data_out, size_t datlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>, and leave the buffer unchanged.  <a href="#a8fa753475570f6529691ef8484cacc1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a1c99c484430a81e641a783a273435074">evbuffer_defer_callbacks</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, struct <a class="el" href="structevent__base.html">event_base</a> *base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force all the callbacks on an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be run, not immediately after the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> is altered, but instead from inside the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> loop.  <a href="#a1c99c484430a81e641a783a273435074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a5c24f3bfbc941d693bf59b5d77d2c37f">evbuffer_drain</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a specified number of bytes data from the beginning of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#a5c24f3bfbc941d693bf59b5d77d2c37f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a1bf21d715f288541eb670c5f159f2264">evbuffer_enable_locking</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, void *lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable locking on an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> so that it can safely be used by multiple threads at the same time.  <a href="#a1bf21d715f288541eb670c5f159f2264"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a305caf7b9bfb8713e6ef383d61791f95">evbuffer_expand</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, size_t datlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Expands the available space in an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#a305caf7b9bfb8713e6ef383d61791f95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a0a87b43a5ae8c5589e77cde486b8a155">evbuffer_free</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate storage for an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#a0a87b43a5ae8c5589e77cde486b8a155"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a8611ca97c720d4dd605e272cc4136684">evbuffer_freeze</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, int at_front)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prevent calls that modify an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> from succeeding.  <a href="#a8611ca97c720d4dd605e272cc4136684"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#acd3d8507991609637a501e835e450331">evbuffer_get_contiguous_space</a> (const struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of contiguous available bytes in the first buffer chain.  <a href="#acd3d8507991609637a501e835e450331"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af1b44374d37735f3a90ae402eaeddf44">evbuffer_get_length</a> (const struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of bytes stored in the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#af1b44374d37735f3a90ae402eaeddf44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#af9542ca1ac381708c9b1450d91d168ec">evbuffer_lock</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire the lock on an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#af9542ca1ac381708c9b1450d91d168ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a8ebe44bfccd1d245cae17b1b7586092a">evbuffer_new</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate storage for a new <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#a8ebe44bfccd1d245cae17b1b7586092a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#adf4b59974a0cb989b7091f0b8677d511">evbuffer_peek</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, ev_ssize_t len, struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *start_at, struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *vec_out, int n_vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to peek at data inside an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> without removing it or copying it out.  <a href="#adf4b59974a0cb989b7091f0b8677d511"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a0daf99dbc837953427b60c462e5eba97">evbuffer_prepend</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, const void *data, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepends data to the beginning of the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#a0daf99dbc837953427b60c462e5eba97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a80ea4326ada348edc0e4fb53ad1df80c">evbuffer_prepend_buffer</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *dst, struct <a class="el" href="structevbuffer.html">evbuffer</a> *src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepends all data from the src <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to the beginning of the dst <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#a80ea4326ada348edc0e4fb53ad1df80c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a83ea16ab8facba6c68d2e6931d13fbf4">evbuffer_ptr_set</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *ptr, size_t position, enum <a class="el" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014">evbuffer_ptr_how</a> how)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the search pointer in the buffer to position.  <a href="#a83ea16ab8facba6c68d2e6931d13fbf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a07df786553218ae3a7b0ebd2c9471a96">evbuffer_pullup</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, ev_ssize_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the data at the begging of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> contiguous.  <a href="#a07df786553218ae3a7b0ebd2c9471a96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a464aff577b05417171192fc68539b77e">evbuffer_read</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, evutil_socket_t fd, int howmuch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from a file descriptor and store the result in an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#a464aff577b05417171192fc68539b77e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ae2460b5060948d3233342c4c81888650">evbuffer_readln</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, size_t *n_read_out, enum <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a> eol_style)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a single line from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#ae2460b5060948d3233342c4c81888650"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a0455fc72c74c758ed8dc9a0902af451a">evbuffer_remove</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, void *data, size_t datlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> and drain the bytes read.  <a href="#a0455fc72c74c758ed8dc9a0902af451a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a0bdef97f6a142425b271b329a90de869">evbuffer_remove_buffer</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *src, struct <a class="el" href="structevbuffer.html">evbuffer</a> *dst, size_t datlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> into another <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>, draining the bytes from the source buffer.  <a href="#a0bdef97f6a142425b271b329a90de869"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a4d7c75045267863306d37043d3f0809a">evbuffer_remove_cb</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, <a class="el" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9">evbuffer_cb_func</a> cb, void *cbarg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a callback from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>, given the function and argument used to add it.  <a href="#a4d7c75045267863306d37043d3f0809a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#afd1e51be92170b17178949a639dfa8ab">evbuffer_remove_cb_entry</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, struct evbuffer_cb_entry *ent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a callback from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>, given a handle returned from evbuffer_add_cb.  <a href="#afd1e51be92170b17178949a639dfa8ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ada49b2dc41bb09bb011765c1fc826a5d">evbuffer_reserve_space</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, ev_ssize_t size, struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *vec, int n_vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reserves space in the last chain or chains of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#ada49b2dc41bb09bb011765c1fc826a5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a61e15e2a355409587464c476d2481105">evbuffer_search</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, const char *what, size_t len, const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *start)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for a string within an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#a61e15e2a355409587464c476d2481105"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aa54aca588fa272157513191a9628d457">evbuffer_search_eol</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *start, size_t *eol_len_out, enum <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a> eol_style)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for an end-of-line string within an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#aa54aca588fa272157513191a9628d457"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a532ded8162d838b306e18839e9ab04af">evbuffer_search_range</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, const char *what, size_t len, const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *start, const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for a string within part of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#a532ded8162d838b306e18839e9ab04af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#ae7ca62b72232b4029288e4c3a06f1c6c">evbuffer_set_flags</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, ev_uint64_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the flags that are set for an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> by adding more.  <a href="#ae7ca62b72232b4029288e4c3a06f1c6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a0aceee5e8d8443df6d1b5daeb4daacfd">evbuffer_unfreeze</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, int at_front)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Re-enable calls that modify an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#a0aceee5e8d8443df6d1b5daeb4daacfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a538b62549df58369e10fd5703cafe92b">evbuffer_unlock</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the lock on an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#a538b62549df58369e10fd5703cafe92b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#a1207167bb14d5333326225f41477e910">evbuffer_write</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, evutil_socket_t fd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the contents of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to a file descriptor.  <a href="#a1207167bb14d5333326225f41477e910"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer_8h.html#aa0bea512e82177762be7cf0a28a9b03b">evbuffer_write_atmost</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, evutil_socket_t fd, ev_ssize_t howmuch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write some of the contents of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to a file descriptor.  <a href="#aa0bea512e82177762be7cf0a28a9b03b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Functions for buffering data for network sending or receiving. </p>
<p>An <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> can be used for preparing data before sending it to the network or conversely for reading data from the network. Evbuffers try to avoid memory copies as much as possible. As a result, evbuffers can be used to pass data around without actually incurring the overhead of copying the data.</p>
<p>A new <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> can be allocated with <a class="el" href="buffer_8h.html#a8ebe44bfccd1d245cae17b1b7586092a" title="Allocate storage for a new evbuffer.">evbuffer_new()</a>, and can be freed with <a class="el" href="buffer_8h.html#a0a87b43a5ae8c5589e77cde486b8a155" title="Deallocate storage for an evbuffer.">evbuffer_free()</a>. Most users will be using evbuffers via the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> interface. To access a bufferevent's evbuffers, use <a class="el" href="bufferevent_8h.html#a7bc716ede3a5fc1e9107ae522e545e0c" title="Returns the input buffer.">bufferevent_get_input()</a> and <a class="el" href="bufferevent_8h.html#af3dea057c5a276461dd94a1601682be1" title="Returns the output buffer.">bufferevent_get_output()</a>.</p>
<p>There are several guidelines for using evbuffers.</p>
<ul>
<li>if you already know how much data you are going to add as a result of calling <a class="el" href="buffer_8h.html#a69c3b8893a49bdd919642c6920c1fcb4" title="Append data to the end of an evbuffer.">evbuffer_add()</a> multiple times, it makes sense to use <a class="el" href="buffer_8h.html#a305caf7b9bfb8713e6ef383d61791f95" title="Expands the available space in an evbuffer.">evbuffer_expand()</a> first to make sure that enough memory is allocated before hand.</li>
</ul>
<ul>
<li><a class="el" href="buffer_8h.html#a9d2edd536246d70c50678a3865305414" title="Move all data from one evbuffer into another evbuffer.">evbuffer_add_buffer()</a> adds the contents of one buffer to the other without incurring any unnecessary memory copies.</li>
</ul>
<ul>
<li><a class="el" href="buffer_8h.html#a69c3b8893a49bdd919642c6920c1fcb4" title="Append data to the end of an evbuffer.">evbuffer_add()</a> and <a class="el" href="buffer_8h.html#a9d2edd536246d70c50678a3865305414" title="Move all data from one evbuffer into another evbuffer.">evbuffer_add_buffer()</a> do not mix very well: if you use them, you will wind up with fragmented memory in your buffer.</li>
</ul>
<ul>
<li>For high-performance code, you may want to avoid copying data into and out of buffers. You can skip the copy step by using <a class="el" href="buffer_8h.html#ada49b2dc41bb09bb011765c1fc826a5d" title="Reserves space in the last chain or chains of an evbuffer.">evbuffer_reserve_space()</a>/evbuffer_commit_space() when writing into a buffer, and <a class="el" href="buffer_8h.html#adf4b59974a0cb989b7091f0b8677d511" title="Function to peek at data inside an evbuffer without removing it or copying it out...">evbuffer_peek()</a> when reading.</li>
</ul>
<p>In Libevent 2.0 and later, evbuffers are represented using a linked list of memory chunks, with pointers to the first and last chunk in the chain.</p>
<p>As the contents of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> can be stored in multiple different memory blocks, it cannot be accessed directly. Instead, <a class="el" href="buffer_8h.html#a07df786553218ae3a7b0ebd2c9471a96" title="Makes the data at the begging of an evbuffer contiguous.">evbuffer_pullup()</a> can be used to force a specified number of bytes to be contiguous. This will cause memory reallocation and memory copies if the data is split across multiple blocks. It is more efficient, however, to use <a class="el" href="buffer_8h.html#adf4b59974a0cb989b7091f0b8677d511" title="Function to peek at data inside an evbuffer without removing it or copying it out...">evbuffer_peek()</a> if you don't require that the memory to be contiguous. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="aeb635643a72f8e57d50d7dee37308148"></a><!-- doxytag: member="buffer.h::EVBUFFER_CB_ENABLED" ref="aeb635643a72f8e57d50d7dee37308148" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVBUFFER_CB_ENABLED&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If this flag is not set, then a callback is temporarily disabled, and should not be invoked. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="buffer_8h.html#a4ba44d01484f19fbfe7c18d2a175dc3b" title="Change the flags that are set for a callback on a buffer by adding more.">evbuffer_cb_set_flags()</a>, <a class="el" href="buffer_8h.html#acda56baecd4b512f4e9f54a21e39177f" title="Change the flags that are set for a callback on a buffer by removing some.">evbuffer_cb_clear_flags()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0d9db8b232ebf8d63c660ec429981e91"></a><!-- doxytag: member="buffer.h::EVBUFFER_FLAG_DRAINS_TO_FD" ref="a0d9db8b232ebf8d63c660ec429981e91" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVBUFFER_FLAG_DRAINS_TO_FD&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If this flag is set, then we will not use <a class="el" href="buffer_8h.html#adf4b59974a0cb989b7091f0b8677d511" title="Function to peek at data inside an evbuffer without removing it or copying it out...">evbuffer_peek()</a>, <a class="el" href="buffer_8h.html#a0455fc72c74c758ed8dc9a0902af451a" title="Read data from an evbuffer and drain the bytes read.">evbuffer_remove()</a>, <a class="el" href="buffer_8h.html#a0bdef97f6a142425b271b329a90de869" title="Read data from an evbuffer into another evbuffer, draining the bytes from the source...">evbuffer_remove_buffer()</a>, and so on to read bytes from this buffer: we'll only take bytes out of this buffer by writing them to the network (as with evbuffer_write_atmost), by removing them without observing them (as with evbuffer_drain), or by copying them all out at once (as with evbuffer_add_buffer). </p>
<p>Using this option allows the implementation to use sendfile-based operations for <a class="el" href="buffer_8h.html#a5db7e9063755accc56fdad87d662743e" title="Copy data from a file into the evbuffer for writing to a socket.">evbuffer_add_file()</a>; see that function for more information.</p>
<p>This flag is on by default for bufferevents that can take advantage of it; you should never actually need to set it on a bufferevent's output buffer. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="af40adaa98b02da7fca55da29270266d9"></a><!-- doxytag: member="buffer.h::evbuffer_cb_func" ref="af40adaa98b02da7fca55da29270266d9" args=")(struct evbuffer *buffer, const struct evbuffer_cb_info *info, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9">evbuffer_cb_func</a>)(struct <a class="el" href="structevbuffer.html">evbuffer</a> *buffer, const struct <a class="el" href="structevbuffer__cb__info.html">evbuffer_cb_info</a> *info, void *arg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type definition for a callback that is invoked whenever data is added or removed from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<p>An <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> may have one or more callbacks set at a time. The order in which they are executed is undefined.</p>
<p>A callback function may add more callbacks, or remove itself from the list of callbacks, or add or remove data from the buffer. It may not remove another callback from the list.</p>
<p>If a callback adds or removes data from the buffer or from another buffer, this can cause a recursive invocation of your callback or other callbacks. If you ask for an infinite loop, you might just get one: watch out!</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the buffer whose size has changed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>a structure describing how the buffer changed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>a pointer to user data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc4dead0032a38143cb2c902417f9177"></a><!-- doxytag: member="buffer.h::evbuffer_ref_cleanup_cb" ref="acc4dead0032a38143cb2c902417f9177" args=")(const void *data, size_t datalen, void *extra)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="buffer_8h.html#acc4dead0032a38143cb2c902417f9177">evbuffer_ref_cleanup_cb</a>)(const void *data, size_t datalen, void *extra)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A cleanup function for a piece of memory added to an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> by reference. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="buffer_8h.html#a8a61b06a97974a86853becb9110b2ffd" title="Reference memory into an evbuffer without copying.">evbuffer_add_reference()</a> </dd></dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ad8daf54669a1d2094ce4251dbb502178"></a><!-- doxytag: member="buffer.h::evbuffer_eol_style" ref="ad8daf54669a1d2094ce4251dbb502178" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used to tell evbuffer_readln what kind of line-ending to look for. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad8daf54669a1d2094ce4251dbb502178ab7c6da1408b1b2ec3a6657e5a71a50c3"></a><!-- doxytag: member="EVBUFFER_EOL_ANY" ref="ad8daf54669a1d2094ce4251dbb502178ab7c6da1408b1b2ec3a6657e5a71a50c3" args="" -->EVBUFFER_EOL_ANY</em>&nbsp;</td><td>
<p>Any sequence of CR and LF characters is acceptable as an EOL. </p>
<p>Note that this style can produce ambiguous results: the sequence "CRLF" will be treated as a single EOL if it is all in the buffer at once, but if you first read a CR from the network and later read an LF from the network, it will be treated as two EOLs. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad8daf54669a1d2094ce4251dbb502178a4aec5353e85fbb57ce3b1ee68f36f641"></a><!-- doxytag: member="EVBUFFER_EOL_CRLF" ref="ad8daf54669a1d2094ce4251dbb502178a4aec5353e85fbb57ce3b1ee68f36f641" args="" -->EVBUFFER_EOL_CRLF</em>&nbsp;</td><td>
<p>An EOL is an LF, optionally preceded by a CR. </p>
<p>This style is most useful for implementing text-based internet protocols. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad8daf54669a1d2094ce4251dbb502178a814775b4a9773d34421e7e88ca8c58de"></a><!-- doxytag: member="EVBUFFER_EOL_CRLF_STRICT" ref="ad8daf54669a1d2094ce4251dbb502178a814775b4a9773d34421e7e88ca8c58de" args="" -->EVBUFFER_EOL_CRLF_STRICT</em>&nbsp;</td><td>
<p>An EOL is a CR followed by an LF. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad8daf54669a1d2094ce4251dbb502178ac572ea90e5a96a7ceb878f2a8ef48993"></a><!-- doxytag: member="EVBUFFER_EOL_LF" ref="ad8daf54669a1d2094ce4251dbb502178ac572ea90e5a96a7ceb878f2a8ef48993" args="" -->EVBUFFER_EOL_LF</em>&nbsp;</td><td>
<p>An EOL is a LF. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a13a9ee759900ce2964d16acd5f309014"></a><!-- doxytag: member="buffer.h::evbuffer_ptr_how" ref="a13a9ee759900ce2964d16acd5f309014" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014">evbuffer_ptr_how</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines how to adjust an <a class="el" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> by <a class="el" href="buffer_8h.html#a83ea16ab8facba6c68d2e6931d13fbf4" title="Sets the search pointer in the buffer to position.">evbuffer_ptr_set()</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="buffer_8h.html#a83ea16ab8facba6c68d2e6931d13fbf4" title="Sets the search pointer in the buffer to position.">evbuffer_ptr_set()</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a13a9ee759900ce2964d16acd5f309014a78a0ff3721ff5f1647f743dcfb2f13ee"></a><!-- doxytag: member="EVBUFFER_PTR_SET" ref="a13a9ee759900ce2964d16acd5f309014a78a0ff3721ff5f1647f743dcfb2f13ee" args="" -->EVBUFFER_PTR_SET</em>&nbsp;</td><td>
<p>Sets the pointer to the position; can be called on with an uninitialized <a class="el" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a>. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a13a9ee759900ce2964d16acd5f309014a0bce00d78b5fbc55c478ff362269f428"></a><!-- doxytag: member="EVBUFFER_PTR_ADD" ref="a13a9ee759900ce2964d16acd5f309014a0bce00d78b5fbc55c478ff362269f428" args="" -->EVBUFFER_PTR_ADD</em>&nbsp;</td><td>
<p>Advances the pointer by adding to the current position. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a69c3b8893a49bdd919642c6920c1fcb4"></a><!-- doxytag: member="buffer.h::evbuffer_add" ref="a69c3b8893a49bdd919642c6920c1fcb4" args="(struct evbuffer *buf, const void *data, size_t datlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>datlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append data to the end of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be appended to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>pointer to the beginning of the data buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>datlen</em>&nbsp;</td><td>the number of bytes to be copied from the data buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d2edd536246d70c50678a3865305414"></a><!-- doxytag: member="buffer.h::evbuffer_add_buffer" ref="a9d2edd536246d70c50678a3865305414" args="(struct evbuffer *outbuf, struct evbuffer *inbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_add_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>inbuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move all data from one <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> into another <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<p>This is a destructive add. The data from one buffer moves into the other buffer. However, no unnecessary memory copies occur.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>outbuf</em>&nbsp;</td><td>the output buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inbuf</em>&nbsp;</td><td>the input buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="buffer_8h.html#a0bdef97f6a142425b271b329a90de869" title="Read data from an evbuffer into another evbuffer, draining the bytes from the source...">evbuffer_remove_buffer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa2a1509845c3d71f0adac4198aab0bf7"></a><!-- doxytag: member="buffer.h::evbuffer_add_cb" ref="aa2a1509845c3d71f0adac4198aab0bf7" args="(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct evbuffer_cb_entry* evbuffer_add_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9">evbuffer_cb_func</a>&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cbarg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new callback to an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<p>Subsequent calls to <a class="el" href="buffer_8h.html#aa2a1509845c3d71f0adac4198aab0bf7" title="Add a new callback to an evbuffer.">evbuffer_add_cb()</a> add new callbacks. To remove this callback, call evbuffer_remove_cb or evbuffer_remove_cb_entry.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be monitored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the callback function to invoke when the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> is modified, or NULL to remove all callbacks. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbarg</em>&nbsp;</td><td>an argument to be provided to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a handle to the callback on success, or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a5db7e9063755accc56fdad87d662743e"></a><!-- doxytag: member="buffer.h::evbuffer_add_file" ref="a5db7e9063755accc56fdad87d662743e" args="(struct evbuffer *outbuf, int fd, ev_off_t offset, ev_off_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_add_file </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_off_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_off_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy data from a file into the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> for writing to a socket. </p>
<p>This function avoids unnecessary data copies between userland and kernel. If sendfile is available and the EVBUFFER_FLAG_DRAINS_TO_FD flag is set, it uses those functions. Otherwise, it tries to use mmap (or CreateFileMapping on Windows).</p>
<p>The function owns the resulting file descriptor and will close it when finished transferring data.</p>
<p>The results of using <a class="el" href="buffer_8h.html#a0455fc72c74c758ed8dc9a0902af451a" title="Read data from an evbuffer and drain the bytes read.">evbuffer_remove()</a> or <a class="el" href="buffer_8h.html#a07df786553218ae3a7b0ebd2c9471a96" title="Makes the data at the begging of an evbuffer contiguous.">evbuffer_pullup()</a> on evbuffers whose data was added using this function are undefined.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>outbuf</em>&nbsp;</td><td>the output buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>the file descriptor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset from which to read data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>how much data to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="adeb9457f344ddaf459726dbe348ac3db"></a><!-- doxytag: member="buffer.h::evbuffer_add_printf" ref="adeb9457f344ddaf459726dbe348ac3db" args="(struct evbuffer *buf, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_add_printf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a formatted string to the end of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<p>The string is formated as printf.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> that will be appended to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>a format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>arguments that will be passed to printf(3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes added if successful, or -1 if an error occurred.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>evutil_printf(), <a class="el" href="buffer_8h.html#acc385568d5129d4af10486b641b98f81" title="Append a va_list formatted string to the end of an evbuffer.">evbuffer_add_vprintf()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8a61b06a97974a86853becb9110b2ffd"></a><!-- doxytag: member="buffer.h::evbuffer_add_reference" ref="a8a61b06a97974a86853becb9110b2ffd" args="(struct evbuffer *outbuf, const void *data, size_t datlen, evbuffer_ref_cleanup_cb cleanupfn, void *cleanupfn_arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_add_reference </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>outbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>datlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#acc4dead0032a38143cb2c902417f9177">evbuffer_ref_cleanup_cb</a>&nbsp;</td>
          <td class="paramname"> <em>cleanupfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cleanupfn_arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reference memory into an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> without copying. </p>
<p>The memory needs to remain valid until all the added data has been read. This function keeps just a reference to the memory without actually incurring the overhead of a copy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>outbuf</em>&nbsp;</td><td>the output buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the memory to reference </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>datlen</em>&nbsp;</td><td>how memory to reference </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cleanupfn</em>&nbsp;</td><td>callback to be invoked when the memory is no longer referenced by this <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cleanupfn_arg</em>&nbsp;</td><td>optional argument to the cleanup callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="acc385568d5129d4af10486b641b98f81"></a><!-- doxytag: member="buffer.h::evbuffer_add_vprintf" ref="acc385568d5129d4af10486b641b98f81" args="(struct evbuffer *buf, const char *fmt, va_list ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_add_vprintf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a va_list formatted string to the end of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> that will be appended to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>a format string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ap</em>&nbsp;</td><td>a varargs va_list argument array that will be passed to vprintf(3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes added if successful, or -1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="acda56baecd4b512f4e9f54a21e39177f"></a><!-- doxytag: member="buffer.h::evbuffer_cb_clear_flags" ref="acda56baecd4b512f4e9f54a21e39177f" args="(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, ev_uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_cb_clear_flags </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct evbuffer_cb_entry *&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the flags that are set for a callback on a buffer by removing some. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> that the callback is watching. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the callback whose status we want to change. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>EVBUFFER_CB_ENABLED to disable the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ba44d01484f19fbfe7c18d2a175dc3b"></a><!-- doxytag: member="buffer.h::evbuffer_cb_set_flags" ref="a4ba44d01484f19fbfe7c18d2a175dc3b" args="(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, ev_uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_cb_set_flags </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct evbuffer_cb_entry *&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the flags that are set for a callback on a buffer by adding more. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> that the callback is watching. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the callback whose status we want to change. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>EVBUFFER_CB_ENABLED to re-enable the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a732701957705ae6abe7c28effeb4aa39"></a><!-- doxytag: member="buffer.h::evbuffer_clear_flags" ref="a732701957705ae6abe7c28effeb4aa39" args="(struct evbuffer *buf, ev_uint64_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_clear_flags </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint64_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the flags that are set for an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> by removing some. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> that the callback is watching. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the callback whose status we want to change. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>One or more EVBUFFER_FLAG_* options </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a13a10fd1eb75cccf0ca29a05c5ba8a"></a><!-- doxytag: member="buffer.h::evbuffer_commit_space" ref="a7a13a10fd1eb75cccf0ca29a05c5ba8a" args="(struct evbuffer *buf, struct evbuffer_iovec *vec, int n_vecs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_commit_space </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n_vecs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commits previously reserved space. </p>
<p>Commits some of the space previously reserved with <a class="el" href="buffer_8h.html#ada49b2dc41bb09bb011765c1fc826a5d" title="Reserves space in the last chain or chains of an evbuffer.">evbuffer_reserve_space()</a>. It then becomes available for reading.</p>
<p>This function may return an error if the pointer in the extents do not match those returned from evbuffer_reserve_space, or if data has been added to the buffer since the space was reserved.</p>
<p>If you want to commit less data than you got reserved space for, modify the iov_len pointer of the appropriate extent to a smaller value. Note that you may have received more space than you requested if it was available!</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> in which to reserve space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>one or two extents returned by evbuffer_reserve_space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_vecs</em>&nbsp;</td><td>the number of extents. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="buffer_8h.html#ada49b2dc41bb09bb011765c1fc826a5d" title="Reserves space in the last chain or chains of an evbuffer.">evbuffer_reserve_space()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8fa753475570f6529691ef8484cacc1b"></a><!-- doxytag: member="buffer.h::evbuffer_copyout" ref="a8fa753475570f6529691ef8484cacc1b" args="(struct evbuffer *buf, void *data_out, size_t datlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ev_ssize_t evbuffer_copyout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>datlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>, and leave the buffer unchanged. </p>
<p>If more bytes are requested than are available in the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>, we only extract as many bytes as were available.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be read from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_out</em>&nbsp;</td><td>the destination buffer to store the result </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>datlen</em>&nbsp;</td><td>the maximum size of the destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes read, or -1 if we can't drain the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c99c484430a81e641a783a273435074"></a><!-- doxytag: member="buffer.h::evbuffer_defer_callbacks" ref="a1c99c484430a81e641a783a273435074" args="(struct evbuffer *buffer, struct event_base *base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_defer_callbacks </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Force all the callbacks on an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be run, not immediately after the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> is altered, but instead from inside the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> loop. </p>
<p>This can be used to serialize all the callbacks to a single thread of execution. </p>

</div>
</div>
<a class="anchor" id="a5c24f3bfbc941d693bf59b5d77d2c37f"></a><!-- doxytag: member="buffer.h::evbuffer_drain" ref="a5c24f3bfbc941d693bf59b5d77d2c37f" args="(struct evbuffer *buf, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_drain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a specified number of bytes data from the beginning of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be drained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the number of bytes to drain from the beginning of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bf21d715f288541eb670c5f159f2264"></a><!-- doxytag: member="buffer.h::evbuffer_enable_locking" ref="a1bf21d715f288541eb670c5f159f2264" args="(struct evbuffer *buf, void *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_enable_locking </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>lock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable locking on an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> so that it can safely be used by multiple threads at the same time. </p>
<p>NOTE: when locking is enabled, the lock will be held when callbacks are invoked. This could result in deadlock if you aren't careful. Plan accordingly!</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>An <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to make lockable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>A lock object, or NULL if we should allocate our own. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a305caf7b9bfb8713e6ef383d61791f95"></a><!-- doxytag: member="buffer.h::evbuffer_expand" ref="a305caf7b9bfb8713e6ef383d61791f95" args="(struct evbuffer *buf, size_t datlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_expand </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>datlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands the available space in an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<p>Expands the available space in the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to at least datlen, so that appending datlen additional bytes will not require any new allocations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be expanded </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>datlen</em>&nbsp;</td><td>the new minimum length requirement </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a0a87b43a5ae8c5589e77cde486b8a155"></a><!-- doxytag: member="buffer.h::evbuffer_free" ref="a0a87b43a5ae8c5589e77cde486b8a155" args="(struct evbuffer *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evbuffer_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate storage for an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>pointer to the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8611ca97c720d4dd605e272cc4136684"></a><!-- doxytag: member="buffer.h::evbuffer_freeze" ref="a8611ca97c720d4dd605e272cc4136684" args="(struct evbuffer *buf, int at_front)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_freeze </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>at_front</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prevent calls that modify an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> from succeeding. </p>
<p>A buffer may frozen at the front, at the back, or at both the front and the back.</p>
<p>If the front of a buffer is frozen, operations that drain data from the front of the buffer, or that prepend data to the buffer, will fail until it is unfrozen. If the back a buffer is frozen, operations that append data from the buffer will fail until it is unfrozen.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to freeze </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>at_front</em>&nbsp;</td><td>If true, we freeze the front of the buffer. If false, we freeze the back. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="acd3d8507991609637a501e835e450331"></a><!-- doxytag: member="buffer.h::evbuffer_get_contiguous_space" ref="acd3d8507991609637a501e835e450331" args="(const struct evbuffer *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t evbuffer_get_contiguous_space </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of contiguous available bytes in the first buffer chain. </p>
<p>This is useful when processing data that might be split into multiple chains, or that might all be in the first chain. Calls to <a class="el" href="buffer_8h.html#a07df786553218ae3a7b0ebd2c9471a96" title="Makes the data at the begging of an evbuffer contiguous.">evbuffer_pullup()</a> that cause reallocation and copying of data can thus be avoided.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>pointer to the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if no data is available, otherwise the number of available bytes in the first buffer chain. </dd></dl>

</div>
</div>
<a class="anchor" id="af1b44374d37735f3a90ae402eaeddf44"></a><!-- doxytag: member="buffer.h::evbuffer_get_length" ref="af1b44374d37735f3a90ae402eaeddf44" args="(const struct evbuffer *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t evbuffer_get_length </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the total number of bytes stored in the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>pointer to the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes stored in the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af9542ca1ac381708c9b1450d91d168ec"></a><!-- doxytag: member="buffer.h::evbuffer_lock" ref="af9542ca1ac381708c9b1450d91d168ec" args="(struct evbuffer *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evbuffer_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Acquire the lock on an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<p>Has no effect if locking was not enabled with evbuffer_enable_locking. </p>

</div>
</div>
<a class="anchor" id="a8ebe44bfccd1d245cae17b1b7586092a"></a><!-- doxytag: member="buffer.h::evbuffer_new" ref="a8ebe44bfccd1d245cae17b1b7586092a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevbuffer.html">evbuffer</a>* evbuffer_new </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate storage for a new <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to a newly allocated <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> struct, or NULL if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="adf4b59974a0cb989b7091f0b8677d511"></a><!-- doxytag: member="buffer.h::evbuffer_peek" ref="adf4b59974a0cb989b7091f0b8677d511" args="(struct evbuffer *buffer, ev_ssize_t len, struct evbuffer_ptr *start_at, struct evbuffer_iovec *vec_out, int n_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_peek </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *&nbsp;</td>
          <td class="paramname"> <em>start_at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>vec_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n_vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to peek at data inside an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> without removing it or copying it out. </p>
<p>Pointers to the data are returned by filling the 'vec_out' array with pointers to one or more extents of data inside the buffer.</p>
<p>The total data in the extents that you get back may be more than you requested (if there is more data last extent than you asked for), or less (if you do not provide enough evbuffer_iovecs, or if the buffer does not have as much data as you asked to see).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to peek into, </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the number of bytes to try to peek. If len is negative, we will try to fill as much of vec_out as we can. If len is negative and vec_out is not provided, we return the number of evbuffer_iovecs that would be needed to get all the data in the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_at</em>&nbsp;</td><td>an <a class="el" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> indicating the point at which we should start looking for data. NULL means, "At the start of the
       buffer." </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec_out</em>&nbsp;</td><td>an array of <a class="el" href="structevbuffer__iovec.html" title="Describes a single extent of memory inside an evbuffer.">evbuffer_iovec</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_vec</em>&nbsp;</td><td>the length of vec_out. If 0, we only count how many extents would be necessary to point to the requested amount of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of extents needed. This may be less than n_vec if we didn't need all the evbuffer_iovecs we were given, or more than n_vec if we would need more to return all the data that was requested. </dd></dl>

</div>
</div>
<a class="anchor" id="a0daf99dbc837953427b60c462e5eba97"></a><!-- doxytag: member="buffer.h::evbuffer_prepend" ref="a0daf99dbc837953427b60c462e5eba97" args="(struct evbuffer *buf, const void *data, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_prepend </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepends data to the beginning of the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to which to prepend data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>a pointer to the memory to prepend </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the number of bytes to prepend </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a80ea4326ada348edc0e4fb53ad1df80c"></a><!-- doxytag: member="buffer.h::evbuffer_prepend_buffer" ref="a80ea4326ada348edc0e4fb53ad1df80c" args="(struct evbuffer *dst, struct evbuffer *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_prepend_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepends all data from the src <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to the beginning of the dst <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to which to prepend data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to prepend; it will be emptied as a result </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a83ea16ab8facba6c68d2e6931d13fbf4"></a><!-- doxytag: member="buffer.h::evbuffer_ptr_set" ref="a83ea16ab8facba6c68d2e6931d13fbf4" args="(struct evbuffer *buffer, struct evbuffer_ptr *ptr, size_t position, enum evbuffer_ptr_how how)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_ptr_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014">evbuffer_ptr_how</a>&nbsp;</td>
          <td class="paramname"> <em>how</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the search pointer in the buffer to position. </p>
<p>If <a class="el" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> is not initialized. This function can only be called with EVBUFFER_PTR_SET.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>a pointer to a struct <a class="el" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>the position at which to start the next search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>how</em>&nbsp;</td><td>determines how the pointer should be manipulated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or -1 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a07df786553218ae3a7b0ebd2c9471a96"></a><!-- doxytag: member="buffer.h::evbuffer_pullup" ref="a07df786553218ae3a7b0ebd2c9471a96" args="(struct evbuffer *buf, ev_ssize_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* evbuffer_pullup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes the data at the begging of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> contiguous. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to make contiguous </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the number of bytes to make contiguous, or -1 to make the entire buffer contiguous. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the contiguous memory array </dd></dl>

</div>
</div>
<a class="anchor" id="a464aff577b05417171192fc68539b77e"></a><!-- doxytag: member="buffer.h::evbuffer_read" ref="a464aff577b05417171192fc68539b77e" args="(struct evbuffer *buffer, evutil_socket_t fd, int howmuch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>howmuch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read from a file descriptor and store the result in an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to store the result </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>the file descriptor to read from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>howmuch</em>&nbsp;</td><td>the number of bytes to be read </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes read, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="buffer_8h.html#a1207167bb14d5333326225f41477e910" title="Write the contents of an evbuffer to a file descriptor.">evbuffer_write()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae2460b5060948d3233342c4c81888650"></a><!-- doxytag: member="buffer.h::evbuffer_readln" ref="ae2460b5060948d3233342c4c81888650" args="(struct evbuffer *buffer, size_t *n_read_out, enum evbuffer_eol_style eol_style)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* evbuffer_readln </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>n_read_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a>&nbsp;</td>
          <td class="paramname"> <em>eol_style</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a single line from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<p>Reads a line terminated by an EOL as determined by the evbuffer_eol_style argument. Returns a newly allocated nul-terminated string; the caller must free the returned value. The EOL is not included in the returned string.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to read from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_read_out</em>&nbsp;</td><td>if non-NULL, points to a size_t that is set to the number of characters in the returned string. This is useful for strings that can contain NUL characters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eol_style</em>&nbsp;</td><td>the style of line-ending to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a single line, or NULL if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a0455fc72c74c758ed8dc9a0902af451a"></a><!-- doxytag: member="buffer.h::evbuffer_remove" ref="a0455fc72c74c758ed8dc9a0902af451a" args="(struct evbuffer *buf, void *data, size_t datlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>datlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> and drain the bytes read. </p>
<p>If more bytes are requested than are available in the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>, we only extract as many bytes as were available.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be read from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the destination buffer to store the result </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>datlen</em>&nbsp;</td><td>the maximum size of the destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes read, or -1 if we can't drain the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bdef97f6a142425b271b329a90de869"></a><!-- doxytag: member="buffer.h::evbuffer_remove_buffer" ref="a0bdef97f6a142425b271b329a90de869" args="(struct evbuffer *src, struct evbuffer *dst, size_t datlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_remove_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>datlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> into another <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>, draining the bytes from the source buffer. </p>
<p>This function avoids copy operations to the extent possible.</p>
<p>If more bytes are requested than are available in src, the src buffer is drained completely.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be read from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>the destination <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to store the result into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>datlen</em>&nbsp;</td><td>the maximum numbers of bytes to transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes read </dd></dl>

</div>
</div>
<a class="anchor" id="a4d7c75045267863306d37043d3f0809a"></a><!-- doxytag: member="buffer.h::evbuffer_remove_cb" ref="a4d7c75045267863306d37043d3f0809a" args="(struct evbuffer *buffer, evbuffer_cb_func cb, void *cbarg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_remove_cb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9">evbuffer_cb_func</a>&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cbarg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a callback from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>, given the function and argument used to add it. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if a callback was removed, or -1 if no matching callback was found. </dd></dl>

</div>
</div>
<a class="anchor" id="afd1e51be92170b17178949a639dfa8ab"></a><!-- doxytag: member="buffer.h::evbuffer_remove_cb_entry" ref="afd1e51be92170b17178949a639dfa8ab" args="(struct evbuffer *buffer, struct evbuffer_cb_entry *ent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_remove_cb_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct evbuffer_cb_entry *&nbsp;</td>
          <td class="paramname"> <em>ent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a callback from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>, given a handle returned from evbuffer_add_cb. </p>
<p>Calling this function invalidates the handle.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if a callback was removed, or -1 if no matching callback was found. </dd></dl>

</div>
</div>
<a class="anchor" id="ada49b2dc41bb09bb011765c1fc826a5d"></a><!-- doxytag: member="buffer.h::evbuffer_reserve_space" ref="ada49b2dc41bb09bb011765c1fc826a5d" args="(struct evbuffer *buf, ev_ssize_t size, struct evbuffer_iovec *vec, int n_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_reserve_space </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__iovec.html">evbuffer_iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n_vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reserves space in the last chain or chains of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<p>Makes space available in the last chain or chains of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> that can be arbitrarily written to by a user. The space does not become available for reading until it has been committed with <a class="el" href="buffer_8h.html#a7a13a10fd1eb75cccf0ca29a05c5ba8a" title="Commits previously reserved space.">evbuffer_commit_space()</a>.</p>
<p>The space is made available as one or more extents, represented by an initial pointer and a length. You can force the memory to be available as only one extent. Allowing more extents, however, makes the function more efficient.</p>
<p>Multiple subsequent calls to this function will make the same space available until <a class="el" href="buffer_8h.html#a7a13a10fd1eb75cccf0ca29a05c5ba8a" title="Commits previously reserved space.">evbuffer_commit_space()</a> has been called.</p>
<p>It is an error to do anything that moves around the buffer's internal memory structures before committing the space.</p>
<p>NOTE: The code currently does not ever use more than two extents. This may change in future versions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> in which to reserve space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>how much space to make available, at minimum. The total length of the extents may be greater than the requested length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>an array of one or more <a class="el" href="structevbuffer__iovec.html" title="Describes a single extent of memory inside an evbuffer.">evbuffer_iovec</a> structures to hold pointers to the reserved extents of memory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_vec</em>&nbsp;</td><td>The length of the vec array. Must be at least 1; 2 is more efficient. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of provided extents, or -1 on error. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="buffer_8h.html#a7a13a10fd1eb75cccf0ca29a05c5ba8a" title="Commits previously reserved space.">evbuffer_commit_space()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a61e15e2a355409587464c476d2481105"></a><!-- doxytag: member="buffer.h::evbuffer_search" ref="a61e15e2a355409587464c476d2481105" args="(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> evbuffer_search </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *&nbsp;</td>
          <td class="paramname"> <em>start</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for a string within an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be searched </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>what</em>&nbsp;</td><td>the string to be searched for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the length of the search string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>NULL or a pointer to a valid struct <a class="el" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a struct <a class="el" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> whose 'pos' field has the offset of the first occurrence of the string in the buffer after 'start'. The 'pos' field of the result is -1 if the string was not found. </dd></dl>

</div>
</div>
<a class="anchor" id="aa54aca588fa272157513191a9628d457"></a><!-- doxytag: member="buffer.h::evbuffer_search_eol" ref="aa54aca588fa272157513191a9628d457" args="(struct evbuffer *buffer, struct evbuffer_ptr *start, size_t *eol_len_out, enum evbuffer_eol_style eol_style)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> evbuffer_search_eol </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>eol_len_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a>&nbsp;</td>
          <td class="paramname"> <em>eol_style</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for an end-of-line string within an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be searched </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>NULL or a pointer to a valid struct <a class="el" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> to start searching at. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eol_len_out</em>&nbsp;</td><td>If non-NULL, the pointed-to value will be set to the length of the end-of-line string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eol_style</em>&nbsp;</td><td>The kind of EOL to look for; see <a class="el" href="buffer_8h.html#ae2460b5060948d3233342c4c81888650" title="Read a single line from an evbuffer.">evbuffer_readln()</a> for more information </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a struct <a class="el" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> whose 'pos' field has the offset of the first occurrence EOL in the buffer after 'start'. The 'pos' field of the result is -1 if the string was not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a532ded8162d838b306e18839e9ab04af"></a><!-- doxytag: member="buffer.h::evbuffer_search_range" ref="a532ded8162d838b306e18839e9ab04af" args="(struct evbuffer *buffer, const char *what, size_t len, const struct evbuffer_ptr *start, const struct evbuffer_ptr *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> evbuffer_search_range </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structevbuffer__ptr.html">evbuffer_ptr</a> *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for a string within part of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be searched </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>what</em>&nbsp;</td><td>the string to be searched for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the length of the search string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>NULL or a pointer to a valid struct <a class="el" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> that indicates where we should start searching. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>NULL or a pointer to a valid struct <a class="el" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> that indicates where we should stop searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a struct <a class="el" href="structevbuffer__ptr.html" title="Pointer to a position within an evbuffer.">evbuffer_ptr</a> whose 'pos' field has the offset of the first occurrence of the string in the buffer after 'start'. The 'pos' field of the result is -1 if the string was not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7ca62b72232b4029288e4c3a06f1c6c"></a><!-- doxytag: member="buffer.h::evbuffer_set_flags" ref="ae7ca62b72232b4029288e4c3a06f1c6c" args="(struct evbuffer *buf, ev_uint64_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_set_flags </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint64_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the flags that are set for an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> by adding more. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> that the callback is watching. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the callback whose status we want to change. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>One or more EVBUFFER_FLAG_* options </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a0aceee5e8d8443df6d1b5daeb4daacfd"></a><!-- doxytag: member="buffer.h::evbuffer_unfreeze" ref="a0aceee5e8d8443df6d1b5daeb4daacfd" args="(struct evbuffer *buf, int at_front)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_unfreeze </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>at_front</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-enable calls that modify an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The buffer to un-freeze </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>at_front</em>&nbsp;</td><td>If true, we unfreeze the front of the buffer. If false, we unfreeze the back. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a538b62549df58369e10fd5703cafe92b"></a><!-- doxytag: member="buffer.h::evbuffer_unlock" ref="a538b62549df58369e10fd5703cafe92b" args="(struct evbuffer *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evbuffer_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the lock on an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<p>Has no effect if locking was not enabled with evbuffer_enable_locking. </p>

</div>
</div>
<a class="anchor" id="a1207167bb14d5333326225f41477e910"></a><!-- doxytag: member="buffer.h::evbuffer_write" ref="a1207167bb14d5333326225f41477e910" args="(struct evbuffer *buffer, evutil_socket_t fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname"> <em>fd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write the contents of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to a file descriptor. </p>
<p>The <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> will be drained after the bytes have been successfully written.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be written and drained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>the file descriptor to be written to </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes written, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="buffer_8h.html#a464aff577b05417171192fc68539b77e" title="Read from a file descriptor and store the result in an evbuffer.">evbuffer_read()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa0bea512e82177762be7cf0a28a9b03b"></a><!-- doxytag: member="buffer.h::evbuffer_write_atmost" ref="aa0bea512e82177762be7cf0a28a9b03b" args="(struct evbuffer *buffer, evutil_socket_t fd, ev_ssize_t howmuch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_write_atmost </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&nbsp;</td>
          <td class="paramname"> <em>howmuch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write some of the contents of an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to a file descriptor. </p>
<p>The <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> will be drained after the bytes have been successfully written.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be written and drained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>the file descriptor to be written to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>howmuch</em>&nbsp;</td><td>the largest allowable number of bytes to write, or -1 to write as many bytes as we can. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes written, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="buffer_8h.html#a464aff577b05417171192fc68539b77e" title="Read from a file descriptor and store the result in an evbuffer.">evbuffer_read()</a> </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 17 Mar 2015 for libevent by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
