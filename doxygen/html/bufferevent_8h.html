<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libevent: event2/bufferevent.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>event2/bufferevent.h File Reference</h1>
<p>Functions for buffering data for network sending or receiving.  
<a href="#_details">More...</a></p>
<code>#include &lt;event2/event-config.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="util_8h_source.html">event2/util.h</a>&gt;</code><br/>

<p><a href="bufferevent_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbufferevent.html">bufferevent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An opaque type for handling buffered IO.  <a href="structbufferevent.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a78fc86349f408552be0fdf249db673ec">EV_RATE_LIMIT_MAX</a>&nbsp;&nbsp;&nbsp;EV_SSIZE_MAX</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum configurable rate- or burst-limit.  <a href="#a78fc86349f408552be0fdf249db673ec"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Bufferevent event codes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpe1216b1b61e9ac8f6be43415d746e46e"></a>These flags are passed as arguments to a bufferevent's <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> callback. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#affb7a7e5e21e1541ba6f43f950d92993">BEV_EVENT_CONNECTED</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">connect operation finished.  <a href="#affb7a7e5e21e1541ba6f43f950d92993"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d7d8c93cf62e6f3d37c0cbac75aebcc"></a><!-- doxytag: member="bufferevent.h::BEV_EVENT_EOF" ref="a4d7d8c93cf62e6f3d37c0cbac75aebcc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a4d7d8c93cf62e6f3d37c0cbac75aebcc">BEV_EVENT_EOF</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">eof file reached <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f112d7a064258bdabf8d5182a3bf5e4"></a><!-- doxytag: member="bufferevent.h::BEV_EVENT_ERROR" ref="a5f112d7a064258bdabf8d5182a3bf5e4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a5f112d7a064258bdabf8d5182a3bf5e4">BEV_EVENT_ERROR</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unrecoverable error encountered <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a504816ca8678e4f3d0bee2700fda524d"></a><!-- doxytag: member="bufferevent.h::BEV_EVENT_READING" ref="a504816ca8678e4f3d0bee2700fda524d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a504816ca8678e4f3d0bee2700fda524d">BEV_EVENT_READING</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">error encountered while reading <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa537428e3ac2c8d2dbb4ec041f09347f"></a><!-- doxytag: member="bufferevent.h::BEV_EVENT_TIMEOUT" ref="aa537428e3ac2c8d2dbb4ec041f09347f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aa537428e3ac2c8d2dbb4ec041f09347f">BEV_EVENT_TIMEOUT</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">user-specified timeout reached <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a557afaa0ce75e6bbb71fdcd68c35d077"></a><!-- doxytag: member="bufferevent.h::BEV_EVENT_WRITING" ref="a557afaa0ce75e6bbb71fdcd68c35d077" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a557afaa0ce75e6bbb71fdcd68c35d077">BEV_EVENT_WRITING</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">error encountered while writing <br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a75e8fa059136e13c04c237e9c03cdbe8">bufferevent_data_cb</a> )(struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, void *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A read or write callback for a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.  <a href="#a75e8fa059136e13c04c237e9c03cdbe8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a79b5f4b983f8e67005416738c6494ac6">bufferevent_event_cb</a> )(struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, short what, void *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An event/error callback for a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.  <a href="#a79b5f4b983f8e67005416738c6494ac6"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25">bufferevent_flush_mode</a> { <a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25a81903ce04ca68ac1680dd0b7a28a7fce">BEV_NORMAL</a> =  0, 
<a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25a77e7f15a95815dcaaef27fdabb0e6164">BEV_FLUSH</a> =  1, 
<a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25acb248a91854bbebd773061df7f4bbc94">BEV_FINISHED</a> =  2
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Flags that can be passed into filters to let them know how to deal with the incoming data. </p>
 <a href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aa4919449c62c6483e2d135509190dc65">bufferevent_options</a> { <a class="el" href="bufferevent_8h.html#aa4919449c62c6483e2d135509190dc65a5dc89d74ef445da33295d00c8f6adc90">BEV_OPT_CLOSE_ON_FREE</a> =  (1&lt;&lt;0), 
<a class="el" href="bufferevent_8h.html#aa4919449c62c6483e2d135509190dc65adfb637881b739eff1441ad848a5e3a2d">BEV_OPT_THREADSAFE</a> =  (1&lt;&lt;1), 
<a class="el" href="bufferevent_8h.html#aa4919449c62c6483e2d135509190dc65a2fbeb24d0156aa2492c23aaace73f1d3">BEV_OPT_DEFER_CALLBACKS</a> =  (1&lt;&lt;2), 
<a class="el" href="bufferevent_8h.html#aa4919449c62c6483e2d135509190dc65acb8ca6f6422fb8f9a748521cf8c4caf5">BEV_OPT_UNLOCK_CALLBACKS</a> =  (1&lt;&lt;3)
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Options that can be specified when creating a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
 <a href="bufferevent_8h.html#aa4919449c62c6483e2d135509190dc65">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aadb00f5d5c054bb705db78db327ef261">bufferevent_add_to_rate_limit_group</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, struct bufferevent_rate_limit_group *g)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add 'bev' to the list of bufferevents whose aggregate reading and writing is restricted by 'g'.  <a href="#aadb00f5d5c054bb705db78db327ef261"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a0697dabdb9b4057ae71b40a2f0e45fed">bufferevent_base_set</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> to a specific <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a>.  <a href="#a0697dabdb9b4057ae71b40a2f0e45fed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aa15582fe250247aa98d4897527215727">bufferevent_disable</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, short <a class="el" href="structevent.html">event</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.  <a href="#aa15582fe250247aa98d4897527215727"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a1b9a3412e8c8e122c745b33d46b9643e">bufferevent_enable</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, short <a class="el" href="structevent.html">event</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.  <a href="#a1b9a3412e8c8e122c745b33d46b9643e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a03376a35668ff9b6dc905cce0d89876d">bufferevent_flush</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, short iotype, enum <a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25">bufferevent_flush_mode</a> mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Triggers the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> to produce more data if possible.  <a href="#a03376a35668ff9b6dc905cce0d89876d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a474a4cef8fd80bea09a636b5f3055bec">bufferevent_free</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate the storage associated with a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> structure.  <a href="#a474a4cef8fd80bea09a636b5f3055bec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cabb56040b43ba1a92efd21c4a89890"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_base" ref="a5cabb56040b43ba1a92efd21c4a89890" args="(struct bufferevent *bev)" -->
struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a5cabb56040b43ba1a92efd21c4a89890">bufferevent_get_base</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> used by a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#afbb4adabeb188cc9000bdee4ba23bdb2">bufferevent_get_enabled</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the events that are enabled on a given <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.  <a href="#afbb4adabeb188cc9000bdee4ba23bdb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a7bc716ede3a5fc1e9107ae522e545e0c">bufferevent_get_input</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the input buffer.  <a href="#a7bc716ede3a5fc1e9107ae522e545e0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2a8edb561655b13b013363726188f0c"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_max_to_read" ref="ab2a8edb561655b13b013363726188f0c" args="(struct bufferevent *bev)" -->
ev_ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>bufferevent_get_max_to_read</b> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97487188a8ace977c3a74e330d2f224d"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_max_to_write" ref="a97487188a8ace977c3a74e330d2f224d" args="(struct bufferevent *bev)" -->
ev_ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>bufferevent_get_max_to_write</b> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#af3dea057c5a276461dd94a1601682be1">bufferevent_get_output</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the output buffer.  <a href="#af3dea057c5a276461dd94a1601682be1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d40fb7aea3c48e25d616bbe4b0fda65"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_underlying" ref="a8d40fb7aea3c48e25d616bbe4b0fda65" args="(struct bufferevent *bufev)" -->
struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a8d40fb7aea3c48e25d616bbe4b0fda65">bufferevent_get_underlying</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the underlying <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> associated with a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> (if the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> is a wrapper), or NULL if there is no underlying <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa959659c8ba1c56c3444b5c147762a91"></a><!-- doxytag: member="bufferevent.h::bufferevent_getfd" ref="aa959659c8ba1c56c3444b5c147762a91" args="(struct bufferevent *bufev)" -->
evutil_socket_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aa959659c8ba1c56c3444b5c147762a91">bufferevent_getfd</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the file descriptor associated with a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>, or -1 if no file descriptor is associated with the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a56a61802037478591048b4967fa15599">bufferevent_lock</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire the lock on a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.  <a href="#a56a61802037478591048b4967fa15599"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a3ebd2a56a2ef87106bf76630eb0926b6">bufferevent_pair_get_partner</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given one <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> returned by <a class="el" href="bufferevent_8h.html#af8932010b0a590ddf9848026e8a99059" title="Allocate a pair of linked bufferevents.">bufferevent_pair_new()</a>, returns the other one if it still exists.  <a href="#a3ebd2a56a2ef87106bf76630eb0926b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#af8932010b0a590ddf9848026e8a99059">bufferevent_pair_new</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, int options, struct <a class="el" href="structbufferevent.html">bufferevent</a> *pair[2])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a pair of linked bufferevents.  <a href="#af8932010b0a590ddf9848026e8a99059"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a73e1daaa7c4d52c95b16c9944fa62e90">bufferevent_priority_set</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, int pri)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a priority to a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.  <a href="#a73e1daaa7c4d52c95b16c9944fa62e90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#adf4304c0c47fedb8122700ce1f0def8b">bufferevent_rate_limit_group_free</a> (struct bufferevent_rate_limit_group *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a rate-limiting group.  <a href="#adf4304c0c47fedb8122700ce1f0def8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a4fec52eebbe5f925dfc2eaa60100124d">bufferevent_rate_limit_group_get_totals</a> (struct bufferevent_rate_limit_group *grp, ev_uint64_t *total_read_out, ev_uint64_t *total_written_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inspect the total bytes read/written on a group.  <a href="#a4fec52eebbe5f925dfc2eaa60100124d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
bufferevent_rate_limit_group *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#acf75d7e04a54e7fe4543f7efd596e7f7">bufferevent_rate_limit_group_new</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, const struct ev_token_bucket_cfg *cfg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new rate-limit group for bufferevents.  <a href="#acf75d7e04a54e7fe4543f7efd596e7f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a38c81c84dc02318bd34f41d84f468a98">bufferevent_rate_limit_group_reset_totals</a> (struct bufferevent_rate_limit_group *grp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the total bytes read/written on a group.  <a href="#a38c81c84dc02318bd34f41d84f468a98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a9b766efb61af2cb92d24f6e4caa38a53">bufferevent_rate_limit_group_set_cfg</a> (struct bufferevent_rate_limit_group *, const struct ev_token_bucket_cfg *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the rate-limiting settings for a given rate-limiting group.  <a href="#a9b766efb61af2cb92d24f6e4caa38a53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aa2499cfb56976dcf3c6b846801043214">bufferevent_rate_limit_group_set_min_share</a> (struct bufferevent_rate_limit_group *, size_t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the smallest quantum we're willing to allocate to any single <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> in a group for reading or writing at a time.  <a href="#aa2499cfb56976dcf3c6b846801043214"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a6bd435529e20a39b24fead9ddcd966ba">bufferevent_read</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, void *data, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data from a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> buffer.  <a href="#a6bd435529e20a39b24fead9ddcd966ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#ab2246fd48085c1acc9e98747a83af041">bufferevent_read_buffer</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data from a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> buffer into an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>.  <a href="#ab2246fd48085c1acc9e98747a83af041"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#abdbf64b4203fe6b65b263661ef18c6f2">bufferevent_remove_from_rate_limit_group</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove 'bev' from its current rate-limit group (if any).  <a href="#abdbf64b4203fe6b65b263661ef18c6f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aeb7bc9d8af4dd74b3de8dcd2941e6e02">bufferevent_set_rate_limit</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, struct ev_token_bucket_cfg *cfg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the rate-limit of a the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> 'bev' to the one specified in 'cfg'.  <a href="#aeb7bc9d8af4dd74b3de8dcd2941e6e02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a3686d744e67e9a530ebf8ab888ade2cf">bufferevent_set_timeouts</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, const struct timeval *timeout_read, const struct timeval *timeout_write)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the read and write timeout for a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.  <a href="#a3686d744e67e9a530ebf8ab888ade2cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a63792519cb94a38beccb5e1390cd6198">bufferevent_setcb</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, <a class="el" href="bufferevent_8h.html#a75e8fa059136e13c04c237e9c03cdbe8">bufferevent_data_cb</a> readcb, <a class="el" href="bufferevent_8h.html#a75e8fa059136e13c04c237e9c03cdbe8">bufferevent_data_cb</a> writecb, <a class="el" href="bufferevent_8h.html#a79b5f4b983f8e67005416738c6494ac6">bufferevent_event_cb</a> eventcb, void *cbarg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the callbacks for a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.  <a href="#a63792519cb94a38beccb5e1390cd6198"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a0a367e404942c11265bfcd0b693aa120">bufferevent_setfd</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, evutil_socket_t fd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the file descriptor on which the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> operates.  <a href="#a0a367e404942c11265bfcd0b693aa120"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a74e3835e99f8eb73bb1cd7afa7427049">bufferevent_setwatermark</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, short events, size_t lowmark, size_t highmark)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the watermarks for read and write events.  <a href="#a74e3835e99f8eb73bb1cd7afa7427049"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#ac2ecbb906883ea848f7bca767d479a2a">bufferevent_socket_connect</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *, struct sockaddr *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Launch a connect() attempt with a socket-based <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.  <a href="#ac2ecbb906883ea848f7bca767d479a2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a797686b522045aefb217c6b87ea7ae4a">bufferevent_socket_connect_hostname</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *, struct evdns_base *, int, const char *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve the hostname 'hostname' and connect to it as with <a class="el" href="bufferevent_8h.html#ac2ecbb906883ea848f7bca767d479a2a" title="Launch a connect() attempt with a socket-based bufferevent.">bufferevent_socket_connect()</a>.  <a href="#a797686b522045aefb217c6b87ea7ae4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a9a66b02bce652cdbcc7d26636ce26d67">bufferevent_socket_get_dns_error</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the error code for the last failed DNS lookup attempt made by <a class="el" href="bufferevent_8h.html#a797686b522045aefb217c6b87ea7ae4a" title="Resolve the hostname &#39;hostname&#39; and connect to it as with bufferevent_socket_connect()...">bufferevent_socket_connect_hostname()</a>.  <a href="#a9a66b02bce652cdbcc7d26636ce26d67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a501557193aa56c9f4923583d9d734395">bufferevent_socket_new</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, evutil_socket_t fd, int options)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new socket <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> over an existing socket.  <a href="#a501557193aa56c9f4923583d9d734395"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a53fd135567d95cab72b8bad473c97510">bufferevent_unlock</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the lock on a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.  <a href="#a53fd135567d95cab72b8bad473c97510"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#abc606695cd6bb2e3f25c4330d0c9e3ab">bufferevent_write</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, const void *data, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write data to a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> buffer.  <a href="#abc606695cd6bb2e3f25c4330d0c9e3ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a3b140a32a4d16c402433130dc8c3bde4">bufferevent_write_buffer</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write data from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> buffer.  <a href="#a3b140a32a4d16c402433130dc8c3bde4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#ad918ea1e7f7967e5db895c7dde5b78ae">ev_token_bucket_cfg_free</a> (struct ev_token_bucket_cfg *cfg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all storage held in 'cfg'.  <a href="#ad918ea1e7f7967e5db895c7dde5b78ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct ev_token_bucket_cfg *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a60dd9d6469537b9099d2f6299c114ae6">ev_token_bucket_cfg_new</a> (size_t read_rate, size_t read_burst, size_t write_rate, size_t write_burst, const struct timeval *tick_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize and return a new object to configure the rate-limiting behavior of bufferevents.  <a href="#a60dd9d6469537b9099d2f6299c114ae6"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Rate limit manipulation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpe8b14baa4d79a5e7721adc58a70c2873"></a>Subtract a number of bytes from a bufferevent's read or write bucket.</p>
<p>The decrement value can be negative, if you want to manually refill the bucket. If the change puts the bucket above or below zero, the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> will resume or suspend reading writing as appropriate. These functions make no change in the buckets for the bufferevent's group, if any.</p>
<p>Returns 0 on success, -1 on internal error. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae22e5c618f1f93afcd6c2adb1b9ca165"></a><!-- doxytag: member="bufferevent.h::bufferevent_decrement_read_limit" ref="ae22e5c618f1f93afcd6c2adb1b9ca165" args="(struct bufferevent *bev, ev_ssize_t decr)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>bufferevent_decrement_read_limit</b> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, ev_ssize_t decr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afedbe4264b84e4e8c65bdeba1bd42b6a"></a><!-- doxytag: member="bufferevent.h::bufferevent_decrement_write_limit" ref="afedbe4264b84e4e8c65bdeba1bd42b6a" args="(struct bufferevent *bev, ev_ssize_t decr)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>bufferevent_decrement_write_limit</b> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, ev_ssize_t decr)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Rate limit inspection</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6ba2cc97cb0cf2def4252c54244c5aa5"></a>Return the current read or write bucket size for a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.</p>
<p>If it is not configured with a per-bufferevent ratelimit, return EV_SSIZE_MAX. This function does not inspect the group limit, if any. Note that it can return a negative value if the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> has been made to read or write more than its limit. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73312a98fb1823be7936833a83b46a9d"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_read_limit" ref="a73312a98fb1823be7936833a83b46a9d" args="(struct bufferevent *bev)" -->
ev_ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>bufferevent_get_read_limit</b> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90ee89498a9bd8777267fbca7947827d"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_write_limit" ref="a90ee89498a9bd8777267fbca7947827d" args="(struct bufferevent *bev)" -->
ev_ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>bufferevent_get_write_limit</b> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Group rate limit manipulation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp57e621f34587553a500fc3eabeb15db4"></a>Subtract a number of bytes from a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> rate-limiting group's read or write bucket.</p>
<p>The decrement value can be negative, if you want to manually refill the bucket. If the change puts the bucket above or below zero, the bufferevents in the group will resume or suspend reading writing as appropriate.</p>
<p>Returns 0 on success, -1 on internal error. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5f603c05b36373b532db68aca645ed8"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_decrement_read" ref="aa5f603c05b36373b532db68aca645ed8" args="(struct bufferevent_rate_limit_group *, ev_ssize_t)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>bufferevent_rate_limit_group_decrement_read</b> (struct bufferevent_rate_limit_group *, ev_ssize_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec8e489e3c2705105d85064340018847"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_decrement_write" ref="aec8e489e3c2705105d85064340018847" args="(struct bufferevent_rate_limit_group *, ev_ssize_t)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>bufferevent_rate_limit_group_decrement_write</b> (struct bufferevent_rate_limit_group *, ev_ssize_t)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Group Rate limit inspection</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp587004889761fd1b2150560e50ac43d2"></a>Return the read or write bucket size for a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> rate limit group.</p>
<p>Note that it can return a negative value if bufferevents in the group have been made to read or write more than their limits. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa72d92d5179e24cd73a910fd353c927a"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_get_read_limit" ref="aa72d92d5179e24cd73a910fd353c927a" args="(struct bufferevent_rate_limit_group *)" -->
ev_ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>bufferevent_rate_limit_group_get_read_limit</b> (struct bufferevent_rate_limit_group *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1f35e47760c34deaf1baede3fd0425a"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_get_write_limit" ref="ad1f35e47760c34deaf1baede3fd0425a" args="(struct bufferevent_rate_limit_group *)" -->
ev_ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>bufferevent_rate_limit_group_get_write_limit</b> (struct bufferevent_rate_limit_group *)</td></tr>
<tr><td colspan="2"><h2>Filtering support</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpc7006df938bda2ca942f78aa63ae8cc0"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1">bufferevent_filter_result</a> { <a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1a794bf8211eaafdbeb382991dc5874e4d">BEV_OK</a> =  0, 
<a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1a78c4f864aee50d333d74e3b46e12b8a4">BEV_NEED_MORE</a> =  1, 
<a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1a4e51550811d3dad92400c27d69277032">BEV_ERROR</a> =  2
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Values that filters can return. </p>
 <a href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1">bufferevent_filter_result</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a4fade9aae0c515ff1848f395ae35e4c7">bufferevent_filter_cb</a> )(struct <a class="el" href="structevbuffer.html">evbuffer</a> *src, struct <a class="el" href="structevbuffer.html">evbuffer</a> *dst, ev_ssize_t dst_limit, enum <a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25">bufferevent_flush_mode</a> mode, void *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function to implement a filter for a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.  <a href="#a4fade9aae0c515ff1848f395ae35e4c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#ab6dea1351561f1866b0526fc1207bb69">bufferevent_filter_new</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *underlying, <a class="el" href="bufferevent_8h.html#a4fade9aae0c515ff1848f395ae35e4c7">bufferevent_filter_cb</a> input_filter, <a class="el" href="bufferevent_8h.html#a4fade9aae0c515ff1848f395ae35e4c7">bufferevent_filter_cb</a> output_filter, int options, void(*free_context)(void *), void *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new filtering <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> on top of an existing <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>.  <a href="#ab6dea1351561f1866b0526fc1207bb69"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Functions for buffering data for network sending or receiving. </p>
<p>Bufferevents are higher level than evbuffers: each has an underlying <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> for reading and one for writing, and callbacks that are invoked under certain circumstances.</p>
<p>A <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> provides input and output buffers that get filled and drained automatically. The user of a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> no longer deals directly with the I/O, but instead is reading from input and writing to output buffers.</p>
<p>Once initialized, the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> structure can be used repeatedly with <a class="el" href="bufferevent_8h.html#a1b9a3412e8c8e122c745b33d46b9643e" title="Enable a bufferevent.">bufferevent_enable()</a> and <a class="el" href="bufferevent_8h.html#aa15582fe250247aa98d4897527215727" title="Disable a bufferevent.">bufferevent_disable()</a>.</p>
<p>When reading is enabled, the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> will try to read from the file descriptor onto its input buffer, and and call the read callback. When writing is enabled, the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> will try to write data onto its file descriptor when writing is enabled, and call the write callback when the output buffer is sufficiently drained.</p>
<p>Bufferevents come in several flavors, including:</p>
<dl>
<dt>Socket-based bufferevents </dt>
<dd><p class="startdd">A <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> that reads and writes data onto a network socket. Created with <a class="el" href="bufferevent_8h.html#a501557193aa56c9f4923583d9d734395" title="Create a new socket bufferevent over an existing socket.">bufferevent_socket_new()</a>.</p>
<p class="enddd"></p>
</dd>
<dt>Paired bufferevents </dt>
<dd><p class="startdd">A pair of bufferevents that send and receive data to one another without touching the network. Created with <a class="el" href="bufferevent_8h.html#af8932010b0a590ddf9848026e8a99059" title="Allocate a pair of linked bufferevents.">bufferevent_pair_new()</a>.</p>
<p class="enddd"></p>
</dd>
<dt>Filtering bufferevents </dt>
<dd><p class="startdd">A <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> that transforms data, and sends or receives it over another underlying <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. Created with <a class="el" href="bufferevent_8h.html#ab6dea1351561f1866b0526fc1207bb69" title="Allocate a new filtering bufferevent on top of an existing bufferevent.">bufferevent_filter_new()</a>.</p>
<p class="enddd"></p>
</dd>
<dt>SSL-backed bufferevents </dt>
<dd>A <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> that uses the openssl library to send and receive data over an encrypted connection. Created with <a class="el" href="bufferevent__ssl_8h.html#a25bcf9f9edae71f2395c5207bfd922f2" title="Create a new SSL bufferevent to send its data over an SSL * on a socket.">bufferevent_openssl_socket_new()</a> or <a class="el" href="bufferevent__ssl_8h.html#ac3f28f95d0714dc30138cfa3d98b8edb" title="Create a new SSL bufferevent to send its data over another bufferevent.">bufferevent_openssl_filter_new()</a>. </dd>
</dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="affb7a7e5e21e1541ba6f43f950d92993"></a><!-- doxytag: member="bufferevent.h::BEV_EVENT_CONNECTED" ref="affb7a7e5e21e1541ba6f43f950d92993" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BEV_EVENT_CONNECTED&nbsp;&nbsp;&nbsp;0x80</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>connect operation finished. </p>

</div>
</div>
<a class="anchor" id="a78fc86349f408552be0fdf249db673ec"></a><!-- doxytag: member="bufferevent.h::EV_RATE_LIMIT_MAX" ref="a78fc86349f408552be0fdf249db673ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EV_RATE_LIMIT_MAX&nbsp;&nbsp;&nbsp;EV_SSIZE_MAX</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum configurable rate- or burst-limit. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a75e8fa059136e13c04c237e9c03cdbe8"></a><!-- doxytag: member="bufferevent.h::bufferevent_data_cb" ref="a75e8fa059136e13c04c237e9c03cdbe8" args=")(struct bufferevent *bev, void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="bufferevent_8h.html#a75e8fa059136e13c04c237e9c03cdbe8">bufferevent_data_cb</a>)(struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, void *ctx)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A read or write callback for a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<p>The read callback is triggered when new data arrives in the input buffer and the amount of readable data exceed the low watermark which is 0 by default.</p>
<p>The write callback is triggered if the write buffer has been exhausted or fell below its low watermark.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> that triggered the callback </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>the user-specified context for this <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79b5f4b983f8e67005416738c6494ac6"></a><!-- doxytag: member="bufferevent.h::bufferevent_event_cb" ref="a79b5f4b983f8e67005416738c6494ac6" args=")(struct bufferevent *bev, short what, void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="bufferevent_8h.html#a79b5f4b983f8e67005416738c6494ac6">bufferevent_event_cb</a>)(struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, short what, void *ctx)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An event/error callback for a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<p>The <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> callback is triggered if either an EOF condition or another unrecoverable error was encountered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> for which the error condition was reached </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>what</em>&nbsp;</td><td>a conjunction of flags: BEV_EVENT_READING or BEV_EVENT_WRITING to indicate if the error was encountered on the read or write path, and one of the following flags: BEV_EVENT_EOF, BEV_EVENT_ERROR, BEV_EVENT_TIMEOUT, BEV_EVENT_CONNECTED.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>the user-specified context for this <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a19e499f7bfa831b802fd3575d141b4e1"></a><!-- doxytag: member="bufferevent.h::bufferevent_filter_result" ref="a19e499f7bfa831b802fd3575d141b4e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1">bufferevent_filter_result</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Values that filters can return. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a19e499f7bfa831b802fd3575d141b4e1a794bf8211eaafdbeb382991dc5874e4d"></a><!-- doxytag: member="BEV_OK" ref="a19e499f7bfa831b802fd3575d141b4e1a794bf8211eaafdbeb382991dc5874e4d" args="" -->BEV_OK</em>&nbsp;</td><td>
<p>everything is okay </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a19e499f7bfa831b802fd3575d141b4e1a78c4f864aee50d333d74e3b46e12b8a4"></a><!-- doxytag: member="BEV_NEED_MORE" ref="a19e499f7bfa831b802fd3575d141b4e1a78c4f864aee50d333d74e3b46e12b8a4" args="" -->BEV_NEED_MORE</em>&nbsp;</td><td>
<p>the filter needs to read more data before output </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a19e499f7bfa831b802fd3575d141b4e1a4e51550811d3dad92400c27d69277032"></a><!-- doxytag: member="BEV_ERROR" ref="a19e499f7bfa831b802fd3575d141b4e1a4e51550811d3dad92400c27d69277032" args="" -->BEV_ERROR</em>&nbsp;</td><td>
<p>the filter encountered a critical error, no further data can be processed. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ac35edc760057a2e48b4e8ba9ecf2ad25"></a><!-- doxytag: member="bufferevent.h::bufferevent_flush_mode" ref="ac35edc760057a2e48b4e8ba9ecf2ad25" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25">bufferevent_flush_mode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flags that can be passed into filters to let them know how to deal with the incoming data. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac35edc760057a2e48b4e8ba9ecf2ad25a81903ce04ca68ac1680dd0b7a28a7fce"></a><!-- doxytag: member="BEV_NORMAL" ref="ac35edc760057a2e48b4e8ba9ecf2ad25a81903ce04ca68ac1680dd0b7a28a7fce" args="" -->BEV_NORMAL</em>&nbsp;</td><td>
<p>usually set when processing data </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac35edc760057a2e48b4e8ba9ecf2ad25a77e7f15a95815dcaaef27fdabb0e6164"></a><!-- doxytag: member="BEV_FLUSH" ref="ac35edc760057a2e48b4e8ba9ecf2ad25a77e7f15a95815dcaaef27fdabb0e6164" args="" -->BEV_FLUSH</em>&nbsp;</td><td>
<p>want to checkpoint all data sent. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac35edc760057a2e48b4e8ba9ecf2ad25acb248a91854bbebd773061df7f4bbc94"></a><!-- doxytag: member="BEV_FINISHED" ref="ac35edc760057a2e48b4e8ba9ecf2ad25acb248a91854bbebd773061df7f4bbc94" args="" -->BEV_FINISHED</em>&nbsp;</td><td>
<p>encountered EOF on read or done sending data </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4919449c62c6483e2d135509190dc65"></a><!-- doxytag: member="bufferevent.h::bufferevent_options" ref="aa4919449c62c6483e2d135509190dc65" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bufferevent_8h.html#aa4919449c62c6483e2d135509190dc65">bufferevent_options</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Options that can be specified when creating a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa4919449c62c6483e2d135509190dc65a5dc89d74ef445da33295d00c8f6adc90"></a><!-- doxytag: member="BEV_OPT_CLOSE_ON_FREE" ref="aa4919449c62c6483e2d135509190dc65a5dc89d74ef445da33295d00c8f6adc90" args="" -->BEV_OPT_CLOSE_ON_FREE</em>&nbsp;</td><td>
<p>If set, we close the underlying file descriptor/bufferevent/whatever when this <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> is freed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4919449c62c6483e2d135509190dc65adfb637881b739eff1441ad848a5e3a2d"></a><!-- doxytag: member="BEV_OPT_THREADSAFE" ref="aa4919449c62c6483e2d135509190dc65adfb637881b739eff1441ad848a5e3a2d" args="" -->BEV_OPT_THREADSAFE</em>&nbsp;</td><td>
<p>If set, and threading is enabled, operations on this <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> are protected by a lock. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4919449c62c6483e2d135509190dc65a2fbeb24d0156aa2492c23aaace73f1d3"></a><!-- doxytag: member="BEV_OPT_DEFER_CALLBACKS" ref="aa4919449c62c6483e2d135509190dc65a2fbeb24d0156aa2492c23aaace73f1d3" args="" -->BEV_OPT_DEFER_CALLBACKS</em>&nbsp;</td><td>
<p>If set, callbacks are run deferred in the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> loop. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4919449c62c6483e2d135509190dc65acb8ca6f6422fb8f9a748521cf8c4caf5"></a><!-- doxytag: member="BEV_OPT_UNLOCK_CALLBACKS" ref="aa4919449c62c6483e2d135509190dc65acb8ca6f6422fb8f9a748521cf8c4caf5" args="" -->BEV_OPT_UNLOCK_CALLBACKS</em>&nbsp;</td><td>
<p>If set, callbacks are executed without locks being held on the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<p>This option currently requires that BEV_OPT_DEFER_CALLBACKS also be set; a future version of Libevent might remove the requirement. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aadb00f5d5c054bb705db78db327ef261"></a><!-- doxytag: member="bufferevent.h::bufferevent_add_to_rate_limit_group" ref="aadb00f5d5c054bb705db78db327ef261" args="(struct bufferevent *bev, struct bufferevent_rate_limit_group *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_add_to_rate_limit_group </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bufferevent_rate_limit_group *&nbsp;</td>
          <td class="paramname"> <em>g</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add 'bev' to the list of bufferevents whose aggregate reading and writing is restricted by 'g'. </p>
<p>If 'g' is NULL, remove 'bev' from its current group.</p>
<p>A <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> may belong to no more than one rate-limit group at a time. If 'bev' is already a member of a group, it will be removed from its old group before being added to 'g'.</p>
<p>Return 0 on success and -1 on failure. </p>

</div>
</div>
<a class="anchor" id="a0697dabdb9b4057ae71b40a2f0e45fed"></a><!-- doxytag: member="bufferevent.h::bufferevent_base_set" ref="a0697dabdb9b4057ae71b40a2f0e45fed" args="(struct event_base *base, struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_base_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> to a specific <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a>. </p>
<p>NOTE that only socket bufferevents support this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>an <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> returned by <a class="el" href="event__compat_8h.html#a1bf74386dd3725e1538fed2d70c1c113" title="Initialize the event API.">event_init()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> struct returned by bufferevent_new() or <a class="el" href="bufferevent_8h.html#a501557193aa56c9f4923583d9d734395" title="Create a new socket bufferevent over an existing socket.">bufferevent_socket_new()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bufferevent_new() </dd></dl>

</div>
</div>
<a class="anchor" id="aa15582fe250247aa98d4897527215727"></a><!-- doxytag: member="bufferevent.h::bufferevent_disable" ref="aa15582fe250247aa98d4897527215727" args="(struct bufferevent *bufev, short event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_disable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> to be disabled </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structevent.html" title="Structure to represent a single event.">event</a></em>&nbsp;</td><td>any combination of EV_READ | EV_WRITE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bufferevent_8h.html#a1b9a3412e8c8e122c745b33d46b9643e" title="Enable a bufferevent.">bufferevent_enable()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1b9a3412e8c8e122c745b33d46b9643e"></a><!-- doxytag: member="bufferevent.h::bufferevent_enable" ref="a1b9a3412e8c8e122c745b33d46b9643e" args="(struct bufferevent *bufev, short event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_enable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> to be enabled </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structevent.html" title="Structure to represent a single event.">event</a></em>&nbsp;</td><td>any combination of EV_READ | EV_WRITE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bufferevent_8h.html#aa15582fe250247aa98d4897527215727" title="Disable a bufferevent.">bufferevent_disable()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab6dea1351561f1866b0526fc1207bb69"></a><!-- doxytag: member="bufferevent.h::bufferevent_filter_new" ref="ab6dea1351561f1866b0526fc1207bb69" args="(struct bufferevent *underlying, bufferevent_filter_cb input_filter, bufferevent_filter_cb output_filter, int options, void(*free_context)(void *), void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbufferevent.html">bufferevent</a>* bufferevent_filter_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>underlying</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bufferevent_8h.html#a4fade9aae0c515ff1848f395ae35e4c7">bufferevent_filter_cb</a>&nbsp;</td>
          <td class="paramname"> <em>input_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bufferevent_8h.html#a4fade9aae0c515ff1848f395ae35e4c7">bufferevent_filter_cb</a>&nbsp;</td>
          <td class="paramname"> <em>output_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>free_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a new filtering <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> on top of an existing <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>underlying</em>&nbsp;</td><td>the underlying <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_filter</em>&nbsp;</td><td>The filter to apply to data we read from the underlying <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output_filter</em>&nbsp;</td><td>The filer to apply to data we write to the underlying <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>A bitfield of <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> options. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_context</em>&nbsp;</td><td>A function to use to free the filter context when this <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> is freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>A context pointer to pass to the filter functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03376a35668ff9b6dc905cce0d89876d"></a><!-- doxytag: member="bufferevent.h::bufferevent_flush" ref="a03376a35668ff9b6dc905cce0d89876d" args="(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_flush </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>iotype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25">bufferevent_flush_mode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Triggers the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> to produce more data if possible. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iotype</em>&nbsp;</td><td>either EV_READ or EV_WRITE or both. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>either BEV_NORMAL or BEV_FLUSH or BEV_FINISHED </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 on failure, 0 if no data was produces, 1 if data was produced </dd></dl>

</div>
</div>
<a class="anchor" id="a474a4cef8fd80bea09a636b5f3055bec"></a><!-- doxytag: member="bufferevent.h::bufferevent_free" ref="a474a4cef8fd80bea09a636b5f3055bec" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufferevent_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate the storage associated with a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> structure. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> structure to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbb4adabeb188cc9000bdee4ba23bdb2"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_enabled" ref="afbb4adabeb188cc9000bdee4ba23bdb2" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short bufferevent_get_enabled </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the events that are enabled on a given <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A combination of EV_READ | EV_WRITE </dd></dl>

</div>
</div>
<a class="anchor" id="a7bc716ede3a5fc1e9107ae522e545e0c"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_input" ref="a7bc716ede3a5fc1e9107ae522e545e0c" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevbuffer.html">evbuffer</a>* bufferevent_get_input </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the input buffer. </p>
<p>The user MUST NOT set the callback on this buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> from which to get the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> object for the input buffer </dd></dl>

</div>
</div>
<a class="anchor" id="af3dea057c5a276461dd94a1601682be1"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_output" ref="af3dea057c5a276461dd94a1601682be1" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevbuffer.html">evbuffer</a>* bufferevent_get_output </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the output buffer. </p>
<p>The user MUST NOT set the callback on this buffer.</p>
<p>When filters are being used, the filters need to be manually triggered if the output buffer was manipulated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> from which to get the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> object for the output buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a56a61802037478591048b4967fa15599"></a><!-- doxytag: member="bufferevent.h::bufferevent_lock" ref="a56a61802037478591048b4967fa15599" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufferevent_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Acquire the lock on a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<p>Has no effect if locking was not enabled with BEV_OPT_THREADSAFE. </p>

</div>
</div>
<a class="anchor" id="a3ebd2a56a2ef87106bf76630eb0926b6"></a><!-- doxytag: member="bufferevent.h::bufferevent_pair_get_partner" ref="a3ebd2a56a2ef87106bf76630eb0926b6" args="(struct bufferevent *bev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbufferevent.html">bufferevent</a>* bufferevent_pair_get_partner </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given one <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> returned by <a class="el" href="bufferevent_8h.html#af8932010b0a590ddf9848026e8a99059" title="Allocate a pair of linked bufferevents.">bufferevent_pair_new()</a>, returns the other one if it still exists. </p>
<p>Otherwise returns NULL. </p>

</div>
</div>
<a class="anchor" id="af8932010b0a590ddf9848026e8a99059"></a><!-- doxytag: member="bufferevent.h::bufferevent_pair_new" ref="af8932010b0a590ddf9848026e8a99059" args="(struct event_base *base, int options, struct bufferevent *pair[2])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_pair_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>pair</em>[2]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a pair of linked bufferevents. </p>
<p>The bufferevents behave as would two bufferevent_sock instances connected to opposite ends of a socketpair(), except that no internal socketpair is allocated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>The <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base to associate with the socketpair. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>A set of options for this <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pair</em>&nbsp;</td><td>A pointer to an array to hold the two new <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a73e1daaa7c4d52c95b16c9944fa62e90"></a><!-- doxytag: member="bufferevent.h::bufferevent_priority_set" ref="a73e1daaa7c4d52c95b16c9944fa62e90" args="(struct bufferevent *bufev, int pri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_priority_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a priority to a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<p>Only supported for socket bufferevents.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> struct </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pri</em>&nbsp;</td><td>the priority to be assigned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="adf4304c0c47fedb8122700ce1f0def8b"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_free" ref="adf4304c0c47fedb8122700ce1f0def8b" args="(struct bufferevent_rate_limit_group *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufferevent_rate_limit_group_free </td>
          <td>(</td>
          <td class="paramtype">struct bufferevent_rate_limit_group *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a rate-limiting group. </p>
<p>The group must have no members when this function is called. </p>

</div>
</div>
<a class="anchor" id="a4fec52eebbe5f925dfc2eaa60100124d"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_get_totals" ref="a4fec52eebbe5f925dfc2eaa60100124d" args="(struct bufferevent_rate_limit_group *grp, ev_uint64_t *total_read_out, ev_uint64_t *total_written_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufferevent_rate_limit_group_get_totals </td>
          <td>(</td>
          <td class="paramtype">struct bufferevent_rate_limit_group *&nbsp;</td>
          <td class="paramname"> <em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint64_t *&nbsp;</td>
          <td class="paramname"> <em>total_read_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint64_t *&nbsp;</td>
          <td class="paramname"> <em>total_written_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inspect the total bytes read/written on a group. </p>
<p>Set the variable pointed to by total_read_out to the total number of bytes ever read on grp, and the variable pointed to by total_written_out to the total number of bytes ever written on grp. </p>

</div>
</div>
<a class="anchor" id="acf75d7e04a54e7fe4543f7efd596e7f7"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_new" ref="acf75d7e04a54e7fe4543f7efd596e7f7" args="(struct event_base *base, const struct ev_token_bucket_cfg *cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bufferevent_rate_limit_group* bufferevent_rate_limit_group_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct ev_token_bucket_cfg *&nbsp;</td>
          <td class="paramname"> <em>cfg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new rate-limit group for bufferevents. </p>
<p>A rate-limit group constrains the maximum number of bytes sent and received, in toto, by all of its bufferevents.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>An <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> to run any necessary timeouts for the group. Note that all bufferevents in the group do not necessarily need to share this <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cfg</em>&nbsp;</td><td>The rate-limit for this group.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that all rate-limits hare are currently best-effort: future versions of Libevent may implement them more tightly.</p>
<p>Note also that only some <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> types currently respect rate-limiting. They are: socket-based bufferevents (normal and IOCP-based), and SSL-based bufferevents. </p>

</div>
</div>
<a class="anchor" id="a38c81c84dc02318bd34f41d84f468a98"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_reset_totals" ref="a38c81c84dc02318bd34f41d84f468a98" args="(struct bufferevent_rate_limit_group *grp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufferevent_rate_limit_group_reset_totals </td>
          <td>(</td>
          <td class="paramtype">struct bufferevent_rate_limit_group *&nbsp;</td>
          <td class="paramname"> <em>grp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the total bytes read/written on a group. </p>
<p>Reset the number of bytes read or written on grp as given by <a class="el" href="bufferevent_8h.html#a38c81c84dc02318bd34f41d84f468a98" title="Reset the total bytes read/written on a group.">bufferevent_rate_limit_group_reset_totals()</a>. </p>

</div>
</div>
<a class="anchor" id="a9b766efb61af2cb92d24f6e4caa38a53"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_set_cfg" ref="a9b766efb61af2cb92d24f6e4caa38a53" args="(struct bufferevent_rate_limit_group *, const struct ev_token_bucket_cfg *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_rate_limit_group_set_cfg </td>
          <td>(</td>
          <td class="paramtype">struct bufferevent_rate_limit_group *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct ev_token_bucket_cfg *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the rate-limiting settings for a given rate-limiting group. </p>
<p>Return 0 on success, -1 on failure. </p>

</div>
</div>
<a class="anchor" id="aa2499cfb56976dcf3c6b846801043214"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_set_min_share" ref="aa2499cfb56976dcf3c6b846801043214" args="(struct bufferevent_rate_limit_group *, size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_rate_limit_group_set_min_share </td>
          <td>(</td>
          <td class="paramtype">struct bufferevent_rate_limit_group *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the smallest quantum we're willing to allocate to any single <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> in a group for reading or writing at a time. </p>
<p>The rationale is that, because of TCP/IP protocol overheads and kernel behavior, if a rate-limiting group is so tight on bandwidth that you're only willing to send 1 byte per tick per <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>, you might instead want to batch up the reads and writes so that you send N bytes per 1/N of the bufferevents (chosen at random) each tick, so you still wind up send 1 byte per tick per <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> on average, but you don't send so many tiny packets.</p>
<p>The default min-share is currently 64 bytes.</p>
<p>Returns 0 on success, -1 on faulre. </p>

</div>
</div>
<a class="anchor" id="a6bd435529e20a39b24fead9ddcd966ba"></a><!-- doxytag: member="bufferevent.h::bufferevent_read" ref="a6bd435529e20a39b24fead9ddcd966ba" args="(struct bufferevent *bufev, void *data, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t bufferevent_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> buffer. </p>
<p>The <a class="el" href="bufferevent_8h.html#a6bd435529e20a39b24fead9ddcd966ba" title="Read data from a bufferevent buffer.">bufferevent_read()</a> function is used to read data from the input buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> to be read from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>pointer to a buffer that will store the data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the data buffer, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the amount of data read, in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2246fd48085c1acc9e98747a83af041"></a><!-- doxytag: member="bufferevent.h::bufferevent_read_buffer" ref="ab2246fd48085c1acc9e98747a83af041" args="(struct bufferevent *bufev, struct evbuffer *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_read_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> buffer into an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a>. </p>
<p>This avoids memory copies.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> to be read from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to which to add data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="abdbf64b4203fe6b65b263661ef18c6f2"></a><!-- doxytag: member="bufferevent.h::bufferevent_remove_from_rate_limit_group" ref="abdbf64b4203fe6b65b263661ef18c6f2" args="(struct bufferevent *bev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_remove_from_rate_limit_group </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove 'bev' from its current rate-limit group (if any). </p>

</div>
</div>
<a class="anchor" id="aeb7bc9d8af4dd74b3de8dcd2941e6e02"></a><!-- doxytag: member="bufferevent.h::bufferevent_set_rate_limit" ref="aeb7bc9d8af4dd74b3de8dcd2941e6e02" args="(struct bufferevent *bev, struct ev_token_bucket_cfg *cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_set_rate_limit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ev_token_bucket_cfg *&nbsp;</td>
          <td class="paramname"> <em>cfg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the rate-limit of a the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> 'bev' to the one specified in 'cfg'. </p>
<p>If 'cfg' is NULL, disable any per-bufferevent rate-limiting on 'bev'.</p>
<p>Note that only some <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> types currently respect rate-limiting. They are: socket-based bufferevents (normal and IOCP-based), and SSL-based bufferevents.</p>
<p>Return 0 on sucess, -1 on failure. </p>

</div>
</div>
<a class="anchor" id="a3686d744e67e9a530ebf8ab888ade2cf"></a><!-- doxytag: member="bufferevent.h::bufferevent_set_timeouts" ref="a3686d744e67e9a530ebf8ab888ade2cf" args="(struct bufferevent *bufev, const struct timeval *timeout_read, const struct timeval *timeout_write)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_set_timeouts </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&nbsp;</td>
          <td class="paramname"> <em>timeout_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&nbsp;</td>
          <td class="paramname"> <em>timeout_write</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the read and write timeout for a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<p>A bufferevent's timeout will fire the first time that the indicated amount of time has elapsed since a successful read or write operation, during which the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> was trying to read or write.</p>
<p>(In other words, if reading or writing is disabled, or if the bufferevent's read or write operation has been suspended because there's no data to write, or not enough banwidth, or so on, the timeout isn't active. The timeout only becomes active when we we're willing to actually read or write.)</p>
<p>Calling bufferevent_enable or setting a timeout for a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> whose timeout is already pending resets its timeout.</p>
<p>If the timeout elapses, the corresponding operation (EV_READ or EV_WRITE) becomes disabled until you re-enable it again. The bufferevent's <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> callback is called with the BEV_EVENT_TIMEOUT|BEV_EVENT_READING or BEV_EVENT_TIMEOUT|BEV_EVENT_WRITING.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> to be modified </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_read</em>&nbsp;</td><td>the read timeout, or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_write</em>&nbsp;</td><td>the write timeout, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63792519cb94a38beccb5e1390cd6198"></a><!-- doxytag: member="bufferevent.h::bufferevent_setcb" ref="a63792519cb94a38beccb5e1390cd6198" args="(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, void *cbarg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufferevent_setcb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bufferevent_8h.html#a75e8fa059136e13c04c237e9c03cdbe8">bufferevent_data_cb</a>&nbsp;</td>
          <td class="paramname"> <em>readcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bufferevent_8h.html#a75e8fa059136e13c04c237e9c03cdbe8">bufferevent_data_cb</a>&nbsp;</td>
          <td class="paramname"> <em>writecb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bufferevent_8h.html#a79b5f4b983f8e67005416738c6494ac6">bufferevent_event_cb</a>&nbsp;</td>
          <td class="paramname"> <em>eventcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cbarg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the callbacks for a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> object for which to change callbacks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readcb</em>&nbsp;</td><td>callback to invoke when there is data to be read, or NULL if no callback is desired </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>writecb</em>&nbsp;</td><td>callback to invoke when the file descriptor is ready for writing, or NULL if no callback is desired </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eventcb</em>&nbsp;</td><td>callback to invoke when there is an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> on the file descriptor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbarg</em>&nbsp;</td><td>an argument that will be supplied to each of the callbacks (readcb, writecb, and errorcb) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bufferevent_new() </dd></dl>

</div>
</div>
<a class="anchor" id="a0a367e404942c11265bfcd0b693aa120"></a><!-- doxytag: member="bufferevent.h::bufferevent_setfd" ref="a0a367e404942c11265bfcd0b693aa120" args="(struct bufferevent *bufev, evutil_socket_t fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_setfd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname"> <em>fd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the file descriptor on which the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> operates. </p>
<p>Not supported for all <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> types.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> object for which to change the file descriptor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>the file descriptor to operate on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74e3835e99f8eb73bb1cd7afa7427049"></a><!-- doxytag: member="bufferevent.h::bufferevent_setwatermark" ref="a74e3835e99f8eb73bb1cd7afa7427049" args="(struct bufferevent *bufev, short events, size_t lowmark, size_t highmark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufferevent_setwatermark </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>lowmark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>highmark</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the watermarks for read and write events. </p>
<p>On input, a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> does not invoke the user read callback unless there is at least low watermark data in the buffer. If the read buffer is beyond the high watermark, the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> stops reading from the network.</p>
<p>On output, the user write callback is invoked whenever the buffered data falls below the low watermark. Filters that write to this bufev will try not to write more bytes to this buffer than the high watermark would allow, except when flushing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> to be modified </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>EV_READ, EV_WRITE or both </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lowmark</em>&nbsp;</td><td>the lower watermark to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>highmark</em>&nbsp;</td><td>the high watermark to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2ecbb906883ea848f7bca767d479a2a"></a><!-- doxytag: member="bufferevent.h::bufferevent_socket_connect" ref="ac2ecbb906883ea848f7bca767d479a2a" args="(struct bufferevent *, struct sockaddr *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_socket_connect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Launch a connect() attempt with a socket-based <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<p>When the connect succeeds, the eventcb will be invoked with BEV_EVENT_CONNECTED set.</p>
<p>If the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> does not already have a socket set, we allocate a new socket here and make it nonblocking before we begin.</p>
<p>If no address is provided, we assume that the socket is already connecting, and configure the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> so that a BEV_EVENT_CONNECTED <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> will be yielded when it is done connecting.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>an existing <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> allocated with <a class="el" href="bufferevent_8h.html#a501557193aa56c9f4923583d9d734395" title="Create a new socket bufferevent over an existing socket.">bufferevent_socket_new()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>the address we should connect to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>socklen</em>&nbsp;</td><td>The length of the address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a797686b522045aefb217c6b87ea7ae4a"></a><!-- doxytag: member="bufferevent.h::bufferevent_socket_connect_hostname" ref="a797686b522045aefb217c6b87ea7ae4a" args="(struct bufferevent *, struct evdns_base *, int, const char *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_socket_connect_hostname </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct evdns_base *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resolve the hostname 'hostname' and connect to it as with <a class="el" href="bufferevent_8h.html#ac2ecbb906883ea848f7bca767d479a2a" title="Launch a connect() attempt with a socket-based bufferevent.">bufferevent_socket_connect()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>An existing <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> allocated with <a class="el" href="bufferevent_8h.html#a501557193aa56c9f4923583d9d734395" title="Create a new socket bufferevent over an existing socket.">bufferevent_socket_new()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evdns_base</em>&nbsp;</td><td>Optionally, an evdns_base to use for resolving hostnames asynchronously. May be set to NULL for a blocking resolve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>family</em>&nbsp;</td><td>A preferred address family to resolve addresses to, or AF_UNSPEC for no preference. Only AF_INET, AF_INET6, and AF_UNSPEC are supported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hostname</em>&nbsp;</td><td>The hostname to resolve; see below for notes on recognized formats </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port to connect to on the resolved address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 on failure.</dd></dl>
<p>Recognized hostname formats are:</p>
<p>www.example.com (hostname) 1.2.3.4 (ipv4address) ::1 (ipv6address) [::1] ([ipv6address])</p>
<p>Performance note: If you do not provide an evdns_base, this function may block while it waits for a DNS response. This is probably not what you want. </p>

</div>
</div>
<a class="anchor" id="a9a66b02bce652cdbcc7d26636ce26d67"></a><!-- doxytag: member="bufferevent.h::bufferevent_socket_get_dns_error" ref="a9a66b02bce652cdbcc7d26636ce26d67" args="(struct bufferevent *bev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_socket_get_dns_error </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the error code for the last failed DNS lookup attempt made by <a class="el" href="bufferevent_8h.html#a797686b522045aefb217c6b87ea7ae4a" title="Resolve the hostname &#39;hostname&#39; and connect to it as with bufferevent_socket_connect()...">bufferevent_socket_connect_hostname()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bev</em>&nbsp;</td><td>The <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>DNS error code. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>evutil_gai_strerror() </dd></dl>

</div>
</div>
<a class="anchor" id="a501557193aa56c9f4923583d9d734395"></a><!-- doxytag: member="bufferevent.h::bufferevent_socket_new" ref="a501557193aa56c9f4923583d9d734395" args="(struct event_base *base, evutil_socket_t fd, int options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbufferevent.html">bufferevent</a>* bufferevent_socket_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new socket <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> over an existing socket. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base to associate with the new <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>the file descriptor from which data is read and written to. This file descriptor is not allowed to be a pipe(2). It is safe to set the fd to -1, so long as you later set it with bufferevent_setfd or <a class="el" href="bufferevent_8h.html#ac2ecbb906883ea848f7bca767d479a2a" title="Launch a connect() attempt with a socket-based bufferevent.">bufferevent_socket_connect()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Zero or more BEV_OPT_* flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to a newly allocated <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> struct, or NULL if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bufferevent_8h.html#a474a4cef8fd80bea09a636b5f3055bec" title="Deallocate the storage associated with a bufferevent structure.">bufferevent_free()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a53fd135567d95cab72b8bad473c97510"></a><!-- doxytag: member="bufferevent.h::bufferevent_unlock" ref="a53fd135567d95cab72b8bad473c97510" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufferevent_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the lock on a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<p>Has no effect if locking was not enabled with BEV_OPT_THREADSAFE. </p>

</div>
</div>
<a class="anchor" id="abc606695cd6bb2e3f25c4330d0c9e3ab"></a><!-- doxytag: member="bufferevent.h::bufferevent_write" ref="abc606695cd6bb2e3f25c4330d0c9e3ab" args="(struct bufferevent *bufev, const void *data, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data to a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> buffer. </p>
<p>The <a class="el" href="bufferevent_8h.html#abc606695cd6bb2e3f25c4330d0c9e3ab" title="Write data to a bufferevent buffer.">bufferevent_write()</a> function can be used to write data to the file descriptor. The data is appended to the output buffer and written to the descriptor automatically as it becomes available for writing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> to be written to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>a pointer to the data to be written </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the length of the data, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bufferevent_8h.html#a3b140a32a4d16c402433130dc8c3bde4" title="Write data from an evbuffer to a bufferevent buffer.">bufferevent_write_buffer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3b140a32a4d16c402433130dc8c3bde4"></a><!-- doxytag: member="bufferevent.h::bufferevent_write_buffer" ref="a3b140a32a4d16c402433130dc8c3bde4" args="(struct bufferevent *bufev, struct evbuffer *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_write_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&nbsp;</td>
          <td class="paramname"> <em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data from an <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> buffer. </p>
<p>The <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> is being drained as a result.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bufev</em>&nbsp;</td><td>the <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> to be written to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bufferevent_8h.html#abc606695cd6bb2e3f25c4330d0c9e3ab" title="Write data to a bufferevent buffer.">bufferevent_write()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad918ea1e7f7967e5db895c7dde5b78ae"></a><!-- doxytag: member="bufferevent.h::ev_token_bucket_cfg_free" ref="ad918ea1e7f7967e5db895c7dde5b78ae" args="(struct ev_token_bucket_cfg *cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ev_token_bucket_cfg_free </td>
          <td>(</td>
          <td class="paramtype">struct ev_token_bucket_cfg *&nbsp;</td>
          <td class="paramname"> <em>cfg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free all storage held in 'cfg'. </p>
<p>Note: 'cfg' is not currently reference-counted; it is not safe to free it until no <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a> is using it. </p>

</div>
</div>
<a class="anchor" id="a60dd9d6469537b9099d2f6299c114ae6"></a><!-- doxytag: member="bufferevent.h::ev_token_bucket_cfg_new" ref="a60dd9d6469537b9099d2f6299c114ae6" args="(size_t read_rate, size_t read_burst, size_t write_rate, size_t write_burst, const struct timeval *tick_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ev_token_bucket_cfg* ev_token_bucket_cfg_new </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>read_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>read_burst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>write_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>write_burst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&nbsp;</td>
          <td class="paramname"> <em>tick_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize and return a new object to configure the rate-limiting behavior of bufferevents. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>read_rate</em>&nbsp;</td><td>The maximum number of bytes to read per tick on average. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>read_burst</em>&nbsp;</td><td>The maximum number of bytes to read in any single tick. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>write_rate</em>&nbsp;</td><td>The maximum number of bytes to write per tick on average. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>write_burst</em>&nbsp;</td><td>The maximum number of bytes to write in any single tick. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tick_len</em>&nbsp;</td><td>The length of a single tick. Defaults to one second. Any fractions of a millisecond are ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that all rate-limits hare are currently best-effort: future versions of Libevent may implement them more tightly. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a4fade9aae0c515ff1848f395ae35e4c7"></a><!-- doxytag: member="bufferevent.h::bufferevent_filter_cb" ref="a4fade9aae0c515ff1848f395ae35e4c7" args=")(struct evbuffer *src, struct evbuffer *dst, ev_ssize_t dst_limit, enum bufferevent_flush_mode mode, void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1">bufferevent_filter_result</a>(* <a class="el" href="bufferevent_8h.html#a4fade9aae0c515ff1848f395ae35e4c7">bufferevent_filter_cb</a>)(struct <a class="el" href="structevbuffer.html">evbuffer</a> *src, struct <a class="el" href="structevbuffer.html">evbuffer</a> *dst, ev_ssize_t dst_limit, enum <a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25">bufferevent_flush_mode</a> mode, void *ctx)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function to implement a filter for a <a class="el" href="structbufferevent.html" title="An opaque type for handling buffered IO.">bufferevent</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>An <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to drain data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>An <a class="el" href="structevbuffer.html" title="An evbuffer is an opaque data type for efficiently buffering data to be sent or received...">evbuffer</a> to add data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>A suggested upper bound of bytes to write to dst. The filter may ignore this value, but doing so means that it will overflow the high-water mark associated with dst. -1 means "no limit". </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Whether we should write data as may be convenient (BEV_NORMAL), or flush as much data as we can (BEV_FLUSH), or flush as much as we can, possibly including an end-of-stream marker (BEV_FINISH). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>A user-supplied pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>BEV_OK if we wrote some data; BEV_NEED_MORE if we can't produce any more output until we get some input; and BEV_ERROR on an error. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 17 Mar 2015 for libevent by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
