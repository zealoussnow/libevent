<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libevent: event2/event.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>event2/event.h File Reference</h1>
<p>Core functions for waiting for and receiving events, and using <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> bases.  
<a href="#_details">More...</a></p>
<code>#include &lt;event2/event-config.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="util_8h_source.html">event2/util.h</a>&gt;</code><br/>

<p><a href="event_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent.html">event</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure to represent a single <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>.  <a href="structevent.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent__base.html">event_base</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure to hold information and state for a Libevent dispatch loop.  <a href="structevent__base.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent__config.html">event_config</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configuration for an <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a>.  <a href="structevent__config.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a964443418439acdd775129ae260b21bb"></a><!-- doxytag: member="event.h::_EVENT_LOG_DEBUG" ref="a964443418439acdd775129ae260b21bb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>_EVENT_LOG_DEBUG</b>&nbsp;&nbsp;&nbsp;EVENT_LOG_DEBUG</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a829eede32e73952922a35e42b510bfe9"></a><!-- doxytag: member="event.h::_EVENT_LOG_ERR" ref="a829eede32e73952922a35e42b510bfe9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>_EVENT_LOG_ERR</b>&nbsp;&nbsp;&nbsp;EVENT_LOG_ERR</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d898badc07a518c29ecb0129cc77188"></a><!-- doxytag: member="event.h::_EVENT_LOG_MSG" ref="a6d898badc07a518c29ecb0129cc77188" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>_EVENT_LOG_MSG</b>&nbsp;&nbsp;&nbsp;EVENT_LOG_MSG</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8ba4ffdc827c139311654c41cfddd1d"></a><!-- doxytag: member="event.h::_EVENT_LOG_WARN" ref="aa8ba4ffdc827c139311654c41cfddd1d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>_EVENT_LOG_WARN</b>&nbsp;&nbsp;&nbsp;EVENT_LOG_WARN</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69cc368a9137187726ef371a06f9cc9f"></a><!-- doxytag: member="event.h::event_get_signal" ref="a69cc368a9137187726ef371a06f9cc9f" args="(ev)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a69cc368a9137187726ef371a06f9cc9f">event_get_signal</a>(ev)&nbsp;&nbsp;&nbsp;((int)event_get_fd(ev))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the signal number assigned to a signal <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ad74f7bf73ff985bfaf61c462cbba022f">EVENT_MAX_PRIORITIES</a>&nbsp;&nbsp;&nbsp;256</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Largest number of priorities that Libevent can support.  <a href="#ad74f7bf73ff985bfaf61c462cbba022f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade387a9a39bbbdf40ff20b4d977ec6ae"></a><!-- doxytag: member="event.h::EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED" ref="ade387a9a39bbbdf40ff20b4d977ec6ae" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ade387a9a39bbbdf40ff20b4d977ec6ae">EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This definition is present if Libevent was built with support for <a class="el" href="event_8h.html#a653e38c4bdd2f3b2d7476fcee95c1a62" title="Override the functions that Libevent uses for memory management.">event_set_mem_functions()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#aad00c7d4ddbd6b590c15861a2e767182">LIBEVENT_VERSION</a>&nbsp;&nbsp;&nbsp;_EVENT_VERSION</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As event_get_version, but gives the version of Libevent's headers.  <a href="#aad00c7d4ddbd6b590c15861a2e767182"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a8a9c8021651a2d8d7946083281279586">LIBEVENT_VERSION_NUMBER</a>&nbsp;&nbsp;&nbsp;_EVENT_NUMERIC_VERSION</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As event_get_version_number, but gives the version number of Libevent's headers.  <a href="#a8a9c8021651a2d8d7946083281279586"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">event flags</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpde9246336010eeb4473c42264734a30b"></a>Flags to pass to <a class="el" href="event_8h.html#ab9a66f828d205eda84b321e32014cbbd" title="Allocate and asssign a new event structure, ready to be added.">event_new()</a>, <a class="el" href="event_8h.html#afade5e4859dee5b85d502e5594a05cf0" title="Prepare a new, already-allocated event structure to be added.">event_assign()</a>, <a class="el" href="event_8h.html#a49773a4e3e46f60e488ac37fb46950d9" title="Checks if a specific event is pending or scheduled.">event_pending()</a>, and anything else with an argument of the form "short events" </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a01084abbcdd3a58b4068359548a3ea71">EV_ET</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select edge-triggered behavior, if supported by the backend.  <a href="#a01084abbcdd3a58b4068359548a3ea71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a3c4947a60eb6d09327c61f89135f9f37">EV_PERSIST</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Persistent <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>: won't get removed automatically when activated.  <a href="#a3c4947a60eb6d09327c61f89135f9f37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74bbaf2d529670cc0ab793497b41700f"></a><!-- doxytag: member="event.h::EV_READ" ref="a74bbaf2d529670cc0ab793497b41700f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a74bbaf2d529670cc0ab793497b41700f">EV_READ</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a socket or FD to become readable. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59b7e95284ac1a197969d42ee9441ece"></a><!-- doxytag: member="event.h::EV_SIGNAL" ref="a59b7e95284ac1a197969d42ee9441ece" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a59b7e95284ac1a197969d42ee9441ece">EV_SIGNAL</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a POSIX signal to be raised. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a37ef4b6056484f5580f7d72fcf46fccf">EV_TIMEOUT</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates that a timeout has occurred.  <a href="#a37ef4b6056484f5580f7d72fcf46fccf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a31813fa3b26bf2d150512cbbf893f7"></a><!-- doxytag: member="event.h::EV_WRITE" ref="a2a31813fa3b26bf2d150512cbbf893f7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a2a31813fa3b26bf2d150512cbbf893f7">EV_WRITE</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a socket or FD to become writeable. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Log severities</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp51b7f7ab2a43043abfe09ca9d4e9a04b"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6904203c125cd86cdd4f3cd90ef1c18f"></a><!-- doxytag: member="event.h::EVENT_LOG_DEBUG" ref="a6904203c125cd86cdd4f3cd90ef1c18f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVENT_LOG_DEBUG</b>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab51b4412fec9223efc5e5fa862b57a11"></a><!-- doxytag: member="event.h::EVENT_LOG_ERR" ref="ab51b4412fec9223efc5e5fa862b57a11" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVENT_LOG_ERR</b>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae18003965fc4df307a68d4f5bde2ec45"></a><!-- doxytag: member="event.h::EVENT_LOG_MSG" ref="ae18003965fc4df307a68d4f5bde2ec45" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVENT_LOG_MSG</b>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a795675e9eb8d63782e86260f101ae72d"></a><!-- doxytag: member="event.h::EVENT_LOG_WARN" ref="a795675e9eb8d63782e86260f101ae72d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVENT_LOG_WARN</b>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td colspan="2"><div class="groupHeader">Loop flags</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp56eaefab5ca78281f20c27e50b0a4d9f"></a>These flags control the behavior of <a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80" title="Wait for events to become active, and run their callbacks.">event_base_loop()</a>. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a10b9c102337d0ece8607c9c01bc4f7c8">EVLOOP_NONBLOCK</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do not block: see which events are ready now, run the callbacks of the highest-priority ones, then exit.  <a href="#a10b9c102337d0ece8607c9c01bc4f7c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#afab575b1e867dde13a2c7f2f967e0e4e">EVLOOP_ONCE</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block until we have an active <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>, then exit once all active events have had their callbacks run.  <a href="#afab575b1e867dde13a2c7f2f967e0e4e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">evsignal_* macros</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp94dd7a221cb4a4b856db63c63f8eeffd"></a>Aliases for working with signal events </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a043e61907ad2ae55d61f5c5e109729dd"></a><!-- doxytag: member="event.h::evsignal_add" ref="a043e61907ad2ae55d61f5c5e109729dd" args="(ev, tv)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evsignal_add</b>(ev, tv)&nbsp;&nbsp;&nbsp;event_add((ev), (tv))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08eae4d05e8e104b1d72bb73eaf95da4"></a><!-- doxytag: member="event.h::evsignal_assign" ref="a08eae4d05e8e104b1d72bb73eaf95da4" args="(ev, b, x, cb, arg)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evsignal_assign</b>(ev, b, x, cb, arg)&nbsp;&nbsp;&nbsp;event_assign((ev), (b), (x), EV_SIGNAL|EV_PERSIST, cb, (arg))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2cca0259e62d40d8470e9b574568f74"></a><!-- doxytag: member="event.h::evsignal_del" ref="af2cca0259e62d40d8470e9b574568f74" args="(ev)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evsignal_del</b>(ev)&nbsp;&nbsp;&nbsp;event_del(ev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa39848850017245c2e946c49c5a51a9d"></a><!-- doxytag: member="event.h::evsignal_initialized" ref="aa39848850017245c2e946c49c5a51a9d" args="(ev)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evsignal_initialized</b>(ev)&nbsp;&nbsp;&nbsp;event_initialized(ev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a990ce36ac02fb1033a0cc56df968b4c4"></a><!-- doxytag: member="event.h::evsignal_new" ref="a990ce36ac02fb1033a0cc56df968b4c4" args="(b, x, cb, arg)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evsignal_new</b>(b, x, cb, arg)&nbsp;&nbsp;&nbsp;event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee9bcb501fce2f2b7d5bc19e5d53b611"></a><!-- doxytag: member="event.h::evsignal_pending" ref="aee9bcb501fce2f2b7d5bc19e5d53b611" args="(ev, tv)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evsignal_pending</b>(ev, tv)&nbsp;&nbsp;&nbsp;event_pending((ev), EV_SIGNAL, (tv))</td></tr>
<tr><td colspan="2"><div class="groupHeader">evtimer_* macros</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp75586550de2fe1f75e1c054e20d695a7"></a>Aliases for working with one-shot timer events </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ea3ca87057c66fd9f5a9fda9b911f8b"></a><!-- doxytag: member="event.h::evtimer_add" ref="a6ea3ca87057c66fd9f5a9fda9b911f8b" args="(ev, tv)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evtimer_add</b>(ev, tv)&nbsp;&nbsp;&nbsp;event_add((ev), (tv))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a356b4550edd470440efa7a74da413939"></a><!-- doxytag: member="event.h::evtimer_assign" ref="a356b4550edd470440efa7a74da413939" args="(ev, b, cb, arg)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evtimer_assign</b>(ev, b, cb, arg)&nbsp;&nbsp;&nbsp;event_assign((ev), (b), -1, 0, (cb), (arg))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22f7e7b422e9098d9362626d47b77525"></a><!-- doxytag: member="event.h::evtimer_del" ref="a22f7e7b422e9098d9362626d47b77525" args="(ev)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evtimer_del</b>(ev)&nbsp;&nbsp;&nbsp;event_del(ev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a765c62ada275b4114ca0494e9d1f0047"></a><!-- doxytag: member="event.h::evtimer_initialized" ref="a765c62ada275b4114ca0494e9d1f0047" args="(ev)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evtimer_initialized</b>(ev)&nbsp;&nbsp;&nbsp;event_initialized(ev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76b701417f1cd29208019283d1fd1691"></a><!-- doxytag: member="event.h::evtimer_new" ref="a76b701417f1cd29208019283d1fd1691" args="(b, cb, arg)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evtimer_new</b>(b, cb, arg)&nbsp;&nbsp;&nbsp;event_new((b), -1, 0, (cb), (arg))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7037bae3f2fb09eb2752e8252b63a5a6"></a><!-- doxytag: member="event.h::evtimer_pending" ref="a7037bae3f2fb09eb2752e8252b63a5a6" args="(ev, tv)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evtimer_pending</b>(ev, tv)&nbsp;&nbsp;&nbsp;event_pending((ev), EV_TIMEOUT, (tv))</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ac1bbbe034b87ff78b7a380c0b71064d4">event_callback_fn</a> )(evutil_socket_t, short, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function for an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>.  <a href="#ac1bbbe034b87ff78b7a380c0b71064d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a96cbd560e6fe7cb4ebfa6000e164d752">event_fatal_cb</a> )(int err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function to be called if Libevent encounters a fatal internal error.  <a href="#a96cbd560e6fe7cb4ebfa6000e164d752"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#adbff4d951c4b002b955966f0ab228a76">event_log_cb</a> )(int severity, const char *msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function used to intercept Libevent's log messages.  <a href="#adbff4d951c4b002b955966f0ab228a76"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#acfef69af45abee54725f40f7f29986c5">event_base_config_flag</a> { <br/>
&nbsp;&nbsp;<a class="el" href="event_8h.html#acfef69af45abee54725f40f7f29986c5ac1302f72251168137258335e945e2ae5">EVENT_BASE_FLAG_NOLOCK</a> =  0x01, 
<a class="el" href="event_8h.html#acfef69af45abee54725f40f7f29986c5a230574947412d83f2dd19fe8c7d286e7">EVENT_BASE_FLAG_IGNORE_ENV</a> =  0x02, 
<a class="el" href="event_8h.html#acfef69af45abee54725f40f7f29986c5a4ffb2510ab533d7156f412ee4f0c08ea">EVENT_BASE_FLAG_STARTUP_IOCP</a> =  0x04, 
<a class="el" href="event_8h.html#acfef69af45abee54725f40f7f29986c5a057dff1977c48174f0a0f0c43ef92ec5">EVENT_BASE_FLAG_NO_CACHE_TIME</a> =  0x08, 
<br/>
&nbsp;&nbsp;<a class="el" href="event_8h.html#acfef69af45abee54725f40f7f29986c5acceb45f3098787247044929f92f4296e">EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST</a> =  0x10
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>A flag passed to <a class="el" href="event_8h.html#ac4b2697c7927fcd2167a1749f6602f29" title="Sets one or more flags to configure what parts of the eventual event_base will be...">event_config_set_flag()</a>. </p>
 <a href="event_8h.html#acfef69af45abee54725f40f7f29986c5">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ae7da61aef13e27a3047151b696b44c80">event_method_feature</a> { <a class="el" href="event_8h.html#ae7da61aef13e27a3047151b696b44c80ab407cae60af925dba44bd66e56e5f897">EV_FEATURE_ET</a> =  0x01, 
<a class="el" href="event_8h.html#ae7da61aef13e27a3047151b696b44c80a7a6f2de86c09b92aa175f950190bf706">EV_FEATURE_O1</a> =  0x02, 
<a class="el" href="event_8h.html#ae7da61aef13e27a3047151b696b44c80a2e964e8a8f3033d26d52831fb8eec199">EV_FEATURE_FDS</a> =  0x04
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>A flag used to describe which features an <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> (must) provide. </p>
 <a href="event_8h.html#ae7da61aef13e27a3047151b696b44c80">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a3262ae1dc7fe51516b43412d61301e4f">event_active</a> (struct <a class="el" href="structevent.html">event</a> *ev, int res, short ncalls)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> active.  <a href="#a3262ae1dc7fe51516b43412d61301e4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add</a> (struct <a class="el" href="structevent.html">event</a> *ev, const struct timeval *timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> to the set of pending events.  <a href="#a44df7b40859b56f2c866adb02dabdd9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#afade5e4859dee5b85d502e5594a05cf0">event_assign</a> (struct <a class="el" href="structevent.html">event</a> *, struct <a class="el" href="structevent__base.html">event_base</a> *, evutil_socket_t, short, <a class="el" href="event_8h.html#ac1bbbe034b87ff78b7a380c0b71064d4">event_callback_fn</a>, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare a new, already-allocated <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> structure to be added.  <a href="#afade5e4859dee5b85d502e5594a05cf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a01e457364ed5216a8c7bc219033b946f">event_base_dispatch</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event dispatching loop.  <a href="#a01e457364ed5216a8c7bc219033b946f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd5d691782408e8a55fbfdc08c26e5da"></a><!-- doxytag: member="event.h::event_base_dump_events" ref="acd5d691782408e8a55fbfdc08c26e5da" args="(struct event_base *, FILE *)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>event_base_dump_events</b> (struct <a class="el" href="structevent__base.html">event_base</a> *, FILE *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a6e9827de8c3014417b11b48f2fe688ae">event_base_free</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate all memory associated with an <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a>, and free the base.  <a href="#a6e9827de8c3014417b11b48f2fe688ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a11cb58563e8b5da36f00db2e250d026c">event_base_get_features</a> (const struct <a class="el" href="structevent__base.html">event_base</a> *base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a bitmask of the features implemented by an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base.  <a href="#a11cb58563e8b5da36f00db2e250d026c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a10914a893ed07dc8238d3274a9cbb3fc">event_base_get_method</a> (const struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the kernel <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> notification mechanism used by Libevent.  <a href="#a10914a893ed07dc8238d3274a9cbb3fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ad1d2129d47590c53d166f8c09afee865">event_base_gettimeofday_cached</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, struct timeval *tv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets 'tv' to the current time (as returned by gettimeofday()), looking at the cached value in 'base' if possible, and calling gettimeofday() or clock_gettime() as appropriate if there is no cached time.  <a href="#ad1d2129d47590c53d166f8c09afee865"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a7a2be7762111b00935c1b1f5ea055351">event_base_got_break</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> loop was told to abort immediately by <a class="el" href="event__compat_8h.html#a3a5c57caea1d97160f6990b3deeb6961" title="Abort the active event_loop() immediately.">event_loopbreak()</a>.  <a href="#a7a2be7762111b00935c1b1f5ea055351"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a4786b2d2cc1dd6e5fdd50e0d7627d495">event_base_got_exit</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> loop was told to exit by <a class="el" href="event__compat_8h.html#a2e3d894ac7986bb4967ebfe67a2d9977" title="Exit the event loop after the specified time.">event_loopexit()</a>.  <a href="#a4786b2d2cc1dd6e5fdd50e0d7627d495"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct timeval *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a55b459e572b58cc0b0c4cca8ce63921d">event_base_init_common_timeout</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, const struct timeval *duration)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare an <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> to use a large number of timeouts with the same duration.  <a href="#a55b459e572b58cc0b0c4cca8ce63921d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80">event_base_loop</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for events to become active, and run their callbacks.  <a href="#ad712706e6a763b6662f0eb03b3d8cd80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a07a7599e478e4031fa8cf52e26d8aa1e">event_base_loopbreak</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort the active <a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80" title="Wait for events to become active, and run their callbacks.">event_base_loop()</a> immediately.  <a href="#a07a7599e478e4031fa8cf52e26d8aa1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ac2c66174ee5f10df65b9a9b62fca7dd9">event_base_loopexit</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, const struct timeval *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exit the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> loop after the specified time.  <a href="#ac2c66174ee5f10df65b9a9b62fca7dd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a4c16f1203aebc67f94791ae0240b7353">event_base_new</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and return a new <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> to use with the rest of Libevent.  <a href="#a4c16f1203aebc67f94791ae0240b7353"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a444afb106c45ba296d847417a3a1ef04">event_base_new_with_config</a> (const struct <a class="el" href="structevent__config.html">event_config</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> API.  <a href="#a444afb106c45ba296d847417a3a1ef04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#acddee16b430c037ae061f966dc18eb9d">event_base_once</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, evutil_socket_t, short, <a class="el" href="event_8h.html#ac1bbbe034b87ff78b7a380c0b71064d4">event_callback_fn</a>, void *, const struct timeval *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule a one-time <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>.  <a href="#acddee16b430c037ae061f966dc18eb9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a67067fe995561cd36a7f34ef19e030e8">event_base_priority_init</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the number of different <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> priorities.  <a href="#a67067fe995561cd36a7f34ef19e030e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a2efd0ac7e54428d1941f212bc16ed9ce">event_base_set</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, struct <a class="el" href="structevent.html">event</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate a different <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base with an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>.  <a href="#a2efd0ac7e54428d1941f212bc16ed9ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a961de3fb39a12ff67ff030bb3caacba2">event_config_avoid_method</a> (struct <a class="el" href="structevent__config.html">event_config</a> *cfg, const char *method)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enters an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> method that should be avoided into the configuration.  <a href="#a961de3fb39a12ff67ff030bb3caacba2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a605f44836f97bb031776a7f70d53d719">event_config_free</a> (struct <a class="el" href="structevent__config.html">event_config</a> *cfg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocates all memory associated with an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> configuration object.  <a href="#a605f44836f97bb031776a7f70d53d719"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevent__config.html">event_config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a92e238d51357e3dae6fcdd0b9e83b2d2">event_config_new</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates a new <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> configuration object.  <a href="#a92e238d51357e3dae6fcdd0b9e83b2d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a2b08f2633e76290117e4a03621940948">event_config_require_features</a> (struct <a class="el" href="structevent__config.html">event_config</a> *cfg, int feature)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enters a required <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> method feature that the application demands.  <a href="#a2b08f2633e76290117e4a03621940948"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ac4b2697c7927fcd2167a1749f6602f29">event_config_set_flag</a> (struct <a class="el" href="structevent__config.html">event_config</a> *cfg, int flag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets one or more flags to configure what parts of the eventual <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> will be initialized, and how they'll work.  <a href="#ac4b2697c7927fcd2167a1749f6602f29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#aa12ff91d766988a170cab43c53f66143">event_config_set_num_cpus_hint</a> (struct <a class="el" href="structevent__config.html">event_config</a> *cfg, int cpus)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Records a hint for the number of CPUs in the system.  <a href="#aa12ff91d766988a170cab43c53f66143"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#afcc47ab5cc9128202cbe5012c4214a6b">event_debug_unassign</a> (struct <a class="el" href="structevent.html">event</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When debugging mode is enabled, informs Libevent that an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> should no longer be considered as assigned.  <a href="#afcc47ab5cc9128202cbe5012c4214a6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258">event_del</a> (struct <a class="el" href="structevent.html">event</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> from the set of monitored events.  <a href="#a30a8cb96af49d18388f64de73a2d4258"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a3472400b8b1802550df2242673a6da37">event_enable_debug_mode</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable some relatively expensive debugging checks in Libevent that would normally be turned off.  <a href="#a3472400b8b1802550df2242673a6da37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ad7fd53b1263bf0fdccd959a6c5a659cc">event_free</a> (struct <a class="el" href="structevent.html">event</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate a struct <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> * returned by <a class="el" href="event_8h.html#ab9a66f828d205eda84b321e32014cbbd" title="Allocate and asssign a new event structure, ready to be added.">event_new()</a>.  <a href="#ad7fd53b1263bf0fdccd959a6c5a659cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a2103c3cbf6e3e173419ebf019e29c788">event_get_assignment</a> (const struct <a class="el" href="structevent.html">event</a> *<a class="el" href="structevent.html">event</a>, struct <a class="el" href="structevent__base.html">event_base</a> **base_out, evutil_socket_t *fd_out, short *events_out, <a class="el" href="event_8h.html#ac1bbbe034b87ff78b7a380c0b71064d4">event_callback_fn</a> *callback_out, void **arg_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract _all_ of arguments given to construct a given <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>.  <a href="#a2103c3cbf6e3e173419ebf019e29c788"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9763d285fa415e4547a0d5e55cf5b13"></a><!-- doxytag: member="event.h::event_get_base" ref="ae9763d285fa415e4547a0d5e55cf5b13" args="(const struct event *ev)" -->
struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ae9763d285fa415e4547a0d5e55cf5b13">event_get_base</a> (const struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> associated with an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cdb0a8dbf7efa9be7b65914ed5c6821"></a><!-- doxytag: member="event.h::event_get_callback" ref="a6cdb0a8dbf7efa9be7b65914ed5c6821" args="(const struct event *ev)" -->
<a class="el" href="event_8h.html#ac1bbbe034b87ff78b7a380c0b71064d4">event_callback_fn</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a6cdb0a8dbf7efa9be7b65914ed5c6821">event_get_callback</a> (const struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the callback assigned to an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab07e87ff7d43ad7205a008f08fbaf0a3"></a><!-- doxytag: member="event.h::event_get_callback_arg" ref="ab07e87ff7d43ad7205a008f08fbaf0a3" args="(const struct event *ev)" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ab07e87ff7d43ad7205a008f08fbaf0a3">event_get_callback_arg</a> (const struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the callback argument assigned to an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0123fdd5b9a1c204de5d7ef1a4578387"></a><!-- doxytag: member="event.h::event_get_events" ref="a0123fdd5b9a1c204de5d7ef1a4578387" args="(const struct event *ev)" -->
short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a0123fdd5b9a1c204de5d7ef1a4578387">event_get_events</a> (const struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the events (EV_READ, EV_WRITE, etc) assigned to an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee0c9c3fc7c997e4d4b77bdcdf321ee6"></a><!-- doxytag: member="event.h::event_get_fd" ref="aee0c9c3fc7c997e4d4b77bdcdf321ee6" args="(const struct event *ev)" -->
evutil_socket_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#aee0c9c3fc7c997e4d4b77bdcdf321ee6">event_get_fd</a> (const struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the socket or signal assigned to an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>, or -1 if the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> has no socket. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a3881f7391324c05bd6f0c291e2682f03">event_get_struct_event_size</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the size of struct <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> that the Libevent library was compiled with.  <a href="#a3881f7391324c05bd6f0c291e2682f03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#af93a8115c6c8ff28db573cba84d1e488">event_get_supported_methods</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets all <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> notification mechanisms supported by Libevent.  <a href="#af93a8115c6c8ff28db573cba84d1e488"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a43d7feed94477cf0a7e3e062cc17b7e1">event_get_version</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Libevent version.  <a href="#a43d7feed94477cf0a7e3e062cc17b7e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ev_uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#abd4d1f2b4ca8e11f3bbf022244f01fa9">event_get_version_number</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a numeric representation of Libevent's version.  <a href="#abd4d1f2b4ca8e11f3bbf022244f01fa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a5be4fbc16d90915a7d1b21ed3bae40c0">event_initialized</a> (const struct <a class="el" href="structevent.html">event</a> *ev)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> structure might be initialized.  <a href="#a5be4fbc16d90915a7d1b21ed3bae40c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevent.html">event</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ab9a66f828d205eda84b321e32014cbbd">event_new</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, evutil_socket_t, short, <a class="el" href="event_8h.html#ac1bbbe034b87ff78b7a380c0b71064d4">event_callback_fn</a>, void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and asssign a new <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> structure, ready to be added.  <a href="#ab9a66f828d205eda84b321e32014cbbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a49773a4e3e46f60e488ac37fb46950d9">event_pending</a> (const struct <a class="el" href="structevent.html">event</a> *ev, short events, struct timeval *tv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a specific <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> is pending or scheduled.  <a href="#a49773a4e3e46f60e488ac37fb46950d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a9984a63f2edcc72bef96a188f569b367">event_priority_set</a> (struct <a class="el" href="structevent.html">event</a> *, int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a priority to an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>.  <a href="#a9984a63f2edcc72bef96a188f569b367"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a7409499a79a59842955928af446fe03d">event_reinit</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reinitialize the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base after a fork.  <a href="#a7409499a79a59842955928af446fe03d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a73beabc6626db0da679eb8961ce3f477">event_set_fatal_callback</a> (<a class="el" href="event_8h.html#a96cbd560e6fe7cb4ebfa6000e164d752">event_fatal_cb</a> cb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override Libevent's behavior in the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> of a fatal internal error.  <a href="#a73beabc6626db0da679eb8961ce3f477"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a87e59ed1dd711ced2b2a1314d3e3c1c7">event_set_log_callback</a> (<a class="el" href="event_8h.html#adbff4d951c4b002b955966f0ab228a76">event_log_cb</a> cb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Redirect Libevent's log messages.  <a href="#a87e59ed1dd711ced2b2a1314d3e3c1c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a653e38c4bdd2f3b2d7476fcee95c1a62">event_set_mem_functions</a> (void *(*malloc_fn)(size_t sz), void *(*realloc_fn)(void *ptr, size_t sz), void(*free_fn)(void *ptr))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override the functions that Libevent uses for memory management.  <a href="#a653e38c4bdd2f3b2d7476fcee95c1a62"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Core functions for waiting for and receiving events, and using <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> bases. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a01084abbcdd3a58b4068359548a3ea71"></a><!-- doxytag: member="event.h::EV_ET" ref="a01084abbcdd3a58b4068359548a3ea71" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EV_ET&nbsp;&nbsp;&nbsp;0x20</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select edge-triggered behavior, if supported by the backend. </p>

</div>
</div>
<a class="anchor" id="a3c4947a60eb6d09327c61f89135f9f37"></a><!-- doxytag: member="event.h::EV_PERSIST" ref="a3c4947a60eb6d09327c61f89135f9f37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EV_PERSIST&nbsp;&nbsp;&nbsp;0x10</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Persistent <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>: won't get removed automatically when activated. </p>
<p>When a persistent <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> with a timeout becomes activated, its timeout is reset to 0. </p>

</div>
</div>
<a class="anchor" id="a37ef4b6056484f5580f7d72fcf46fccf"></a><!-- doxytag: member="event.h::EV_TIMEOUT" ref="a37ef4b6056484f5580f7d72fcf46fccf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EV_TIMEOUT&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates that a timeout has occurred. </p>
<p>It's not necessary to pass this flag to event_for new()/event_assign() to get a timeout. </p>

</div>
</div>
<a class="anchor" id="ad74f7bf73ff985bfaf61c462cbba022f"></a><!-- doxytag: member="event.h::EVENT_MAX_PRIORITIES" ref="ad74f7bf73ff985bfaf61c462cbba022f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVENT_MAX_PRIORITIES&nbsp;&nbsp;&nbsp;256</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Largest number of priorities that Libevent can support. </p>

</div>
</div>
<a class="anchor" id="a10b9c102337d0ece8607c9c01bc4f7c8"></a><!-- doxytag: member="event.h::EVLOOP_NONBLOCK" ref="a10b9c102337d0ece8607c9c01bc4f7c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVLOOP_NONBLOCK&nbsp;&nbsp;&nbsp;0x02</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do not block: see which events are ready now, run the callbacks of the highest-priority ones, then exit. </p>

</div>
</div>
<a class="anchor" id="afab575b1e867dde13a2c7f2f967e0e4e"></a><!-- doxytag: member="event.h::EVLOOP_ONCE" ref="afab575b1e867dde13a2c7f2f967e0e4e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVLOOP_ONCE&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block until we have an active <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>, then exit once all active events have had their callbacks run. </p>

</div>
</div>
<a class="anchor" id="aad00c7d4ddbd6b590c15861a2e767182"></a><!-- doxytag: member="event.h::LIBEVENT_VERSION" ref="aad00c7d4ddbd6b590c15861a2e767182" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIBEVENT_VERSION&nbsp;&nbsp;&nbsp;_EVENT_VERSION</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>As event_get_version, but gives the version of Libevent's headers. </p>

</div>
</div>
<a class="anchor" id="a8a9c8021651a2d8d7946083281279586"></a><!-- doxytag: member="event.h::LIBEVENT_VERSION_NUMBER" ref="a8a9c8021651a2d8d7946083281279586" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIBEVENT_VERSION_NUMBER&nbsp;&nbsp;&nbsp;_EVENT_NUMERIC_VERSION</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>As event_get_version_number, but gives the version number of Libevent's headers. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ac1bbbe034b87ff78b7a380c0b71064d4"></a><!-- doxytag: member="event.h::event_callback_fn" ref="ac1bbbe034b87ff78b7a380c0b71064d4" args=")(evutil_socket_t, short, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="event_8h.html#ac1bbbe034b87ff78b7a380c0b71064d4">event_callback_fn</a>)(evutil_socket_t, short, void *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function for an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>. </p>
<p>It receives three arguments:</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>An fd or signal </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>One or more EV_* flags </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>A user-supplied argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#ab9a66f828d205eda84b321e32014cbbd" title="Allocate and asssign a new event structure, ready to be added.">event_new()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a96cbd560e6fe7cb4ebfa6000e164d752"></a><!-- doxytag: member="event.h::event_fatal_cb" ref="a96cbd560e6fe7cb4ebfa6000e164d752" args=")(int err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="event_8h.html#a96cbd560e6fe7cb4ebfa6000e164d752">event_fatal_cb</a>)(int err)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function to be called if Libevent encounters a fatal internal error. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#a73beabc6626db0da679eb8961ce3f477" title="Override Libevent&#39;s behavior in the event of a fatal internal error.">event_set_fatal_callback</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adbff4d951c4b002b955966f0ab228a76"></a><!-- doxytag: member="event.h::event_log_cb" ref="adbff4d951c4b002b955966f0ab228a76" args=")(int severity, const char *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="event_8h.html#adbff4d951c4b002b955966f0ab228a76">event_log_cb</a>)(int severity, const char *msg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function used to intercept Libevent's log messages. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#a87e59ed1dd711ced2b2a1314d3e3c1c7" title="Redirect Libevent&#39;s log messages.">event_set_log_callback</a> </dd></dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="acfef69af45abee54725f40f7f29986c5"></a><!-- doxytag: member="event.h::event_base_config_flag" ref="acfef69af45abee54725f40f7f29986c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="event_8h.html#acfef69af45abee54725f40f7f29986c5">event_base_config_flag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A flag passed to <a class="el" href="event_8h.html#ac4b2697c7927fcd2167a1749f6602f29" title="Sets one or more flags to configure what parts of the eventual event_base will be...">event_config_set_flag()</a>. </p>
<p>These flags change the behavior of an allocated <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#ac4b2697c7927fcd2167a1749f6602f29" title="Sets one or more flags to configure what parts of the eventual event_base will be...">event_config_set_flag()</a>, <a class="el" href="event_8h.html#a444afb106c45ba296d847417a3a1ef04" title="Initialize the event API.">event_base_new_with_config()</a>, <a class="el" href="event_8h.html#ae7da61aef13e27a3047151b696b44c80" title="A flag used to describe which features an event_base (must) provide.">event_method_feature</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="acfef69af45abee54725f40f7f29986c5ac1302f72251168137258335e945e2ae5"></a><!-- doxytag: member="EVENT_BASE_FLAG_NOLOCK" ref="acfef69af45abee54725f40f7f29986c5ac1302f72251168137258335e945e2ae5" args="" -->EVENT_BASE_FLAG_NOLOCK</em>&nbsp;</td><td>
<p>Do not allocate a lock for the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base, even if we have locking set up. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acfef69af45abee54725f40f7f29986c5a230574947412d83f2dd19fe8c7d286e7"></a><!-- doxytag: member="EVENT_BASE_FLAG_IGNORE_ENV" ref="acfef69af45abee54725f40f7f29986c5a230574947412d83f2dd19fe8c7d286e7" args="" -->EVENT_BASE_FLAG_IGNORE_ENV</em>&nbsp;</td><td>
<p>Do not check the EVENT_* environment variables when configuring an <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a>. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acfef69af45abee54725f40f7f29986c5a4ffb2510ab533d7156f412ee4f0c08ea"></a><!-- doxytag: member="EVENT_BASE_FLAG_STARTUP_IOCP" ref="acfef69af45abee54725f40f7f29986c5a4ffb2510ab533d7156f412ee4f0c08ea" args="" -->EVENT_BASE_FLAG_STARTUP_IOCP</em>&nbsp;</td><td>
<p>Windows only: enable the IOCP dispatcher at startup. </p>
<p>If this flag is set then <a class="el" href="bufferevent_8h.html#a501557193aa56c9f4923583d9d734395" title="Create a new socket bufferevent over an existing socket.">bufferevent_socket_new()</a> and evconn_listener_new() will use IOCP-backed implementations instead of the usual select-based one on Windows. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acfef69af45abee54725f40f7f29986c5a057dff1977c48174f0a0f0c43ef92ec5"></a><!-- doxytag: member="EVENT_BASE_FLAG_NO_CACHE_TIME" ref="acfef69af45abee54725f40f7f29986c5a057dff1977c48174f0a0f0c43ef92ec5" args="" -->EVENT_BASE_FLAG_NO_CACHE_TIME</em>&nbsp;</td><td>
<p>Instead of checking the current time every time the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> loop is ready to run timeout callbacks, check after each timeout callback. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acfef69af45abee54725f40f7f29986c5acceb45f3098787247044929f92f4296e"></a><!-- doxytag: member="EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST" ref="acfef69af45abee54725f40f7f29986c5acceb45f3098787247044929f92f4296e" args="" -->EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST</em>&nbsp;</td><td>
<p>If we are using the epoll backend, this flag says that it is safe to use Libevent's internal change-list code to batch up adds and deletes in order to try to do as few syscalls as possible. </p>
<p>Setting this flag can make your code run faster, but it may trigger a Linux bug: it is not safe to use this flag if you have any fds cloned by dup() or its variants. Doing so will produce strange and hard-to-diagnose bugs.</p>
<p>This flag can also be activated by settnig the EVENT_EPOLL_USE_CHANGELIST environment variable.</p>
<p>This flag has no effect if you wind up using a backend other than epoll. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7da61aef13e27a3047151b696b44c80"></a><!-- doxytag: member="event.h::event_method_feature" ref="ae7da61aef13e27a3047151b696b44c80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="event_8h.html#ae7da61aef13e27a3047151b696b44c80">event_method_feature</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A flag used to describe which features an <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> (must) provide. </p>
<p>Because of OS limitations, not every Libevent backend supports every possible feature. You can use this type with <a class="el" href="event_8h.html#a2b08f2633e76290117e4a03621940948" title="Enters a required event method feature that the application demands.">event_config_require_features()</a> to tell Libevent to only proceed if your <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> implements a given feature, and you can receive this type from <a class="el" href="event_8h.html#a11cb58563e8b5da36f00db2e250d026c" title="Return a bitmask of the features implemented by an event base.">event_base_get_features()</a> to see which features are available. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae7da61aef13e27a3047151b696b44c80ab407cae60af925dba44bd66e56e5f897"></a><!-- doxytag: member="EV_FEATURE_ET" ref="ae7da61aef13e27a3047151b696b44c80ab407cae60af925dba44bd66e56e5f897" args="" -->EV_FEATURE_ET</em>&nbsp;</td><td>
<p>Require an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> method that allows edge-triggered events with EV_ET. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae7da61aef13e27a3047151b696b44c80a7a6f2de86c09b92aa175f950190bf706"></a><!-- doxytag: member="EV_FEATURE_O1" ref="ae7da61aef13e27a3047151b696b44c80a7a6f2de86c09b92aa175f950190bf706" args="" -->EV_FEATURE_O1</em>&nbsp;</td><td>
<p>Require an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> method where having one <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> triggered among many is [approximately] an O(1) operation. </p>
<p>This excludes (for example) select and poll, which are approximately O(N) for N equal to the total number of possible events. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae7da61aef13e27a3047151b696b44c80a2e964e8a8f3033d26d52831fb8eec199"></a><!-- doxytag: member="EV_FEATURE_FDS" ref="ae7da61aef13e27a3047151b696b44c80a2e964e8a8f3033d26d52831fb8eec199" args="" -->EV_FEATURE_FDS</em>&nbsp;</td><td>
<p>Require an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> method that allows file descriptors as well as sockets. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a3262ae1dc7fe51516b43412d61301e4f"></a><!-- doxytag: member="event.h::event_active" ref="a3262ae1dc7fe51516b43412d61301e4f" args="(struct event *ev, int res, short ncalls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_active </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&nbsp;</td>
          <td class="paramname"> <em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>ncalls</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> active. </p>
<p>You can use this function on a pending or a non-pending <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> to make it active, so that its callback will be run by <a class="el" href="event_8h.html#a01e457364ed5216a8c7bc219033b946f" title="Event dispatching loop.">event_base_dispatch()</a> or <a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80" title="Wait for events to become active, and run their callbacks.">event_base_loop()</a>.</p>
<p>One common use in multithreaded programs is to wake the thread running <a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80" title="Wait for events to become active, and run their callbacks.">event_base_loop()</a> from another thread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ev</em>&nbsp;</td><td>an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> to make active. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>res</em>&nbsp;</td><td>a set of flags to pass to the event's callback. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ncalls</em>&nbsp;</td><td>an obsolete argument: this is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44df7b40859b56f2c866adb02dabdd9e"></a><!-- doxytag: member="event.h::event_add" ref="a44df7b40859b56f2c866adb02dabdd9e" args="(struct event *ev, const struct timeval *timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&nbsp;</td>
          <td class="paramname"> <em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> to the set of pending events. </p>
<p>The function <a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e" title="Add an event to the set of pending events.">event_add()</a> schedules the execution of the ev <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> when the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> specified in <a class="el" href="event_8h.html#afade5e4859dee5b85d502e5594a05cf0" title="Prepare a new, already-allocated event structure to be added.">event_assign()</a>/event_new() occurs, or when the time specified in timeout has elapesed. If atimeout is NULL, no timeout occurs and the function will only be called if a matching <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> occurs. The <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> in the ev argument must be already initialized by <a class="el" href="event_8h.html#afade5e4859dee5b85d502e5594a05cf0" title="Prepare a new, already-allocated event structure to be added.">event_assign()</a> or <a class="el" href="event_8h.html#ab9a66f828d205eda84b321e32014cbbd" title="Allocate and asssign a new event structure, ready to be added.">event_new()</a> and may not be used in calls to <a class="el" href="event_8h.html#afade5e4859dee5b85d502e5594a05cf0" title="Prepare a new, already-allocated event structure to be added.">event_assign()</a> until it is no longer pending.</p>
<p>If the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> in the ev argument already has a scheduled timeout, calling <a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e" title="Add an event to the set of pending events.">event_add()</a> replaces the old timeout with the new one, or clears the old timeout if the timeout argument is NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ev</em>&nbsp;</td><td>an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> struct initialized via <a class="el" href="event__compat_8h.html#ace184d66066e9bac013779d8f6921d11" title="Prepare an event structure to be added.">event_set()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>the maximum amount of time to wait for the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>, or NULL to wait forever </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258" title="Remove an event from the set of monitored events.">event_del()</a>, <a class="el" href="event_8h.html#afade5e4859dee5b85d502e5594a05cf0" title="Prepare a new, already-allocated event structure to be added.">event_assign()</a>, <a class="el" href="event_8h.html#ab9a66f828d205eda84b321e32014cbbd" title="Allocate and asssign a new event structure, ready to be added.">event_new()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afade5e4859dee5b85d502e5594a05cf0"></a><!-- doxytag: member="event.h::event_assign" ref="afade5e4859dee5b85d502e5594a05cf0" args="(struct event *, struct event_base *, evutil_socket_t, short, event_callback_fn, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_assign </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event_8h.html#ac1bbbe034b87ff78b7a380c0b71064d4">event_callback_fn</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare a new, already-allocated <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> structure to be added. </p>
<p>The function <a class="el" href="event_8h.html#afade5e4859dee5b85d502e5594a05cf0" title="Prepare a new, already-allocated event structure to be added.">event_assign()</a> prepares the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> structure ev to be used in future calls to <a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e" title="Add an event to the set of pending events.">event_add()</a> and <a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258" title="Remove an event from the set of monitored events.">event_del()</a>. Unlike <a class="el" href="event_8h.html#ab9a66f828d205eda84b321e32014cbbd" title="Allocate and asssign a new event structure, ready to be added.">event_new()</a>, it doesn't allocate memory itself: it requires that you have already allocated a struct <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>, probably on the heap. Doing this will typically make your code depend on the size of the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> structure, and thereby create incompatibility with future versions of Libevent.</p>
<p>The easiest way to avoid this problem is just to use <a class="el" href="event_8h.html#ab9a66f828d205eda84b321e32014cbbd" title="Allocate and asssign a new event structure, ready to be added.">event_new()</a> and <a class="el" href="event_8h.html#ad7fd53b1263bf0fdccd959a6c5a659cc" title="Deallocate a struct event * returned by event_new().">event_free()</a> instead.</p>
<p>A slightly harder way to future-proof your code is to use <a class="el" href="event_8h.html#a3881f7391324c05bd6f0c291e2682f03" title="Return the size of struct event that the Libevent library was compiled with.">event_get_struct_event_size()</a> to determine the required size of an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> at runtime.</p>
<p>Note that it is NOT safe to call this function on an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> that is active or pending. Doing so WILL corrupt internal data structures in Libevent, and lead to strange, hard-to-diagnose bugs. You _can_ use event_assign to change an existing <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>, but only if it is not active or pending!</p>
<p>The arguments for this function, and the behavior of the events that it makes, are as for <a class="el" href="event_8h.html#ab9a66f828d205eda84b321e32014cbbd" title="Allocate and asssign a new event structure, ready to be added.">event_new()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ev</em>&nbsp;</td><td>an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> struct to be modified </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base to which ev should be attached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>the file descriptor to be monitored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>desired events to monitor; can be EV_READ and/or EV_WRITE </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>callback function to be invoked when the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> occurs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback_arg</em>&nbsp;</td><td>an argument to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success, or -1 on invalid arguments.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#ab9a66f828d205eda84b321e32014cbbd" title="Allocate and asssign a new event structure, ready to be added.">event_new()</a>, <a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e" title="Add an event to the set of pending events.">event_add()</a>, <a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258" title="Remove an event from the set of monitored events.">event_del()</a>, <a class="el" href="event_8h.html#acddee16b430c037ae061f966dc18eb9d" title="Schedule a one-time event.">event_base_once()</a>, <a class="el" href="event_8h.html#a3881f7391324c05bd6f0c291e2682f03" title="Return the size of struct event that the Libevent library was compiled with.">event_get_struct_event_size()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a01e457364ed5216a8c7bc219033b946f"></a><!-- doxytag: member="event.h::event_base_dispatch" ref="a01e457364ed5216a8c7bc219033b946f" args="(struct event_base *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_dispatch </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event dispatching loop. </p>
<p>This loop will run the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base until either there are no more added events, or until something calls <a class="el" href="event_8h.html#a07a7599e478e4031fa8cf52e26d8aa1e" title="Abort the active event_base_loop() immediately.">event_base_loopbreak()</a> or <a class="el" href="event_8h.html#ac2c66174ee5f10df65b9a9b62fca7dd9" title="Exit the event loop after the specified time.">event_base_loopexit()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>the <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> structure returned by <a class="el" href="event_8h.html#a4c16f1203aebc67f94791ae0240b7353" title="Create and return a new event_base to use with the rest of Libevent.">event_base_new()</a> or <a class="el" href="event_8h.html#a444afb106c45ba296d847417a3a1ef04" title="Initialize the event API.">event_base_new_with_config()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if an error occurred, or 1 if no events were registered. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80" title="Wait for events to become active, and run their callbacks.">event_base_loop()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6e9827de8c3014417b11b48f2fe688ae"></a><!-- doxytag: member="event.h::event_base_free" ref="a6e9827de8c3014417b11b48f2fe688ae" args="(struct event_base *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_base_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate all memory associated with an <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a>, and free the base. </p>
<p>Note that this function will not close any fds or free any memory passed to event_new as the argument to callback.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eb</em>&nbsp;</td><td>an <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> to be freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11cb58563e8b5da36f00db2e250d026c"></a><!-- doxytag: member="event.h::event_base_get_features" ref="a11cb58563e8b5da36f00db2e250d026c" args="(const struct event_base *base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_get_features </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"> <em>base</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a bitmask of the features implemented by an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base. </p>
<p>This will be a bitwise OR of one or more of the values of event_method_feature</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#ae7da61aef13e27a3047151b696b44c80" title="A flag used to describe which features an event_base (must) provide.">event_method_feature</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10914a893ed07dc8238d3274a9cbb3fc"></a><!-- doxytag: member="event.h::event_base_get_method" ref="a10914a893ed07dc8238d3274a9cbb3fc" args="(const struct event_base *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* event_base_get_method </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the kernel <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> notification mechanism used by Libevent. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eb</em>&nbsp;</td><td>the <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> structure returned by <a class="el" href="event_8h.html#a4c16f1203aebc67f94791ae0240b7353" title="Create and return a new event_base to use with the rest of Libevent.">event_base_new()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string identifying the kernel <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> mechanism (kqueue, epoll, etc.) </dd></dl>

</div>
</div>
<a class="anchor" id="ad1d2129d47590c53d166f8c09afee865"></a><!-- doxytag: member="event.h::event_base_gettimeofday_cached" ref="ad1d2129d47590c53d166f8c09afee865" args="(struct event_base *base, struct timeval *tv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_gettimeofday_cached </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&nbsp;</td>
          <td class="paramname"> <em>tv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets 'tv' to the current time (as returned by gettimeofday()), looking at the cached value in 'base' if possible, and calling gettimeofday() or clock_gettime() as appropriate if there is no cached time. </p>
<p>Generally, this value will only be cached while actually processing <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> callbacks, and may be very inaccuate if your callbacks take a long time to execute.</p>
<p>Returns 0 on success, negative on failure. </p>

</div>
</div>
<a class="anchor" id="a7a2be7762111b00935c1b1f5ea055351"></a><!-- doxytag: member="event.h::event_base_got_break" ref="a7a2be7762111b00935c1b1f5ea055351" args="(struct event_base *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_got_break </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> loop was told to abort immediately by <a class="el" href="event__compat_8h.html#a3a5c57caea1d97160f6990b3deeb6961" title="Abort the active event_loop() immediately.">event_loopbreak()</a>. </p>
<p>This function will return true for an <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> at every point after <a class="el" href="event__compat_8h.html#a3a5c57caea1d97160f6990b3deeb6961" title="Abort the active event_loop() immediately.">event_loopbreak()</a> is called, until the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> loop is next entered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eb</em>&nbsp;</td><td>the <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> structure returned by <a class="el" href="event__compat_8h.html#a1bf74386dd3725e1538fed2d70c1c113" title="Initialize the event API.">event_init()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if <a class="el" href="event_8h.html#a07a7599e478e4031fa8cf52e26d8aa1e" title="Abort the active event_base_loop() immediately.">event_base_loopbreak()</a> was called on this <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base, or 0 otherwise </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#a07a7599e478e4031fa8cf52e26d8aa1e" title="Abort the active event_base_loop() immediately.">event_base_loopbreak()</a> </dd>
<dd>
<a class="el" href="event_8h.html#a4786b2d2cc1dd6e5fdd50e0d7627d495" title="Checks if the event loop was told to exit by event_loopexit().">event_base_got_exit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4786b2d2cc1dd6e5fdd50e0d7627d495"></a><!-- doxytag: member="event.h::event_base_got_exit" ref="a4786b2d2cc1dd6e5fdd50e0d7627d495" args="(struct event_base *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_got_exit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> loop was told to exit by <a class="el" href="event__compat_8h.html#a2e3d894ac7986bb4967ebfe67a2d9977" title="Exit the event loop after the specified time.">event_loopexit()</a>. </p>
<p>This function will return true for an <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> at every point after <a class="el" href="event__compat_8h.html#a2e3d894ac7986bb4967ebfe67a2d9977" title="Exit the event loop after the specified time.">event_loopexit()</a> is called, until the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> loop is next entered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eb</em>&nbsp;</td><td>the <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> structure returned by <a class="el" href="event__compat_8h.html#a1bf74386dd3725e1538fed2d70c1c113" title="Initialize the event API.">event_init()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if <a class="el" href="event_8h.html#ac2c66174ee5f10df65b9a9b62fca7dd9" title="Exit the event loop after the specified time.">event_base_loopexit()</a> was called on this <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base, or 0 otherwise </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#ac2c66174ee5f10df65b9a9b62fca7dd9" title="Exit the event loop after the specified time.">event_base_loopexit()</a> </dd>
<dd>
<a class="el" href="event_8h.html#a7a2be7762111b00935c1b1f5ea055351" title="Checks if the event loop was told to abort immediately by event_loopbreak().">event_base_got_break()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a55b459e572b58cc0b0c4cca8ce63921d"></a><!-- doxytag: member="event.h::event_base_init_common_timeout" ref="a55b459e572b58cc0b0c4cca8ce63921d" args="(struct event_base *base, const struct timeval *duration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct timeval* event_base_init_common_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&nbsp;</td>
          <td class="paramname"> <em>duration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare an <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> to use a large number of timeouts with the same duration. </p>
<p>Libevent's default scheduling algorithm is optimized for having a large number of timeouts with their durations more or less randomly distributed. But if you have a large number of timeouts that all have the same duration (for example, if you have a large number of connections that all have a 10-second timeout), then you can improve Libevent's performance by telling Libevent about it.</p>
<p>To do this, call this function with the common duration. It will return a pointer to a different, opaque timeout value. (Don't depend on its actual contents!) When you use this timeout value in <a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e" title="Add an event to the set of pending events.">event_add()</a>, Libevent will schedule the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> more efficiently.</p>
<p>(This optimization probably will not be worthwhile until you have thousands or tens of thousands of events with the same timeout.) </p>

</div>
</div>
<a class="anchor" id="ad712706e6a763b6662f0eb03b3d8cd80"></a><!-- doxytag: member="event.h::event_base_loop" ref="ad712706e6a763b6662f0eb03b3d8cd80" args="(struct event_base *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_loop </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for events to become active, and run their callbacks. </p>
<p>This is a more flexible version of <a class="el" href="event_8h.html#a01e457364ed5216a8c7bc219033b946f" title="Event dispatching loop.">event_base_dispatch()</a>.</p>
<p>By default, this loop will run the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base until either there are no more added events, or until something calls <a class="el" href="event_8h.html#a07a7599e478e4031fa8cf52e26d8aa1e" title="Abort the active event_base_loop() immediately.">event_base_loopbreak()</a> or evenet_base_loopexit(). You can override this behavior with the 'flags' argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eb</em>&nbsp;</td><td>the <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> structure returned by <a class="el" href="event_8h.html#a4c16f1203aebc67f94791ae0240b7353" title="Create and return a new event_base to use with the rest of Libevent.">event_base_new()</a> or <a class="el" href="event_8h.html#a444afb106c45ba296d847417a3a1ef04" title="Initialize the event API.">event_base_new_with_config()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if an error occurred, or 1 if no events were registered. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#ac2c66174ee5f10df65b9a9b62fca7dd9" title="Exit the event loop after the specified time.">event_base_loopexit()</a>, <a class="el" href="event_8h.html#a01e457364ed5216a8c7bc219033b946f" title="Event dispatching loop.">event_base_dispatch()</a>, <a class="el" href="event_8h.html#afab575b1e867dde13a2c7f2f967e0e4e" title="Block until we have an active event, then exit once all active events have had their...">EVLOOP_ONCE</a>, <a class="el" href="event_8h.html#a10b9c102337d0ece8607c9c01bc4f7c8" title="Do not block: see which events are ready now, run the callbacks of the highest-priority...">EVLOOP_NONBLOCK</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a07a7599e478e4031fa8cf52e26d8aa1e"></a><!-- doxytag: member="event.h::event_base_loopbreak" ref="a07a7599e478e4031fa8cf52e26d8aa1e" args="(struct event_base *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_loopbreak </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abort the active <a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80" title="Wait for events to become active, and run their callbacks.">event_base_loop()</a> immediately. </p>
<p><a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80" title="Wait for events to become active, and run their callbacks.">event_base_loop()</a> will abort the loop after the next <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> is completed; <a class="el" href="event_8h.html#a07a7599e478e4031fa8cf52e26d8aa1e" title="Abort the active event_base_loop() immediately.">event_base_loopbreak()</a> is typically invoked from this event's callback. This behavior is analogous to the "break;" statement.</p>
<p>Subsequent invocations of <a class="el" href="event__compat_8h.html#a765c1875642fc730addf04e9433f6448" title="Handle events.">event_loop()</a> will proceed normally.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eb</em>&nbsp;</td><td>the <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> structure returned by <a class="el" href="event__compat_8h.html#a1bf74386dd3725e1538fed2d70c1c113" title="Initialize the event API.">event_init()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#ac2c66174ee5f10df65b9a9b62fca7dd9" title="Exit the event loop after the specified time.">event_base_loopexit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac2c66174ee5f10df65b9a9b62fca7dd9"></a><!-- doxytag: member="event.h::event_base_loopexit" ref="ac2c66174ee5f10df65b9a9b62fca7dd9" args="(struct event_base *, const struct timeval *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_loopexit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exit the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> loop after the specified time. </p>
<p>The next <a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80" title="Wait for events to become active, and run their callbacks.">event_base_loop()</a> iteration after the given timer expires will complete normally (handling all queued events) then exit without blocking for events again.</p>
<p>Subsequent invocations of <a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80" title="Wait for events to become active, and run their callbacks.">event_base_loop()</a> will proceed normally.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eb</em>&nbsp;</td><td>the <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> structure returned by <a class="el" href="event__compat_8h.html#a1bf74386dd3725e1538fed2d70c1c113" title="Initialize the event API.">event_init()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tv</em>&nbsp;</td><td>the amount of time after which the loop should terminate, or NULL to exit after running all currently active events. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#a07a7599e478e4031fa8cf52e26d8aa1e" title="Abort the active event_base_loop() immediately.">event_base_loopbreak()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4c16f1203aebc67f94791ae0240b7353"></a><!-- doxytag: member="event.h::event_base_new" ref="a4c16f1203aebc67f94791ae0240b7353" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevent__base.html">event_base</a>* event_base_new </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create and return a new <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> to use with the rest of Libevent. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> on success, or NULL on failure.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#a6e9827de8c3014417b11b48f2fe688ae" title="Deallocate all memory associated with an event_base, and free the base.">event_base_free()</a>, <a class="el" href="event_8h.html#a444afb106c45ba296d847417a3a1ef04" title="Initialize the event API.">event_base_new_with_config()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a444afb106c45ba296d847417a3a1ef04"></a><!-- doxytag: member="event.h::event_base_new_with_config" ref="a444afb106c45ba296d847417a3a1ef04" args="(const struct event_config *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevent__base.html">event_base</a>* event_base_new_with_config </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent__config.html">event_config</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> API. </p>
<p>Use <a class="el" href="event_8h.html#a444afb106c45ba296d847417a3a1ef04" title="Initialize the event API.">event_base_new_with_config()</a> to initialize a new <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base, taking the specified configuration under consideration. The configuration object can currently be used to avoid certain <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> notification mechanisms.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cfg</em>&nbsp;</td><td>the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> configuration object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an initialized <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> that can be used to registering events, or NULL if no <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base can be created with the requested <a class="el" href="structevent__config.html" title="Configuration for an event_base.">event_config</a>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#a4c16f1203aebc67f94791ae0240b7353" title="Create and return a new event_base to use with the rest of Libevent.">event_base_new()</a>, <a class="el" href="event_8h.html#a6e9827de8c3014417b11b48f2fe688ae" title="Deallocate all memory associated with an event_base, and free the base.">event_base_free()</a>, <a class="el" href="event__compat_8h.html#a1bf74386dd3725e1538fed2d70c1c113" title="Initialize the event API.">event_init()</a>, <a class="el" href="event_8h.html#afade5e4859dee5b85d502e5594a05cf0" title="Prepare a new, already-allocated event structure to be added.">event_assign()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acddee16b430c037ae061f966dc18eb9d"></a><!-- doxytag: member="event.h::event_base_once" ref="acddee16b430c037ae061f966dc18eb9d" args="(struct event_base *, evutil_socket_t, short, event_callback_fn, void *, const struct timeval *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_once </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event_8h.html#ac1bbbe034b87ff78b7a380c0b71064d4">event_callback_fn</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule a one-time <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>. </p>
<p>The function <a class="el" href="event_8h.html#acddee16b430c037ae061f966dc18eb9d" title="Schedule a one-time event.">event_base_once()</a> is similar to <a class="el" href="event__compat_8h.html#ace184d66066e9bac013779d8f6921d11" title="Prepare an event structure to be added.">event_set()</a>. However, it schedules a callback to be called exactly once, and does not require the caller to prepare an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> structure.</p>
<p>Note that in Libevent 2.0 and earlier, if the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> is never triggered, the internal memory used to hold it will never be freed. This may be fixed in a later version of Libevent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>an <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>a file descriptor to monitor, or -1 for no fd. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>event(s) to monitor; can be any of EV_READ | EV_WRITE, or EV_TIMEOUT </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>callback function to be invoked when the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> occurs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>an argument to be passed to the callback function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>the maximum amount of time to wait for the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>. NULL makes an EV_READ/EV_WRITE <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> make forever; NULL makes an EV_TIMEOUT <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> succees immediately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="a67067fe995561cd36a7f34ef19e030e8"></a><!-- doxytag: member="event.h::event_base_priority_init" ref="a67067fe995561cd36a7f34ef19e030e8" args="(struct event_base *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_priority_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the number of different <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> priorities. </p>
<p>By default Libevent schedules all active events with the same priority. However, some time it is desirable to process some events with a higher priority than others. For that reason, Libevent supports strict priority queues. Active events with a lower priority are always processed before events with a higher priority.</p>
<p>The number of different priorities can be set initially with the <a class="el" href="event_8h.html#a67067fe995561cd36a7f34ef19e030e8" title="Set the number of different event priorities.">event_base_priority_init()</a> function. This function should be called before the first call to <a class="el" href="event_8h.html#a01e457364ed5216a8c7bc219033b946f" title="Event dispatching loop.">event_base_dispatch()</a>. The <a class="el" href="event_8h.html#a9984a63f2edcc72bef96a188f569b367" title="Assign a priority to an event.">event_priority_set()</a> function can be used to assign a priority to an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>. By default, Libevent assigns the middle priority to all events unless their priority is explicitly set.</p>
<p>Note that urgent-priority events can starve less-urgent events: after running all urgent-priority callbacks, Libevent checks for more urgent events again, before running less-urgent events. Less-urgent events will not have their callbacks run until there are no events more urgent than them that want to be active.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eb</em>&nbsp;</td><td>the <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> structure returned by <a class="el" href="event_8h.html#a4c16f1203aebc67f94791ae0240b7353" title="Create and return a new event_base to use with the rest of Libevent.">event_base_new()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>npriorities</em>&nbsp;</td><td>the maximum number of priorities </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#a9984a63f2edcc72bef96a188f569b367" title="Assign a priority to an event.">event_priority_set()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2efd0ac7e54428d1941f212bc16ed9ce"></a><!-- doxytag: member="event.h::event_base_set" ref="a2efd0ac7e54428d1941f212bc16ed9ce" args="(struct event_base *, struct event *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associate a different <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base with an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>. </p>
<p>The <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> to be associated must not be currently active or pending.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eb</em>&nbsp;</td><td>the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ev</em>&nbsp;</td><td>the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a961de3fb39a12ff67ff030bb3caacba2"></a><!-- doxytag: member="event.h::event_config_avoid_method" ref="a961de3fb39a12ff67ff030bb3caacba2" args="(struct event_config *cfg, const char *method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_config_avoid_method </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__config.html">event_config</a> *&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>method</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enters an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> method that should be avoided into the configuration. </p>
<p>This can be used to avoid <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> mechanisms that do not support certain file descriptor types, or for debugging to avoid certain <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> mechanisms. An application can make use of multiple <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> bases to accommodate incompatible file descriptor types.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cfg</em>&nbsp;</td><td>the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> configuration object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>the name of the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> method to avoid </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a605f44836f97bb031776a7f70d53d719"></a><!-- doxytag: member="event.h::event_config_free" ref="a605f44836f97bb031776a7f70d53d719" args="(struct event_config *cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_config_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__config.html">event_config</a> *&nbsp;</td>
          <td class="paramname"> <em>cfg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocates all memory associated with an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> configuration object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cfg</em>&nbsp;</td><td>the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> configuration object to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92e238d51357e3dae6fcdd0b9e83b2d2"></a><!-- doxytag: member="event.h::event_config_new" ref="a92e238d51357e3dae6fcdd0b9e83b2d2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevent__config.html">event_config</a>* event_config_new </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a new <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> configuration object. </p>
<p>The <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> configuration object can be used to change the behavior of an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an <a class="el" href="structevent__config.html" title="Configuration for an event_base.">event_config</a> object that can be used to store configuration, or NULL if an error is encountered. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#a444afb106c45ba296d847417a3a1ef04" title="Initialize the event API.">event_base_new_with_config()</a>, <a class="el" href="event_8h.html#a605f44836f97bb031776a7f70d53d719" title="Deallocates all memory associated with an event configuration object.">event_config_free()</a>, <a class="el" href="structevent__config.html" title="Configuration for an event_base.">event_config</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2b08f2633e76290117e4a03621940948"></a><!-- doxytag: member="event.h::event_config_require_features" ref="a2b08f2633e76290117e4a03621940948" args="(struct event_config *cfg, int feature)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_config_require_features </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__config.html">event_config</a> *&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>feature</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enters a required <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> method feature that the application demands. </p>
<p>Note that not every feature or combination of features is supported on every platform. Code that requests features should be prepared to handle the case where <a class="el" href="event_8h.html#a444afb106c45ba296d847417a3a1ef04" title="Initialize the event API.">event_base_new_with_config()</a> returns NULL, as in: </p>
<pre>
     event_config_require_features(cfg, EV_FEATURE_ET);
     base = event_base_new_with_config(cfg);
     if (base == NULL) {
We can't get edge-triggered behavior here.
       event_config_require_features(cfg, 0);
       base = event_base_new_with_config(cfg);
     }
   </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cfg</em>&nbsp;</td><td>the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> configuration object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>feature</em>&nbsp;</td><td>a bitfield of one or more event_method_feature values. Replaces values from previous calls to this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#ae7da61aef13e27a3047151b696b44c80" title="A flag used to describe which features an event_base (must) provide.">event_method_feature</a>, <a class="el" href="event_8h.html#a444afb106c45ba296d847417a3a1ef04" title="Initialize the event API.">event_base_new_with_config()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac4b2697c7927fcd2167a1749f6602f29"></a><!-- doxytag: member="event.h::event_config_set_flag" ref="ac4b2697c7927fcd2167a1749f6602f29" args="(struct event_config *cfg, int flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_config_set_flag </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__config.html">event_config</a> *&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets one or more flags to configure what parts of the eventual <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> will be initialized, and how they'll work. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>event_base_config_flags, <a class="el" href="event_8h.html#a444afb106c45ba296d847417a3a1ef04" title="Initialize the event API.">event_base_new_with_config()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa12ff91d766988a170cab43c53f66143"></a><!-- doxytag: member="event.h::event_config_set_num_cpus_hint" ref="aa12ff91d766988a170cab43c53f66143" args="(struct event_config *cfg, int cpus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_config_set_num_cpus_hint </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__config.html">event_config</a> *&nbsp;</td>
          <td class="paramname"> <em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cpus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Records a hint for the number of CPUs in the system. </p>
<p>This is used for tuning thread pools, etc, for optimal performance. In Libevent 2.0, it is only on Windows, and only when IOCP is in use.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cfg</em>&nbsp;</td><td>the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> configuration object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpus</em>&nbsp;</td><td>the number of cpus </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="afcc47ab5cc9128202cbe5012c4214a6b"></a><!-- doxytag: member="event.h::event_debug_unassign" ref="afcc47ab5cc9128202cbe5012c4214a6b" args="(struct event *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_debug_unassign </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When debugging mode is enabled, informs Libevent that an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> should no longer be considered as assigned. </p>
<p>When debugging mode is not enabled, does nothing.</p>
<p>This function must only be called on a non-added <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#a3472400b8b1802550df2242673a6da37" title="Enable some relatively expensive debugging checks in Libevent that would normally...">event_enable_debug_mode()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a30a8cb96af49d18388f64de73a2d4258"></a><!-- doxytag: member="event.h::event_del" ref="a30a8cb96af49d18388f64de73a2d4258" args="(struct event *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_del </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> from the set of monitored events. </p>
<p>The function <a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258" title="Remove an event from the set of monitored events.">event_del()</a> will cancel the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> in the argument ev. If the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> has already executed or has never been added the call will have no effect.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ev</em>&nbsp;</td><td>an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> struct to be removed from the working set </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e" title="Add an event to the set of pending events.">event_add()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3472400b8b1802550df2242673a6da37"></a><!-- doxytag: member="event.h::event_enable_debug_mode" ref="a3472400b8b1802550df2242673a6da37" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_enable_debug_mode </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable some relatively expensive debugging checks in Libevent that would normally be turned off. </p>
<p>Generally, these checks cause code that would otherwise crash mysteriously to fail earlier with an assertion failure. Note that this method MUST be called before any events or event_bases have been created.</p>
<p>Debug mode can currently catch the following errors: An <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> is re-assigned while it is added Any function is called on a non-assigned <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a></p>
<p>Note that debugging mode uses memory to track every <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> that has been initialized (via event_assign, event_set, or event_new) but not yet released (via event_free or event_debug_unassign). If you want to use debug mode, and you find yourself running out of memory, you will need to use event_debug_unassign to explicitly stop tracking events that are no longer considered set-up.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#afcc47ab5cc9128202cbe5012c4214a6b" title="When debugging mode is enabled, informs Libevent that an event should no longer be...">event_debug_unassign()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad7fd53b1263bf0fdccd959a6c5a659cc"></a><!-- doxytag: member="event.h::event_free" ref="ad7fd53b1263bf0fdccd959a6c5a659cc" args="(struct event *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate a struct <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> * returned by <a class="el" href="event_8h.html#ab9a66f828d205eda84b321e32014cbbd" title="Allocate and asssign a new event structure, ready to be added.">event_new()</a>. </p>
<p>If the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> is pending or active, first make it non-pending and non-active. </p>

</div>
</div>
<a class="anchor" id="a2103c3cbf6e3e173419ebf019e29c788"></a><!-- doxytag: member="event.h::event_get_assignment" ref="a2103c3cbf6e3e173419ebf019e29c788" args="(const struct event *event, struct event_base **base_out, evutil_socket_t *fd_out, short *events_out, event_callback_fn *callback_out, void **arg_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_get_assignment </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent.html">event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> **&nbsp;</td>
          <td class="paramname"> <em>base_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evutil_socket_t *&nbsp;</td>
          <td class="paramname"> <em>fd_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&nbsp;</td>
          <td class="paramname"> <em>events_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event_8h.html#ac1bbbe034b87ff78b7a380c0b71064d4">event_callback_fn</a> *&nbsp;</td>
          <td class="paramname"> <em>callback_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>arg_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract _all_ of arguments given to construct a given <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>. </p>
<p>The <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a> is copied into *base_out, the fd is copied into *fd_out, and so on.</p>
<p>If any of the "_out" arguments is NULL, it will be ignored. </p>

</div>
</div>
<a class="anchor" id="a3881f7391324c05bd6f0c291e2682f03"></a><!-- doxytag: member="event.h::event_get_struct_event_size" ref="a3881f7391324c05bd6f0c291e2682f03" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t event_get_struct_event_size </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the size of struct <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> that the Libevent library was compiled with. </p>
<p>This will be NO GREATER than sizeof(struct event) if you're running with the same version of Libevent that your application was built with, but otherwise might not.</p>
<p>Note that it might be SMALLER than sizeof(struct event) if some future version of Libevent adds extra padding to the end of struct <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>. We might do this to help ensure ABI-compatibility between different versions of Libevent. </p>

</div>
</div>
<a class="anchor" id="af93a8115c6c8ff28db573cba84d1e488"></a><!-- doxytag: member="event.h::event_get_supported_methods" ref="af93a8115c6c8ff28db573cba84d1e488" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char** event_get_supported_methods </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets all <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> notification mechanisms supported by Libevent. </p>
<p>This functions returns the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> mechanism in order preferred by Libevent. Note that this list will include all backends that Libevent has compiled-in support for, and will not necessarily check your OS to see whether it has the required resources.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an array with pointers to the names of support methods. The end of the array is indicated by a NULL pointer. If an error is encountered NULL is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a43d7feed94477cf0a7e3e062cc17b7e1"></a><!-- doxytag: member="event.h::event_get_version" ref="a43d7feed94477cf0a7e3e062cc17b7e1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* event_get_version </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Libevent version. </p>
<p>Note that this will give you the version of the library that you're currently linked against, not the version of the headers that you've compiled against.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string containing the version number of Libevent </dd></dl>

</div>
</div>
<a class="anchor" id="abd4d1f2b4ca8e11f3bbf022244f01fa9"></a><!-- doxytag: member="event.h::event_get_version_number" ref="abd4d1f2b4ca8e11f3bbf022244f01fa9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ev_uint32_t event_get_version_number </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a numeric representation of Libevent's version. </p>
<p>Note that this will give you the version of the library that you're currently linked against, not the version of the headers you've used to compile.</p>
<p>The format uses one byte each for the major, minor, and patchlevel parts of the version number. The low-order byte is unused. For example, version 2.0.1-alpha has a numeric representation of 0x02000100 </p>

</div>
</div>
<a class="anchor" id="a5be4fbc16d90915a7d1b21ed3bae40c0"></a><!-- doxytag: member="event.h::event_initialized" ref="a5be4fbc16d90915a7d1b21ed3bae40c0" args="(const struct event *ev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_initialized </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent.html">event</a> *&nbsp;</td>
          <td class="paramname"> <em>ev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> structure might be initialized. </p>
<p>The <a class="el" href="event_8h.html#a5be4fbc16d90915a7d1b21ed3bae40c0" title="Test if an event structure might be initialized.">event_initialized()</a> function can be used to check if an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> has been initialized.</p>
<p>Warning: This function is only useful for distinguishing a a zeroed-out piece of memory from an initialized <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>, it can easily be confused by uninitialized memory. Thus, it should ONLY be used to distinguish an initialized <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> from zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ev</em>&nbsp;</td><td>an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> structure to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the structure might be initialized, or 0 if it has not been initialized </dd></dl>

</div>
</div>
<a class="anchor" id="ab9a66f828d205eda84b321e32014cbbd"></a><!-- doxytag: member="event.h::event_new" ref="ab9a66f828d205eda84b321e32014cbbd" args="(struct event_base *, evutil_socket_t, short, event_callback_fn, void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevent.html">event</a>* event_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="event_8h.html#ac1bbbe034b87ff78b7a380c0b71064d4">event_callback_fn</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate and asssign a new <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> structure, ready to be added. </p>
<p>The function <a class="el" href="event_8h.html#ab9a66f828d205eda84b321e32014cbbd" title="Allocate and asssign a new event structure, ready to be added.">event_new()</a> returns a new <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> that can be used in future calls to <a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e" title="Add an event to the set of pending events.">event_add()</a> and <a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258" title="Remove an event from the set of monitored events.">event_del()</a>. The fd and events arguments determine which conditions will trigger the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>; the callback and callback_arg arguments tell Libevent what to do when the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> becomes active.</p>
<p>If events contains one of EV_READ, EV_WRITE, or EV_READ|EV_WRITE, then fd is a file descriptor or socket that should get monitored for readiness to read, readiness to write, or readiness for either operation (respectively). If events contains EV_SIGNAL, then fd is a signal number to wait for. If events contains none of those flags, then the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> can be triggered only by a timeout or by manual activation with <a class="el" href="event_8h.html#a3262ae1dc7fe51516b43412d61301e4f" title="Make an event active.">event_active()</a>: In this case, fd must be -1.</p>
<p>The EV_PERSIST flag can also be passed in the events argument: it makes <a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e" title="Add an event to the set of pending events.">event_add()</a> persistent until <a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258" title="Remove an event from the set of monitored events.">event_del()</a> is called.</p>
<p>The EV_ET flag is compatible with EV_READ and EV_WRITE, and supported only by certain backends. It tells Libevent to use edge-triggered events.</p>
<p>The EV_TIMEOUT flag has no effect here.</p>
<p>It is okay to have multiple events all listening on the same fds; but they must either all be edge-triggered, or all not be edge triggerd.</p>
<p>When the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> becomes active, the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> loop will run the provided callbuck function, with three arguments. The first will be the provided fd value. The second will be a bitfield of the events that triggered: EV_READ, EV_WRITE, or EV_SIGNAL. Here the EV_TIMEOUT flag indicates that a timeout occurred, and EV_ET indicates that an edge-triggered <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> occurred. The third <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> will be the callback_arg pointer that you provide.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base to which the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> should be attached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>the file descriptor or signal to be monitored, or -1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>desired events to monitor: bitfield of EV_READ, EV_WRITE, EV_SIGNAL, EV_PERSIST, EV_ET. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>callback function to be invoked when the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> occurs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback_arg</em>&nbsp;</td><td>an argument to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a newly allocated struct <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> that must later be freed with <a class="el" href="event_8h.html#ad7fd53b1263bf0fdccd959a6c5a659cc" title="Deallocate a struct event * returned by event_new().">event_free()</a>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#ad7fd53b1263bf0fdccd959a6c5a659cc" title="Deallocate a struct event * returned by event_new().">event_free()</a>, <a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e" title="Add an event to the set of pending events.">event_add()</a>, <a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258" title="Remove an event from the set of monitored events.">event_del()</a>, <a class="el" href="event_8h.html#afade5e4859dee5b85d502e5594a05cf0" title="Prepare a new, already-allocated event structure to be added.">event_assign()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a49773a4e3e46f60e488ac37fb46950d9"></a><!-- doxytag: member="event.h::event_pending" ref="a49773a4e3e46f60e488ac37fb46950d9" args="(const struct event *ev, short events, struct timeval *tv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_pending </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevent.html">event</a> *&nbsp;</td>
          <td class="paramname"> <em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&nbsp;</td>
          <td class="paramname"> <em>tv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if a specific <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> is pending or scheduled. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ev</em>&nbsp;</td><td>an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> struct previously passed to <a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e" title="Add an event to the set of pending events.">event_add()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>events</em>&nbsp;</td><td>the requested <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> type; any of EV_TIMEOUT|EV_READ| EV_WRITE|EV_SIGNAL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tv</em>&nbsp;</td><td>if this field is not NULL, and the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> has a timeout, this field is set to hold the time at which the timeout will expire.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> is pending on any of the events in 'what', (that is to say, it has been added), or 0 if the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> is not added. </dd></dl>

</div>
</div>
<a class="anchor" id="a9984a63f2edcc72bef96a188f569b367"></a><!-- doxytag: member="event.h::event_priority_set" ref="a9984a63f2edcc72bef96a188f569b367" args="(struct event *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_priority_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a priority to an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ev</em>&nbsp;</td><td>an <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> struct </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>the new priority to be assigned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event__compat_8h.html#ac98d83bce2fe3e97ac655329fb30fccb" title="Set the number of different event priorities.">event_priority_init()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7409499a79a59842955928af446fe03d"></a><!-- doxytag: member="event.h::event_reinit" ref="a7409499a79a59842955928af446fe03d" args="(struct event_base *base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_reinit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&nbsp;</td>
          <td class="paramname"> <em>base</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reinitialize the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base after a fork. </p>
<p>Some <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> mechanisms do not survive across fork. The <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base needs to be reinitialized with the <a class="el" href="event_8h.html#a7409499a79a59842955928af446fe03d" title="Reinitialize the event base after a fork.">event_reinit()</a> function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> base that needs to be re-initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if some events could not be re-added. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="event_8h.html#a4c16f1203aebc67f94791ae0240b7353" title="Create and return a new event_base to use with the rest of Libevent.">event_base_new()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a73beabc6626db0da679eb8961ce3f477"></a><!-- doxytag: member="event.h::event_set_fatal_callback" ref="a73beabc6626db0da679eb8961ce3f477" args="(event_fatal_cb cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_set_fatal_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="event_8h.html#a96cbd560e6fe7cb4ebfa6000e164d752">event_fatal_cb</a>&nbsp;</td>
          <td class="paramname"> <em>cb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Override Libevent's behavior in the <a class="el" href="structevent.html" title="Structure to represent a single event.">event</a> of a fatal internal error. </p>
<p>By default, Libevent will call exit(1) if a programming error makes it impossible to continue correct operation. This function allows you to supply another callback instead. Note that if the function is ever invoked, something is wrong with your program, or with Libevent: any subsequent calls to Libevent may result in undefined behavior.</p>
<p>Libevent will (almost) always log an _EVENT_LOG_ERR message before calling this function; look at the last log message to see why Libevent has died. </p>

</div>
</div>
<a class="anchor" id="a87e59ed1dd711ced2b2a1314d3e3c1c7"></a><!-- doxytag: member="event.h::event_set_log_callback" ref="a87e59ed1dd711ced2b2a1314d3e3c1c7" args="(event_log_cb cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_set_log_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="event_8h.html#adbff4d951c4b002b955966f0ab228a76">event_log_cb</a>&nbsp;</td>
          <td class="paramname"> <em>cb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Redirect Libevent's log messages. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>a function taking two arguments: an integer severity between _EVENT_LOG_DEBUG and _EVENT_LOG_ERR, and a string. If cb is NULL, then the default log is used.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: The function you provide *must not* call any other libevent functionality. Doing so can produce undefined behavior. </p>

</div>
</div>
<a class="anchor" id="a653e38c4bdd2f3b2d7476fcee95c1a62"></a><!-- doxytag: member="event.h::event_set_mem_functions" ref="a653e38c4bdd2f3b2d7476fcee95c1a62" args="(void *(*malloc_fn)(size_t sz), void *(*realloc_fn)(void *ptr, size_t sz), void(*free_fn)(void *ptr))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_set_mem_functions </td>
          <td>(</td>
          <td class="paramtype">void *(*)(size_t sz)&nbsp;</td>
          <td class="paramname"> <em>malloc_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *ptr, size_t sz)&nbsp;</td>
          <td class="paramname"> <em>realloc_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *ptr)&nbsp;</td>
          <td class="paramname"> <em>free_fn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Override the functions that Libevent uses for memory management. </p>
<p>Usually, Libevent uses the standard libc functions malloc, realloc, and free to allocate memory. Passing replacements for those functions to <a class="el" href="event_8h.html#a653e38c4bdd2f3b2d7476fcee95c1a62" title="Override the functions that Libevent uses for memory management.">event_set_mem_functions()</a> overrides this behavior.</p>
<p>Note that all memory returned from Libevent will be allocated by the replacement functions rather than by malloc() and realloc(). Thus, if you have replaced those functions, it will not be appropriate to free() memory that you get from Libevent. Instead, you must use the free_fn replacement that you provided.</p>
<p>Note also that if you are going to call this function, you should do so before any call to any Libevent function that does allocation. Otherwise, those funtions will allocate their memory using malloc(), but then later free it using your provided free_fn.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>malloc_fn</em>&nbsp;</td><td>A replacement for malloc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>realloc_fn</em>&nbsp;</td><td>A replacement for realloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_fn</em>&nbsp;</td><td>A replacement for free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 17 Mar 2015 for libevent by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
