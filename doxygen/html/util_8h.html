<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libevent: event2/util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>event2/util.h File Reference</h1>
<p>Common convenience functions for cross-platform portability and related socket manipulations.  
<a href="#_details">More...</a></p>
<code>#include &lt;event2/event-config.h&gt;</code><br/>
<code>#include &lt;stdarg.h&gt;</code><br/>
<code>#include &lt;sys/socket.h&gt;</code><br/>

<p><a href="util_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A definition of struct addrinfo for systems that lack it.  <a href="structevutil__addrinfo.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1aa9b4bfabbeaae5ba828e808938fa2c"></a><!-- doxytag: member="util.h::ev_socklen_t" ref="a1aa9b4bfabbeaae5ba828e808938fa2c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ev_socklen_t</b>&nbsp;&nbsp;&nbsp;socklen_t</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa70c6baf0f9ac418407245579ec2a168"></a><!-- doxytag: member="util.h::EVUTIL_CLOSESOCKET" ref="aa70c6baf0f9ac418407245579ec2a168" args="(s)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_CLOSESOCKET</b>(s)&nbsp;&nbsp;&nbsp;evutil_closesocket(s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a4c296955d33624c18bd4811730caa417">evutil_offsetof</a>(type, field)&nbsp;&nbsp;&nbsp;((off_t)(&amp;((type *)0)-&gt;field))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replacement for offsetof on platforms that don't define it.  <a href="#a4c296955d33624c18bd4811730caa417"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&nbsp;&nbsp;&nbsp;int</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A type wide enough to hold the output of "socket()" or "accept()".  <a href="#a7ef0023565082a65020f6e56be59fd0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a1a42f43db6aaf6e99736329b6611175d">evutil_timercmp</a>(tvp, uvp, cmp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true iff the tvp is related to uvp according to the relational operator cmp.  <a href="#a1a42f43db6aaf6e99736329b6611175d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a393a0aee6129d132a3dd488366352bf2"></a><!-- doxytag: member="util.h::evutil_timerisset" ref="a393a0aee6129d132a3dd488366352bf2" args="(tvp)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evutil_timerisset</b>(tvp)&nbsp;&nbsp;&nbsp;((tvp)-&gt;tv_sec || (tvp)-&gt;tv_usec)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Limits for integer types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa22069b681b1061b3c363863253572fa"></a>These macros hold the largest or smallest values possible for the ev_[u]int*_t types. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6271a010b87f8e78edfb3d576d16909"></a><!-- doxytag: member="util.h::EV_INT16_MAX" ref="af6271a010b87f8e78edfb3d576d16909" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_INT16_MAX</b>&nbsp;&nbsp;&nbsp;((ev_int16_t) 0x7fffL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10afd44462363963e6cdfc20e10d250a"></a><!-- doxytag: member="util.h::EV_INT16_MIN" ref="a10afd44462363963e6cdfc20e10d250a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_INT16_MIN</b>&nbsp;&nbsp;&nbsp;((-EV_INT16_MAX) - 1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbfb8c4ad3c2b8d2bec82787c9f0eaa3"></a><!-- doxytag: member="util.h::EV_INT32_MAX" ref="adbfb8c4ad3c2b8d2bec82787c9f0eaa3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_INT32_MAX</b>&nbsp;&nbsp;&nbsp;((ev_int32_t) 0x7fffffffL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7899efdfa42ebe54093c85fbc35ba8e5"></a><!-- doxytag: member="util.h::EV_INT32_MIN" ref="a7899efdfa42ebe54093c85fbc35ba8e5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_INT32_MIN</b>&nbsp;&nbsp;&nbsp;((-EV_INT32_MAX) - 1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a5b615c4a5ffb69122263c69d8bb091"></a><!-- doxytag: member="util.h::EV_INT64_MAX" ref="a7a5b615c4a5ffb69122263c69d8bb091" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_INT64_MAX</b>&nbsp;&nbsp;&nbsp;((((ev_int64_t) 0x7fffffffL) &lt;&lt; 32) | 0xffffffffL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20073b67f3e9cdda20215246b11c4f6d"></a><!-- doxytag: member="util.h::EV_INT64_MIN" ref="a20073b67f3e9cdda20215246b11c4f6d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_INT64_MIN</b>&nbsp;&nbsp;&nbsp;((-EV_INT64_MAX) - 1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae959d5851ca0690f9da6e47fbb8056c9"></a><!-- doxytag: member="util.h::EV_INT8_MAX" ref="ae959d5851ca0690f9da6e47fbb8056c9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_INT8_MAX</b>&nbsp;&nbsp;&nbsp;127</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4adcc386a7cb06436af4618301c8b03"></a><!-- doxytag: member="util.h::EV_INT8_MIN" ref="aa4adcc386a7cb06436af4618301c8b03" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_INT8_MIN</b>&nbsp;&nbsp;&nbsp;((-EV_INT8_MAX) - 1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af85ec3c0198df9bbb370d9c70f1fd2f4"></a><!-- doxytag: member="util.h::EV_UINT16_MAX" ref="af85ec3c0198df9bbb370d9c70f1fd2f4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_UINT16_MAX</b>&nbsp;&nbsp;&nbsp;((ev_uint16_t)0xffffUL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a815ab1b931ad8d2b11da526b9071282a"></a><!-- doxytag: member="util.h::EV_UINT32_MAX" ref="a815ab1b931ad8d2b11da526b9071282a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_UINT32_MAX</b>&nbsp;&nbsp;&nbsp;((ev_uint32_t)0xffffffffUL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34cff4b5f64165a133fd51d3004964db"></a><!-- doxytag: member="util.h::EV_UINT64_MAX" ref="a34cff4b5f64165a133fd51d3004964db" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_UINT64_MAX</b>&nbsp;&nbsp;&nbsp;((((ev_uint64_t)0xffffffffUL) &lt;&lt; 32) | 0xffffffffUL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8af5a509193ad75cdd20e77a8422d84d"></a><!-- doxytag: member="util.h::EV_UINT8_MAX" ref="a8af5a509193ad75cdd20e77a8422d84d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_UINT8_MAX</b>&nbsp;&nbsp;&nbsp;255</td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard integer types.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb9efe3e8071cb39ecaa9bca905f2b9f1"></a>Integer type definitions for types that are supposed to be defined in the C99-specified stdint.h.</p>
<p>Shamefully, some platforms do not include stdint.h, so we need to replace it. (If you are on a platform like this, your C headers are now over 10 years out of date. You should bug them to do something about this.)</p>
<p>We define:</p>
<dl>
<dt>ev_uint64_t, ev_uint32_t, ev_uint16_t, ev_uint8_t </dt>
<dd>unsigned integer types of exactly 64, 32, 16, and 8 bits respectively. </dd>
<dt>ev_int64_t, ev_int32_t, ev_int16_t, ev_int8_t </dt>
<dd>signed integer types of exactly 64, 32, 16, and 8 bits respectively. </dd>
<dt>ev_uintptr_t, ev_intptr_t </dt>
<dd>unsigned/signed integers large enough to hold a pointer without loss of bits. </dd>
<dt>ev_ssize_t </dt>
<dd>A signed type of the same size as size_t </dd>
<dt>ev_off_t </dt>
<dd>A signed type typically used to represent offsets within a (potentially large) file </dd>
</dl>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5943ff8aa2063dd531c7cbc7f20a1e55"></a><!-- doxytag: member="util.h::ev_int16_t" ref="a5943ff8aa2063dd531c7cbc7f20a1e55" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ev_int16_t</b>&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91a83fba6bcb61a80774e2533fa1da1b"></a><!-- doxytag: member="util.h::ev_int32_t" ref="a91a83fba6bcb61a80774e2533fa1da1b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ev_int32_t</b>&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22ebbcfd82e30a022792cc0aef0a0049"></a><!-- doxytag: member="util.h::ev_int64_t" ref="a22ebbcfd82e30a022792cc0aef0a0049" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ev_int64_t</b>&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab642ae86b43a6d75c52811eb686f0837"></a><!-- doxytag: member="util.h::ev_int8_t" ref="ab642ae86b43a6d75c52811eb686f0837" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ev_int8_t</b>&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4913c495b489d419353b3d1512505ea2"></a><!-- doxytag: member="util.h::ev_intptr_t" ref="a4913c495b489d419353b3d1512505ea2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ev_intptr_t</b>&nbsp;&nbsp;&nbsp;ev_int32_t</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f968b0d453ef37a233e2d40860296a6"></a><!-- doxytag: member="util.h::ev_off_t" ref="a2f968b0d453ef37a233e2d40860296a6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ev_off_t</b>&nbsp;&nbsp;&nbsp;off_t</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fce2c187cee381db4bf5276f76a39e8"></a><!-- doxytag: member="util.h::ev_ssize_t" ref="a9fce2c187cee381db4bf5276f76a39e8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ev_ssize_t</b>&nbsp;&nbsp;&nbsp;ssize_t</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cc03c0ef4fc4327e373b079528ca049"></a><!-- doxytag: member="util.h::ev_uint16_t" ref="a9cc03c0ef4fc4327e373b079528ca049" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ev_uint16_t</b>&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43b2386e75123100c6179f7f14f8fda2"></a><!-- doxytag: member="util.h::ev_uint32_t" ref="a43b2386e75123100c6179f7f14f8fda2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ev_uint32_t</b>&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58f6d4822116b1492238ea9b0b1469f9"></a><!-- doxytag: member="util.h::ev_uint64_t" ref="a58f6d4822116b1492238ea9b0b1469f9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ev_uint64_t</b>&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9052cd1d14b92812de0796d84af5604"></a><!-- doxytag: member="util.h::ev_uint8_t" ref="ad9052cd1d14b92812de0796d84af5604" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ev_uint8_t</b>&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bf36939a205bd52df25c40fe44b7fd7"></a><!-- doxytag: member="util.h::ev_uintptr_t" ref="a6bf36939a205bd52df25c40fe44b7fd7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ev_uintptr_t</b>&nbsp;&nbsp;&nbsp;ev_uint32_t</td></tr>
<tr><td colspan="2"><div class="groupHeader">Limits for SIZE_T and SSIZE_T</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpf5322ad6da93744a31594c48e9f91bb6"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b6a9c2fa6a1ba42d79e2f9118f9670c"></a><!-- doxytag: member="util.h::EV_SIZE_MAX" ref="a2b6a9c2fa6a1ba42d79e2f9118f9670c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_SIZE_MAX</b>&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a142028f0a0d7248168a3aaca652851c3"></a><!-- doxytag: member="util.h::EV_SSIZE_MAX" ref="a142028f0a0d7248168a3aaca652851c3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_SSIZE_MAX</b>&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59e6c7724ce1f7e0562d6e24021acb10"></a><!-- doxytag: member="util.h::EV_SSIZE_MIN" ref="a59e6c7724ce1f7e0562d6e24021acb10" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EV_SSIZE_MIN</b>&nbsp;&nbsp;&nbsp;((-EV_SSIZE_MAX) - 1)</td></tr>
<tr><td colspan="2"><div class="groupHeader">evutil_getaddrinfo() error codes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpc3bbc2b66cd972855cbba0bcdab30dbc"></a>These values are possible error codes for <a class="el" href="util_8h.html#af72dd0e3c31f03a1de0fd297b1b2691b" title="This function clones getaddrinfo for systems that don&#39;t have it.">evutil_getaddrinfo()</a> and related functions. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1162c61313f61eff48a9533a3309f739"></a><!-- doxytag: member="util.h::EVUTIL_AI_ADDRCONFIG" ref="a1162c61313f61eff48a9533a3309f739" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_ADDRCONFIG</b>&nbsp;&nbsp;&nbsp;0x40000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a437bacd5a8915b541a3e38c965932297"></a><!-- doxytag: member="util.h::EVUTIL_AI_ALL" ref="a437bacd5a8915b541a3e38c965932297" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_ALL</b>&nbsp;&nbsp;&nbsp;0x20000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b1fbbc2f3b038e60fd97a620bff9230"></a><!-- doxytag: member="util.h::EVUTIL_AI_CANONNAME" ref="a1b1fbbc2f3b038e60fd97a620bff9230" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_CANONNAME</b>&nbsp;&nbsp;&nbsp;0x2000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a145a3766f56a33a6d845cfd0dba1890d"></a><!-- doxytag: member="util.h::EVUTIL_AI_NUMERICHOST" ref="a145a3766f56a33a6d845cfd0dba1890d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_NUMERICHOST</b>&nbsp;&nbsp;&nbsp;0x4000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a067c788a683f74e43e87098a68b37e69"></a><!-- doxytag: member="util.h::EVUTIL_AI_NUMERICSERV" ref="a067c788a683f74e43e87098a68b37e69" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_NUMERICSERV</b>&nbsp;&nbsp;&nbsp;0x8000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2611f48d74207f6e996189e71ca9742f"></a><!-- doxytag: member="util.h::EVUTIL_AI_PASSIVE" ref="a2611f48d74207f6e996189e71ca9742f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_PASSIVE</b>&nbsp;&nbsp;&nbsp;0x1000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbc6a3beb4ecf5b653a871949a49b53a"></a><!-- doxytag: member="util.h::EVUTIL_AI_V4MAPPED" ref="abbc6a3beb4ecf5b653a871949a49b53a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_V4MAPPED</b>&nbsp;&nbsp;&nbsp;0x10000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf1a2e7213ceab1be80a752ec8cbd109"></a><!-- doxytag: member="util.h::EVUTIL_EAI_ADDRFAMILY" ref="aaf1a2e7213ceab1be80a752ec8cbd109" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_ADDRFAMILY</b>&nbsp;&nbsp;&nbsp;-901</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1cb726c0bf1ff8907dfc3b4171742ac"></a><!-- doxytag: member="util.h::EVUTIL_EAI_AGAIN" ref="ae1cb726c0bf1ff8907dfc3b4171742ac" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_AGAIN</b>&nbsp;&nbsp;&nbsp;-902</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5f1ed6215f25714f371551cb7467ad7"></a><!-- doxytag: member="util.h::EVUTIL_EAI_BADFLAGS" ref="ac5f1ed6215f25714f371551cb7467ad7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_BADFLAGS</b>&nbsp;&nbsp;&nbsp;-903</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34127164b338d82707034566b100b4cb"></a><!-- doxytag: member="util.h::EVUTIL_EAI_CANCEL" ref="a34127164b338d82707034566b100b4cb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_CANCEL</b>&nbsp;&nbsp;&nbsp;-90001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76916ba557e677dafe9c1fd7da89f2b3"></a><!-- doxytag: member="util.h::EVUTIL_EAI_FAIL" ref="a76916ba557e677dafe9c1fd7da89f2b3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_FAIL</b>&nbsp;&nbsp;&nbsp;-904</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0df5ae5495d39cb471ef5403c2823ab4"></a><!-- doxytag: member="util.h::EVUTIL_EAI_FAMILY" ref="a0df5ae5495d39cb471ef5403c2823ab4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_FAMILY</b>&nbsp;&nbsp;&nbsp;-905</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03351808979dfac04060773ebfd3c06b"></a><!-- doxytag: member="util.h::EVUTIL_EAI_MEMORY" ref="a03351808979dfac04060773ebfd3c06b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_MEMORY</b>&nbsp;&nbsp;&nbsp;-906</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d7b69a78006c0f48d88f88e9b55334b"></a><!-- doxytag: member="util.h::EVUTIL_EAI_NODATA" ref="a1d7b69a78006c0f48d88f88e9b55334b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_NODATA</b>&nbsp;&nbsp;&nbsp;-907</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab100c4d4e222d5cdfa2aebcf3a0140e9"></a><!-- doxytag: member="util.h::EVUTIL_EAI_NONAME" ref="ab100c4d4e222d5cdfa2aebcf3a0140e9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_NONAME</b>&nbsp;&nbsp;&nbsp;-908</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2cc1d8d4eead1bc0e15eaae2edaf668"></a><!-- doxytag: member="util.h::EVUTIL_EAI_SERVICE" ref="ab2cc1d8d4eead1bc0e15eaae2edaf668" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_SERVICE</b>&nbsp;&nbsp;&nbsp;-909</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac30b335f48757b2ba10da69f80a87a46"></a><!-- doxytag: member="util.h::EVUTIL_EAI_SOCKTYPE" ref="ac30b335f48757b2ba10da69f80a87a46" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_SOCKTYPE</b>&nbsp;&nbsp;&nbsp;-910</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03273ded49de60ab08e489b7d5d5e17e"></a><!-- doxytag: member="util.h::EVUTIL_EAI_SYSTEM" ref="a03273ded49de60ab08e489b7d5d5e17e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_SYSTEM</b>&nbsp;&nbsp;&nbsp;-911</td></tr>
<tr><td colspan="2"><div class="groupHeader">Socket error functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa0f9f860daf31b89470c36b87ba1bd7f"></a>These functions are needed for making programs compatible between Windows and Unix-like platforms.</p>
<p>You see, Winsock handles socket errors differently from the rest of the world. Elsewhere, a socket error is like any other error and is stored in errno. But winsock functions require you to retrieve the error with a special function, and don't let you use strerror for the error codes. And handling EWOULDBLOCK is ... different. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8b4fae7790599f7b58e8c269f6b29d8"></a><!-- doxytag: member="util.h::EVUTIL_SET_SOCKET_ERROR" ref="ae8b4fae7790599f7b58e8c269f6b29d8" args="(errcode)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ae8b4fae7790599f7b58e8c269f6b29d8">EVUTIL_SET_SOCKET_ERROR</a>(errcode)&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace the most recent socket error with errcode. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9a94a2e72982e708333486cf72aab941">EVUTIL_SOCKET_ERROR</a>()&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the most recent socket error.  <a href="#a9a94a2e72982e708333486cf72aab941"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ad5ea5ef81ddcfb299e4867d362ad8654">evutil_socket_error_to_string</a>(errcode)&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a socket error to a string.  <a href="#ad5ea5ef81ddcfb299e4867d362ad8654"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a28f952fb0f16b057d931fd38ee9bdf5e">evutil_socket_geterror</a>(sock)&nbsp;&nbsp;&nbsp;...</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the most recent socket error to occur on sock.  <a href="#a28f952fb0f16b057d931fd38ee9bdf5e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Manipulation macros for struct timeval.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb5781dd4bec0ea17b0d67f2ad8c0c6bf"></a>We define replacements for timeradd, timersub, timerclear, timercmp, and timerisset. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evutil_timeradd</b>(tvp, uvp, vvp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add4999b82eab8bcb8becc8cb079341a0"></a><!-- doxytag: member="util.h::evutil_timerclear" ref="add4999b82eab8bcb8becc8cb079341a0" args="(tvp)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evutil_timerclear</b>(tvp)&nbsp;&nbsp;&nbsp;(tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>evutil_timersub</b>(tvp, uvp, vvp)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a56923d1aaa25b89ccb8d3b2def643ed3">evutil_ascii_strcasecmp</a> (const char *str1, const char *str2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As strcasecmp, but always compares the characters in locale-independent ASCII.  <a href="#a56923d1aaa25b89ccb8d3b2def643ed3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a4a967b00e4ef0025d7e865f1e28f826b">evutil_ascii_strncasecmp</a> (const char *str1, const char *str2, size_t n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As strncasecmp, but always compares the characters in locale-independent ASCII.  <a href="#a4a967b00e4ef0025d7e865f1e28f826b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a3950f08bc7b4ab52d519eabe7edd1889">evutil_closesocket</a> (evutil_socket_t sock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do the platform-specific call needed to close a socket returned from socket() or accept().  <a href="#a3950f08bc7b4ab52d519eabe7edd1889"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ad43029540a4878bc49b343e7b0573ef3">evutil_freeaddrinfo</a> (struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *ai)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release storage allocated by evutil_getaddrinfo or evdns_getaddrinfo.  <a href="#ad43029540a4878bc49b343e7b0573ef3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09249a88abca73bf3b739bb0dcbc0c72"></a><!-- doxytag: member="util.h::evutil_gai_strerror" ref="a09249a88abca73bf3b739bb0dcbc0c72" args="(int err)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>evutil_gai_strerror</b> (int err)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#af72dd0e3c31f03a1de0fd297b1b2691b">evutil_getaddrinfo</a> (const char *nodename, const char *servname, const struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *hints_in, struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> **res)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function clones getaddrinfo for systems that don't have it.  <a href="#af72dd0e3c31f03a1de0fd297b1b2691b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ca2db950ffe1e218494428a4c6be268"></a><!-- doxytag: member="util.h::evutil_gettimeofday" ref="a2ca2db950ffe1e218494428a4c6be268" args="(struct timeval *tv, struct timezone *tz)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>evutil_gettimeofday</b> (struct timeval *tv, struct timezone *tz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#af21b0b8bc5a13594eccd492d564b64c0">evutil_inet_ntop</a> (int af, const void *src, char *dst, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replacement for inet_ntop for platforms which lack it.  <a href="#af21b0b8bc5a13594eccd492d564b64c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a1457e5a0b461a99ca9d6d5c19e9dd65f">evutil_inet_pton</a> (int af, const char *src, void *dst)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replacement for inet_pton for platforms which lack it.  <a href="#a1457e5a0b461a99ca9d6d5c19e9dd65f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a050bec12aefa132d8e94e712332f38d9">evutil_make_listen_socket_reuseable</a> (evutil_socket_t sock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do platform-specific operations to make a listener socket reusable.  <a href="#a050bec12aefa132d8e94e712332f38d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ac5975b58b3c7b7360be7ac1a1df135df">evutil_make_socket_closeonexec</a> (evutil_socket_t sock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do platform-specific operations as needed to close a socket upon a successful execution of one of the exec*() functions.  <a href="#ac5975b58b3c7b7360be7ac1a1df135df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a1b5741a91b809c7f2594c96aa66d4aac">evutil_make_socket_nonblocking</a> (evutil_socket_t sock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do platform-specific operations as needed to make a socket nonblocking.  <a href="#a1b5741a91b809c7f2594c96aa66d4aac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a8f0601b249a1eef50f16f519df26fe30">evutil_parse_sockaddr_port</a> (const char *str, struct sockaddr *out, int *outlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse an IPv4 or IPv6 address, with optional port, from a string.  <a href="#a8f0601b249a1eef50f16f519df26fe30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a3d19c11db91a8831b80104346b451a43">evutil_secure_rng_add_bytes</a> (const char *dat, size_t datlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seed the random number generator with extra random bytes.  <a href="#a3d19c11db91a8831b80104346b451a43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#af1ed05b1100d3b6f08a3b66f8c58ad29">evutil_secure_rng_get_bytes</a> (void *buf, size_t n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate n bytes of secure pseudorandom data, and store them in buf.  <a href="#af1ed05b1100d3b6f08a3b66f8c58ad29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a40a0ef996a117d2e85d3a6a5a94938fc">evutil_secure_rng_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seed the secure random number generator if needed, and return 0 on success or -1 on failure.  <a href="#a40a0ef996a117d2e85d3a6a5a94938fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55dc7427a539b8c710acf6eb117364e1"></a><!-- doxytag: member="util.h::evutil_snprintf" ref="a55dc7427a539b8c710acf6eb117364e1" args="(char *buf, size_t buflen, const char *format,...)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a55dc7427a539b8c710acf6eb117364e1">evutil_snprintf</a> (char *buf, size_t buflen, const char *format,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replacement for snprintf to get consistent behavior on platforms for which the return value of snprintf does not conform to C99. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ae2397b592e9965630a1bf78a6a688859">evutil_sockaddr_cmp</a> (const struct sockaddr *sa1, const struct sockaddr *sa2, int include_port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two sockaddrs; return 0 if they are equal, or less than 0 if sa1 preceeds sa2, or greater than 0 if sa1 follows sa2.  <a href="#ae2397b592e9965630a1bf78a6a688859"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a405ce3c11b9672b7547669877c294935">evutil_socketpair</a> (int d, int type, int protocol, evutil_socket_t sv[2])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create two new sockets that are connected to each other.  <a href="#a405ce3c11b9672b7547669877c294935"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ev_int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a87762fbc9974b211df3babfacd99df19">evutil_strtoll</a> (const char *s, char **endptr, int base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a 64-bit value from a string.  <a href="#a87762fbc9974b211df3babfacd99df19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80bb0d174aa64218ce077b0c79df3e0f"></a><!-- doxytag: member="util.h::evutil_vsnprintf" ref="a80bb0d174aa64218ce077b0c79df3e0f" args="(char *buf, size_t buflen, const char *format, va_list ap)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a80bb0d174aa64218ce077b0c79df3e0f">evutil_vsnprintf</a> (char *buf, size_t buflen, const char *format, va_list ap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replacement for vsnprintf to get consistent behavior on platforms for which the return value of snprintf does not conform to C99. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Common convenience functions for cross-platform portability and related socket manipulations. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a4c296955d33624c18bd4811730caa417"></a><!-- doxytag: member="util.h::evutil_offsetof" ref="a4c296955d33624c18bd4811730caa417" args="(type, field)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_offsetof</td>
          <td>(</td>
          <td class="paramtype">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">field&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((off_t)(&amp;((type *)0)-&gt;field))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replacement for offsetof on platforms that don't define it. </p>

</div>
</div>
<a class="anchor" id="a9a94a2e72982e708333486cf72aab941"></a><!-- doxytag: member="util.h::EVUTIL_SOCKET_ERROR" ref="a9a94a2e72982e708333486cf72aab941" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVUTIL_SOCKET_ERROR</td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;...</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the most recent socket error. </p>
<p>Not idempotent on all platforms. </p>

</div>
</div>
<a class="anchor" id="ad5ea5ef81ddcfb299e4867d362ad8654"></a><!-- doxytag: member="util.h::evutil_socket_error_to_string" ref="ad5ea5ef81ddcfb299e4867d362ad8654" args="(errcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_socket_error_to_string</td>
          <td>(</td>
          <td class="paramtype">errcode&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;...</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert a socket error to a string. </p>

</div>
</div>
<a class="anchor" id="a28f952fb0f16b057d931fd38ee9bdf5e"></a><!-- doxytag: member="util.h::evutil_socket_geterror" ref="a28f952fb0f16b057d931fd38ee9bdf5e" args="(sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_socket_geterror</td>
          <td>(</td>
          <td class="paramtype">sock&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;...</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the most recent socket error to occur on sock. </p>

</div>
</div>
<a class="anchor" id="a7ef0023565082a65020f6e56be59fd0b"></a><!-- doxytag: member="util.h::evutil_socket_t" ref="a7ef0023565082a65020f6e56be59fd0b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_socket_t&nbsp;&nbsp;&nbsp;int</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A type wide enough to hold the output of "socket()" or "accept()". </p>
<p>On Windows, this is an intptr_t; elsewhere, it is an int. </p>

</div>
</div>
<a class="anchor" id="a6182f91a8aede88fac748b3f424cbb6d"></a><!-- doxytag: member="util.h::evutil_timeradd" ref="a6182f91a8aede88fac748b3f424cbb6d" args="(tvp, uvp, vvp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_timeradd</td>
          <td>(</td>
          <td class="paramtype">tvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vvp&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                                            \
                (vvp)-&gt;tv_sec = (tvp)-&gt;tv_sec + (uvp)-&gt;tv_sec;          \
                (vvp)-&gt;tv_usec = (tvp)-&gt;tv_usec + (uvp)-&gt;tv_usec;       \
                <span class="keywordflow">if</span> ((vvp)-&gt;tv_usec &gt;= 1000000) {                        \
                        (vvp)-&gt;tv_sec++;                                \
                        (vvp)-&gt;tv_usec -= 1000000;                      \
                }                                                       \
        } <span class="keywordflow">while</span> (0)
</pre></div>
</div>
</div>
<a class="anchor" id="a1a42f43db6aaf6e99736329b6611175d"></a><!-- doxytag: member="util.h::evutil_timercmp" ref="a1a42f43db6aaf6e99736329b6611175d" args="(tvp, uvp, cmp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_timercmp</td>
          <td>(</td>
          <td class="paramtype">tvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cmp&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(((tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec) ?                             \
         ((tvp)-&gt;tv_usec cmp (uvp)-&gt;tv_usec) :                          \
         ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec))
</pre></div>
<p>Return true iff the tvp is related to uvp according to the relational operator cmp. </p>
<p>Recognized values for cmp are ==, &lt;=, &lt;, &gt;=, and &gt;. </p>

</div>
</div>
<a class="anchor" id="ab75cdb8eae7b33eac738c46356967399"></a><!-- doxytag: member="util.h::evutil_timersub" ref="ab75cdb8eae7b33eac738c46356967399" args="(tvp, uvp, vvp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_timersub</td>
          <td>(</td>
          <td class="paramtype">tvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vvp&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                                            \
                (vvp)-&gt;tv_sec = (tvp)-&gt;tv_sec - (uvp)-&gt;tv_sec;          \
                (vvp)-&gt;tv_usec = (tvp)-&gt;tv_usec - (uvp)-&gt;tv_usec;       \
                <span class="keywordflow">if</span> ((vvp)-&gt;tv_usec &lt; 0) {                               \
                        (vvp)-&gt;tv_sec--;                                \
                        (vvp)-&gt;tv_usec += 1000000;                      \
                }                                                       \
        } <span class="keywordflow">while</span> (0)
</pre></div>
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a56923d1aaa25b89ccb8d3b2def643ed3"></a><!-- doxytag: member="util.h::evutil_ascii_strcasecmp" ref="a56923d1aaa25b89ccb8d3b2def643ed3" args="(const char *str1, const char *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evutil_ascii_strcasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>As strcasecmp, but always compares the characters in locale-independent ASCII. </p>
<p>That's useful if you're handling data in ASCII-based protocols. </p>

</div>
</div>
<a class="anchor" id="a4a967b00e4ef0025d7e865f1e28f826b"></a><!-- doxytag: member="util.h::evutil_ascii_strncasecmp" ref="a4a967b00e4ef0025d7e865f1e28f826b" args="(const char *str1, const char *str2, size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evutil_ascii_strncasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>As strncasecmp, but always compares the characters in locale-independent ASCII. </p>
<p>That's useful if you're handling data in ASCII-based protocols. </p>

</div>
</div>
<a class="anchor" id="a3950f08bc7b4ab52d519eabe7edd1889"></a><!-- doxytag: member="util.h::evutil_closesocket" ref="a3950f08bc7b4ab52d519eabe7edd1889" args="(evutil_socket_t sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evutil_closesocket </td>
          <td>(</td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do the platform-specific call needed to close a socket returned from socket() or accept(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>The socket to be closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ad43029540a4878bc49b343e7b0573ef3"></a><!-- doxytag: member="util.h::evutil_freeaddrinfo" ref="ad43029540a4878bc49b343e7b0573ef3" args="(struct evutil_addrinfo *ai)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evutil_freeaddrinfo </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *&nbsp;</td>
          <td class="paramname"> <em>ai</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release storage allocated by evutil_getaddrinfo or evdns_getaddrinfo. </p>

</div>
</div>
<a class="anchor" id="af72dd0e3c31f03a1de0fd297b1b2691b"></a><!-- doxytag: member="util.h::evutil_getaddrinfo" ref="af72dd0e3c31f03a1de0fd297b1b2691b" args="(const char *nodename, const char *servname, const struct evutil_addrinfo *hints_in, struct evutil_addrinfo **res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evutil_getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nodename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>servname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *&nbsp;</td>
          <td class="paramname"> <em>hints_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> **&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function clones getaddrinfo for systems that don't have it. </p>
<p>For full details, see RFC 3493, section 6.1.</p>
<p>Limitations:</p>
<ul>
<li>When the system has no getaddrinfo, we fall back to gethostbyname_r or gethostbyname, with their attendant issues.</li>
<li>The AI_V4MAPPED and AI_ALL flags are not currently implemented.</li>
</ul>
<p>For a nonblocking variant, see evdns_getaddrinfo. </p>

</div>
</div>
<a class="anchor" id="af21b0b8bc5a13594eccd492d564b64c0"></a><!-- doxytag: member="util.h::evutil_inet_ntop" ref="af21b0b8bc5a13594eccd492d564b64c0" args="(int af, const void *src, char *dst, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* evutil_inet_ntop </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replacement for inet_ntop for platforms which lack it. </p>

</div>
</div>
<a class="anchor" id="a1457e5a0b461a99ca9d6d5c19e9dd65f"></a><!-- doxytag: member="util.h::evutil_inet_pton" ref="a1457e5a0b461a99ca9d6d5c19e9dd65f" args="(int af, const char *src, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evutil_inet_pton </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dst</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replacement for inet_pton for platforms which lack it. </p>

</div>
</div>
<a class="anchor" id="a050bec12aefa132d8e94e712332f38d9"></a><!-- doxytag: member="util.h::evutil_make_listen_socket_reuseable" ref="a050bec12aefa132d8e94e712332f38d9" args="(evutil_socket_t sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evutil_make_listen_socket_reuseable </td>
          <td>(</td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do platform-specific operations to make a listener socket reusable. </p>
<p>Specifically, we want to make sure that another program will be able to bind this address right after we've closed the listener.</p>
<p>This differs from Windows's interpretation of "reusable", which allows multiple listeners to bind the same address at the same time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>The socket to make reusable </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ac5975b58b3c7b7360be7ac1a1df135df"></a><!-- doxytag: member="util.h::evutil_make_socket_closeonexec" ref="ac5975b58b3c7b7360be7ac1a1df135df" args="(evutil_socket_t sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evutil_make_socket_closeonexec </td>
          <td>(</td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do platform-specific operations as needed to close a socket upon a successful execution of one of the exec*() functions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>The socket to be closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a1b5741a91b809c7f2594c96aa66d4aac"></a><!-- doxytag: member="util.h::evutil_make_socket_nonblocking" ref="a1b5741a91b809c7f2594c96aa66d4aac" args="(evutil_socket_t sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evutil_make_socket_nonblocking </td>
          <td>(</td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname"> <em>sock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do platform-specific operations as needed to make a socket nonblocking. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>The socket to make nonblocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a8f0601b249a1eef50f16f519df26fe30"></a><!-- doxytag: member="util.h::evutil_parse_sockaddr_port" ref="a8f0601b249a1eef50f16f519df26fe30" args="(const char *str, struct sockaddr *out, int *outlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evutil_parse_sockaddr_port </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>outlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse an IPv4 or IPv6 address, with optional port, from a string. </p>
<p>Recognized formats are:</p>
<ul>
<li>[IPv6Address]:port</li>
<li>[IPv6Address]</li>
<li>IPv6Address</li>
<li>IPv4Address:port</li>
<li>IPv4Address</li>
</ul>
<p>If no port is specified, the port in the output is set to 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to parse. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>A struct sockaddr to hold the result. This should probably be a struct sockaddr_storage. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>outlen</em>&nbsp;</td><td>A pointer to the number of bytes that that 'out' can safely hold. Set to the number of bytes used in 'out' on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 if the address is not well-formed, if the port is out of range, or if out is not large enough to hold the result. Otherwise returns 0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d19c11db91a8831b80104346b451a43"></a><!-- doxytag: member="util.h::evutil_secure_rng_add_bytes" ref="a3d19c11db91a8831b80104346b451a43" args="(const char *dat, size_t datlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evutil_secure_rng_add_bytes </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>datlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seed the random number generator with extra random bytes. </p>
<p>You should almost never need to call this function; it should be sufficient to invoke <a class="el" href="util_8h.html#a40a0ef996a117d2e85d3a6a5a94938fc" title="Seed the secure random number generator if needed, and return 0 on success or -1...">evutil_secure_rng_init()</a>, or let Libevent take care of calling <a class="el" href="util_8h.html#a40a0ef996a117d2e85d3a6a5a94938fc" title="Seed the secure random number generator if needed, and return 0 on success or -1...">evutil_secure_rng_init()</a> on its own.</p>
<p>If you call this function as a _replacement_ for the regular entropy sources, then you need to be sure that your input contains a fairly large amount of strong entropy. Doing so is notoriously hard: most people who try get it wrong. Watch out!</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dat</em>&nbsp;</td><td>a buffer full of a strong source of random numbers </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>datlen</em>&nbsp;</td><td>the number of bytes to read from datlen </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1ed05b1100d3b6f08a3b66f8c58ad29"></a><!-- doxytag: member="util.h::evutil_secure_rng_get_bytes" ref="af1ed05b1100d3b6f08a3b66f8c58ad29" args="(void *buf, size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evutil_secure_rng_get_bytes </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate n bytes of secure pseudorandom data, and store them in buf. </p>
<p>By default, Libevent uses an ARC4-based random number generator, seeded using the platform's entropy source (/dev/urandom on Unix-like systems; CryptGenRandom on Windows). </p>

</div>
</div>
<a class="anchor" id="a40a0ef996a117d2e85d3a6a5a94938fc"></a><!-- doxytag: member="util.h::evutil_secure_rng_init" ref="a40a0ef996a117d2e85d3a6a5a94938fc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evutil_secure_rng_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seed the secure random number generator if needed, and return 0 on success or -1 on failure. </p>
<p>It is okay to call this function more than once; it will still return 0 if the RNG has been successfully seeded and -1 if it can't be seeded.</p>
<p>Ordinarily you don't need to call this function from your own code; Libevent will seed the RNG itself the first time it needs good random numbers. You only need to call it if (a) you want to double-check that one of the seeding methods did succeed, or (b) you plan to drop the capability to seed (by chrooting, or dropping capabilities, or whatever), and you want to make sure that seeding happens before your program loses the ability to do it. </p>

</div>
</div>
<a class="anchor" id="ae2397b592e9965630a1bf78a6a688859"></a><!-- doxytag: member="util.h::evutil_sockaddr_cmp" ref="ae2397b592e9965630a1bf78a6a688859" args="(const struct sockaddr *sa1, const struct sockaddr *sa2, int include_port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evutil_sockaddr_cmp </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr *&nbsp;</td>
          <td class="paramname"> <em>sa1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&nbsp;</td>
          <td class="paramname"> <em>sa2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>include_port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare two sockaddrs; return 0 if they are equal, or less than 0 if sa1 preceeds sa2, or greater than 0 if sa1 follows sa2. </p>
<p>If include_port is true, consider the port as well as the address. Only implemented for AF_INET and AF_INET6 addresses. The ordering is not guaranteed to remain the same between Libevent versions. </p>

</div>
</div>
<a class="anchor" id="a405ce3c11b9672b7547669877c294935"></a><!-- doxytag: member="util.h::evutil_socketpair" ref="a405ce3c11b9672b7547669877c294935" args="(int d, int type, int protocol, evutil_socket_t sv[2])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evutil_socketpair </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evutil_socket_t&nbsp;</td>
          <td class="paramname"> <em>sv</em>[2]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create two new sockets that are connected to each other. </p>
<p>On Unix, this simply calls socketpair(). On Windows, it uses the loopback network interface on 127.0.0.1, and only AF_INET,SOCK_STREAM are supported.</p>
<p>(This may fail on some Windows hosts where firewall software has cleverly decided to keep 127.0.0.1 from talking to itself.)</p>
<p>Parameters and return values are as for socketpair() </p>

</div>
</div>
<a class="anchor" id="a87762fbc9974b211df3babfacd99df19"></a><!-- doxytag: member="util.h::evutil_strtoll" ref="a87762fbc9974b211df3babfacd99df19" args="(const char *s, char **endptr, int base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ev_int64_t evutil_strtoll </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse a 64-bit value from a string. </p>
<p>Arguments are as for strtol. </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 17 Mar 2015 for libevent by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
